/*
 *  Copyright(c) 2019-2021 Qualcomm Innovation Center, Inc. All Rights Reserved.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#ifndef _HMX_MACROS_H
#define _HMX_MACROS_H

#include "q6v_defines.h"

#define FPRINTF(...) 

#define sim_mem_read1(X, Y, ADDR) mem_read1(env, ADDR)
#define sim_mem_read2(X, Y, ADDR) mem_read2(env, ADDR)
#define sim_mem_read4(X, Y, ADDR) mem_read4(env, ADDR)
#define sim_mem_read8(X, Y, ADDR) mem_read8(env, ADDR)

#define tmp_Insn Insn;

#define fMX_NONE()
#define fMX_HMX_FLT()
#define fMX_HMX_FLT_EXP()
#define fMX_SELECT_ACCUMULATOR_FXP(ACC, ROW,COL,SEL) { if (thread->processor_ptr->arch_proc_options->QDSP6_MX_SUB_COLS>1) { fMX_COMBINE_REDUNDANT_ACC(ACC, THREAD2STRUCT->accum_fxp[ROW][COL].w[SEL+2], THREAD2STRUCT->accum_fxp[ROW][COL].w[SEL+0], ROW, COL, SEL); } else { ACC = THREAD2STRUCT->accum_fxp[ROW][COL].w[SEL]; } }
#define fMX_SHL16_ACCUMULATOR_FXP(ROW,COL,SELECT) { THREAD2STRUCT->future_accum_fxp[ROW][COL].w[SELECT+0] <<= 16; THREAD2STRUCT->future_accum_fxp[ROW][COL].w[SELECT+2] <<= 16; }
#define fMX_SELECT_ACCUMULATOR_FLT(ACC,OVF,ROW,COL,SELECT) { if (thread->processor_ptr->arch_proc_options->QDSP6_MX_FP_ACC_EXP) { hmx_xfp_t acc_xfp = THREAD2STRUCT->accum_flt[ROW][COL].xfp[SELECT]; ACC = hmx_convert_to_legacy_acc(thread->processor_ptr, acc_xfp); OVF = hmx_convert_to_legacy_ovf(thread->processor_ptr, acc_xfp); } else { ACC=THREAD2STRUCT->accum_flt[ROW][COL].val[SELECT]; OVF=THREAD2STRUCT->accum_flt[ROW][COL].ovf[SELECT]; } fMX_DEBUG_LOG(2, "HMX CVT ACC[%02d][%02d][%02d] = %016llx.%016llx OVF=%02x", ROW>>1, COL, SELECT, ACC.hi, ACC.lo, OVF); }
#define fMX_CONVERTED_ACCUMULATOR_FXP(ROW,COL,VAL) THREAD2STRUCT->cvt_future_accum_fxp[ROW][COL].uh[0] = (size2u_t)VAL
#define fMX_CONVERTED_ACCUMULATOR_FLT(ROW,COL,VAL) THREAD2STRUCT->cvt_future_accum_flt[ROW][COL].uh[0] = (size4u_t)VAL
#define fMX_CLEAR_ACC_FXP() { THREAD2STRUCT->fxp_commit_state.acc_clear = 1; }
#define fMX_CLEAR_ACC_FLT() { THREAD2STRUCT->flt_commit_state.acc_clear = 1; }
#define fMX_CLEAR_BOTH_ACC_FXP() { THREAD2STRUCT->fxp_commit_state.acc_clear_both = 1; }
#define fMX_CLEAR_BOTH_ACC_FLT() { THREAD2STRUCT->flt_commit_state.acc_clear_both = 1; }
#define fMX_SWAP_ACC_FXP() { THREAD2STRUCT->fxp_commit_state.swap_acc = 1; }
#define fMX_SWAP_ACC_FLT() { THREAD2STRUCT->flt_commit_state.swap_acc = 1; }
#define fMX_NOCLEAR_ACC()
#define fMX_ACT_DESC()
#define fMX_ACTIVATION_INIT(START, RANGE, TYPE, FORMAT,BLOCK_TYPE ) hmx_activation_init(thread, START, RANGE, insn->slot, TYPE, FORMAT, BLOCK_TYPE)
#define fMX_WEIGHT_INIT(START, RANGE, TYPE, BLOCK_TYPE, WEIGHTS_PER_BYTE_LOG,OUTPUT_CH_SCALE) hmx_weight_init(thread, START, RANGE, insn->slot, TYPE, BLOCK_TYPE, WEIGHTS_PER_BYTE_LOG,OUTPUT_CH_SCALE)
#define fMX_STORE_INIT(EA, RSV, RTV, FORMAT, TYPE ) hmx_convert_store_init(thread, insn->slot, EA, RSV, RTV, FORMAT, TYPE)
#define fMX_fVSATUB(OUT, IN) OUT = fVSATUB(IN);
#define fMX_fVSATUH(OUT, IN) OUT = fVSATUH(IN);
#define fMX_UPDATE_ARRAY_PMU(FLT, BLOCK) { int hmx_power_on = (thread->processor_ptr->arch_proc_options->hmx_power_config == 0) ? (!thread->bq_on) : 1; if (thread->processor_ptr->arch_proc_options->pmu_enable && hmx_power_on) { processor_t * proc = thread->processor_ptr; int mac_tile_size = (FLT) ? thread->processor_ptr->arch_proc_options->QDSP6_MX_FP_RATE : thread->processor_ptr->arch_proc_options->QDSP6_MX_RATE; int mac_pmu_counter = 2048; int max_cycles = 32/mac_tile_size; int mac_pmu_counter_mask = mac_pmu_counter-1; for(int in_idx = 0; in_idx < 32; in_idx += mac_tile_size) { int32_t raw_count = 0; for(int row_idx = 0; row_idx < (1 << proc->arch_proc_options->hmx_spatial_size); row_idx++) { for(int col_idx = 0; col_idx < proc->arch_proc_options->QDSP6_MX_COLS; col_idx++) { int active_acc = 0; for(int tile_idx = 0; tile_idx < mac_tile_size; tile_idx++) { if (thread->processor_ptr->arch_proc_options->hmxarray_new) { size1u_t previous = THREAD2STRUCT->mpy_matrix_pre[row_idx][tile_idx][col_idx]; size1u_t current = THREAD2STRUCT->mpy_matrix[row_idx][in_idx+tile_idx][col_idx]; size1u_t inc = (current || previous) ? 1 : 0; THREAD2STRUCT->array_mpy[tile_idx] += inc; active_acc |= inc; THREAD2STRUCT->mpy_matrix_pre[row_idx][tile_idx][col_idx] = current; INC_PSTAT(((current) ? phmx_array_raw_active : phmx_array_raw_inactive)); INC_PSTAT(((current) ? phmx_array_raw_nonzero : phmx_array_raw_zero)); } else { size1u_t inc = THREAD2STRUCT->mpy_matrix[row_idx][in_idx+tile_idx][col_idx] > 0; THREAD2STRUCT->array_mpy[tile_idx] += inc; active_acc |= inc; raw_count += inc; INC_PSTAT(((inc) ? phmx_array_raw_nonzero : phmx_array_raw_zero)); } } THREAD2STRUCT->array_acc += active_acc; } } size2u_t pmu_valids = 0; int32_t pmu_count = 0; for(int tile_idx = 0; tile_idx < mac_tile_size; tile_idx++) { if (THREAD2STRUCT->array_mpy[tile_idx] >= mac_pmu_counter) { INC_PSTAT(((FLT) ? phmx_array_flt_mpy0 : phmx_array_fxp_mpy0)); THREAD2STRUCT->array_mpy[tile_idx] &= mac_pmu_counter_mask; pmu_valids |= 0x1 << tile_idx; pmu_count += 0x1; } else { } } if (THREAD2STRUCT->array_acc >= mac_pmu_counter) { INC_PSTAT(((FLT) ? phmx_array_flt_acc : phmx_array_fxp_acc)); THREAD2STRUCT->array_acc &= mac_pmu_counter_mask; pmu_valids |= 0x1 << mac_tile_size; } int cycle_idx = (in_idx/mac_tile_size) + BLOCK*max_cycles; if (cycle_idx > 511) { cycle_idx = 511; } thread->mem_access[1].cdata[cycle_idx] = pmu_valids; thread->mem_access[1].hmx_ma.egy_mpy_acc[cycle_idx] = pmu_valids; if (thread->processor_ptr->arch_proc_options->hmxmpytrace) { if (THREAD2STRUCT->hmxmpytrace_cycle < thread->processor_ptr->monotonic_pcycles) { THREAD2STRUCT->hmxmpytrace_cycle = thread->processor_ptr->monotonic_pcycles; } FPRINTF( thread->processor_ptr->arch_proc_options->hmxmpytrace, "%lli:%d:%d\n", THREAD2STRUCT->hmxmpytrace_cycle, raw_count, pmu_count); THREAD2STRUCT->hmxmpytrace_cycle++; } } BLOCK++; } }
#define fMX_NOCLEAR_ACCUMULATOR()
#define fMX_NO_SHIFT_ACC(EVEN) {}
#define fMX_XFP_CONVERT_BODY(SPATIAL_IDX,OUTPUT_IDX,ACC_SELECT,BIAS,SUBCHANNEL_SELECT_UNUSED,LEGACY,RS) { hmx_xfp_t acc = THREAD2STRUCT->accum_flt[SPATIAL_IDX][OUTPUT_IDX].xfp[ACC_SELECT]; RS.fp_type &= (thread->processor_ptr->arch_proc_options->QDSP6_MX_FP_ACC_EXP >= 8); uint32_t cvt_feedback_lo = (THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX+0][OUTPUT_IDX].uh[0] & 0xFFF ) << 0; uint32_t cvt_feedback_hi = (THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX+1][OUTPUT_IDX].uh[0] & 0xFF0 ) << 8; uint32_t cvt_feedback = (cvt_feedback_hi | cvt_feedback_lo); fMX_DEBUG_LOG(2, "HMX_CVT XFP FP16 INPUT pktid:%08x  : ACC[%02d][%02d][%02d] EXP=%02x SIG=%016llx OVF=%02x usr=%x CVT FEEDBACK=%05x (%04x, %04x) fb dest=%x limit=%x rnd=%d", thread->pktid, (int)(SPATIAL_IDX>>1), (int)OUTPUT_IDX, (int)ACC_SELECT, (uint16_t)acc.exp, (long long int)acc.sig, acc.status.inf, THREAD2STRUCT->usr_fp.raw, cvt_feedback, cvt_feedback_hi, cvt_feedback_lo, RS.fb_dst, RS.fb_limit, RS.fp_rnd ); hmx_cvt_function_ptr hmx_cvt_function = ( thread->processor_ptr->arch_proc_options->hmxdebugfile) ? hmx_xfp_cvt_debug : hmx_xfp_cvt; uint32_t hf = hmx_cvt_function(thread->processor_ptr, THREAD2STRUCT->usr_fp, acc, BIAS.flt_poly, cvt_feedback, RS); uint16_t hf_lo = (hf >> 0) & 0xFFF; uint16_t hf_hi = (hf >> 8) & 0xFF0; if (thread->processor_ptr->options->hmx_cvt_state_transfer_callback) { thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 0, SPATIAL_IDX , OUTPUT_IDX, ACC_SELECT, hf_lo); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 0, SPATIAL_IDX+1, OUTPUT_IDX, ACC_SELECT, hf_hi); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 1, SPATIAL_IDX , OUTPUT_IDX, ACC_SELECT, THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX ][OUTPUT_IDX].val[0].w[0]); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 1, SPATIAL_IDX+1, OUTPUT_IDX, ACC_SELECT, THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX+1][OUTPUT_IDX].val[0].w[0]); } fMX_CONVERTED_ACCUMULATOR_FLT(SPATIAL_IDX+0, OUTPUT_IDX, hf_lo); fMX_CONVERTED_ACCUMULATOR_FLT(SPATIAL_IDX+1, OUTPUT_IDX, hf_hi); fMX_DEBUG_LOG(2, "HMX_CVT FP OUTPUT pktid:%08x : ACC[%02d][%02d][%02d] HF16=%05x CVT_STATE[%02d][%02d]=%03x CVT_STATE[%02d][%02d]=%03x", thread->pktid, (int)(SPATIAL_IDX>>1), (int)OUTPUT_IDX, (int)ACC_SELECT, hf, (int)(SPATIAL_IDX), (int)OUTPUT_IDX, hf_lo, (int)(SPATIAL_IDX+1), (int)OUTPUT_IDX, hf_hi); }
#define fMX_8X8_CONVERT(ACC,SAT,SPATIAL_IDX,OUTPUT_IDX,ACC_SELECT,BIAS,POLY,LEGACY,BIAS_MASK) { uint16_t result = 0; uint16_t output_bias = (((BIAS.fxp.bias1 << 1) + BIAS.fxp.rnd_bit) << 3) + BIAS.fxp.bias0; uint16_t poly_output_bias = output_bias; int16_t scale = (((!BIAS.fxp.sigmsb << 10) + BIAS.fxp.sig) << 1) + BIAS.fxp.siglsb; int16_t poly_scale = scale; int32_t bias32 = (int32_t)BIAS.fxp.bias32; bias32 &= BIAS_MASK; fMX_POLY_SELECT(poly_output_bias, poly_scale, output_bias, scale, THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX][OUTPUT_IDX].uh[0], POLY); fMX_RNDSAT_ACC_U8(result, ACC, bias32, BIAS.fxp.exp, (BIAS.fxp.negate << 2) + (BIAS.fxp.zeropos << 1) + BIAS.fxp.zeroneg, poly_scale, poly_output_bias, SAT, SPATIAL_IDX, OUTPUT_IDX, ACC_SELECT, LEGACY); fMX_CONVERTED_ACCUMULATOR_FXP(spatial_idx, output_idx, result); }
#define fMX_8X4_CONVERT_BODY(SPATIAL_IDX,OUTPUT_IDX,ACC_SELECT,BIAS,SUBCHANNEL_SELECT,LEGACY,RS) { int32_t acc = ((int32_t)THREAD2STRUCT->accum_fxp[SPATIAL_IDX][OUTPUT_IDX].w[ACC_SELECT+SUBCHANNEL_SELECT]) << 4; const int32_t bias_mask = 0xFFFFFFF0; const int32_t poly = RS.fb_dst | (RS.fb_limit<<2); fMX_8X8_CONVERT(acc, (RS.relu==0), SPATIAL_IDX, OUTPUT_IDX, ACC_SELECT, BIAS,poly, LEGACY, bias_mask); }
#define fMX_8X8_CONVERT_BODY(SPATIAL_IDX,OUTPUT_IDX,ACC_SELECT,BIAS,SUBCHANNEL_SELECT_UNUSED,LEGACY,RS) { int32_t acc = 0; const int32_t bias_mask = 0xFFFFFFFF; int32_t poly = RS.fb_dst | (RS.fb_limit<<2); fMX_SELECT_ACCUMULATOR_FXP(acc, SPATIAL_IDX, OUTPUT_IDX, ACC_SELECT); fMX_8X8_CONVERT(acc, (RS.relu==0), SPATIAL_IDX, OUTPUT_IDX, ACC_SELECT, BIAS,poly, LEGACY, bias_mask); }
#define fMX_16X8_CONVERT_BODY(SPATIAL_IDX,OUTPUT_IDX,ACC_SELECT,BIAS,SUBCHANNEL_SELECT_UNUSED,LEGACY,RS) { uint32_t result; int32_t acc_ll; int32_t acc_hl; const int convert_width = thread->processor_ptr->arch_proc_options->QDSP6_MX_CVT_WIDTH; const int16_t scale = (((!BIAS.fxp.sigmsb << 10) + BIAS.fxp.sig) << 1) + BIAS.fxp.siglsb; fMX_SELECT_ACCUMULATOR_FXP(acc_ll, SPATIAL_IDX+0, OUTPUT_IDX, ACC_SELECT); fMX_SELECT_ACCUMULATOR_FXP(acc_hl, SPATIAL_IDX+1, OUTPUT_IDX, ACC_SELECT); fMX_RNDSAT_ACC_U16(result, acc_hl, acc_ll, BIAS.fxp.bias32, BIAS.fxp.exp, (BIAS.fxp.negate << 2) + (BIAS.fxp.zeropos << 1) + BIAS.fxp.zeroneg, scale, BIAS.fxp.rnd_bit, (RS.relu==0), SPATIAL_IDX, OUTPUT_IDX, ACC_SELECT, LEGACY); fMX_CONVERTED_ACCUMULATOR_FXP(SPATIAL_IDX+0, OUTPUT_IDX, ((result>>(convert_width - 8)) & ((1 << convert_width) - 1))); fMX_CONVERTED_ACCUMULATOR_FXP(SPATIAL_IDX+1, OUTPUT_IDX, (((result>>(convert_width+(convert_width - 8))) & 0xFF) << (convert_width - 8))); }
#define fMX_16X16_CONVERT_BODY(SPATIAL_IDX,OUTPUT_IDX,ACC_SELECT,BIAS,SUBCHANNEL_SELECT_UNUSED,LEGACY,RS) { uint32_t result; int32_t acc_ll; int32_t acc_hl; int32_t acc_lh; int32_t acc_hh; hmx_bias_t bias_reg2 = fMX_SELECT_BIAS(OUTPUT_IDX+1); const int32_t poly = RS.fb_dst | (RS.fb_limit<<2); const int32_t convert_width = thread->processor_ptr->arch_proc_options->QDSP6_MX_CVT_WIDTH; uint32_t output_bias = ((bias_reg2.fxp.bias1 << 12) + (((BIAS.fxp.bias1 << 1) + BIAS.fxp.rnd_bit) << 3) + BIAS.fxp.bias0) << 2; uint32_t poly_output_bias = output_bias; int32_t scale = (((((!bias_reg2.fxp.sigmsb << 10) + bias_reg2.fxp.sig) << 10) + BIAS.fxp.sig) << 1) + BIAS.fxp.siglsb; int32_t poly_scale = scale; fMX_SELECT_ACCUMULATOR_FXP(acc_ll, SPATIAL_IDX+0, OUTPUT_IDX+0, ACC_SELECT); fMX_SELECT_ACCUMULATOR_FXP(acc_hl, SPATIAL_IDX+1, OUTPUT_IDX+0, ACC_SELECT); fMX_SELECT_ACCUMULATOR_FXP(acc_lh, SPATIAL_IDX+0, OUTPUT_IDX+1, ACC_SELECT); fMX_SELECT_ACCUMULATOR_FXP(acc_hh, SPATIAL_IDX+1, OUTPUT_IDX+1, ACC_SELECT); int output_adjust = 1; if((RS.fxp16_ch_sel != 0x3) && !LEGACY){ if(RS.fxp16_ch_sel == 0x2){ acc_lh = acc_ll; acc_hh = acc_hl; output_adjust = 0; } acc_ll = 0; acc_hl = 0; } int32_t previous_output = ((THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX+1][OUTPUT_IDX+output_adjust].uh[0] & 0xFF0) << 8) + THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX][OUTPUT_IDX+output_adjust].uh[0]; int write_unconverted = !(RS.fb_dst); fMX_POLY_SELECT(poly_output_bias, poly_scale, output_bias, scale, previous_output<<2, poly); fMX_RNDSAT_ACC_U16x16(result, acc_hh, acc_hl, acc_lh, acc_ll, (size8s_t)BIAS.fxp.bias32 << 16, BIAS.fxp.exp, (BIAS.fxp.negate << 2) + (bias_reg.fxp.zeropos << 1) + BIAS.fxp.zeroneg, poly_scale, poly_output_bias>>2, (RS.relu==0), SPATIAL_IDX, OUTPUT_IDX, ACC_SELECT, LEGACY, output_adjust, write_unconverted); fMX_CONVERTED_ACCUMULATOR_FXP(SPATIAL_IDX+0, OUTPUT_IDX + output_adjust, ((result>>(convert_width - 8)) & ((1 << convert_width) - 1))); fMX_CONVERTED_ACCUMULATOR_FXP(SPATIAL_IDX+1, OUTPUT_IDX + output_adjust, (((result>>(convert_width+(convert_width - 8))) & 0xFF) << (convert_width - 8))); if(write_unconverted){ fMX_CONVERTED_ACCUMULATOR_FXP(SPATIAL_IDX+0, OUTPUT_IDX + !output_adjust, 0); fMX_CONVERTED_ACCUMULATOR_FXP(SPATIAL_IDX+1, OUTPUT_IDX + !output_adjust, 0); } }
#define fMX_POLY_SELECT(OUTBIAS,OUTSCALE,OUTPUT_BIAS,SCALE,PREVIOUS,POLY) { int convert_width = thread->processor_ptr->arch_proc_options->QDSP6_MX_CVT_WIDTH; if(convert_width < 12){ convert_width = 12; } if(POLY == HMX_POLY_ADD_MIN){ OUTBIAS = ((OUTPUT_BIAS) > (PREVIOUS >> (convert_width - 12))) ? PREVIOUS : OUTPUT_BIAS; } else if(POLY == HMX_POLY_ADD_MAX){ OUTBIAS = ((OUTPUT_BIAS) > (PREVIOUS >> (convert_width - 12))) ? OUTPUT_BIAS : PREVIOUS; } else if(POLY == HMX_POLY_MPY_MIN){ OUTSCALE = ((SCALE) > (PREVIOUS >> (convert_width - 12))) ? PREVIOUS : SCALE; } else if(POLY == HMX_POLY_MPY_MAX){ OUTSCALE = ((SCALE) > (PREVIOUS >> (convert_width - 12))) ? SCALE : PREVIOUS; } }
#define fMX_VERIF_FLT_MAC_CALLBACK(ROW, COL, SEL, IN_CHAN, WGT, ACT, X_TAP, Y_TAP, BLOCK, DEEP_BLOCK) { if (thread->processor_ptr->options->hmx_mac_flt_callback) { size16s_t acc = {0}; uint32_t ovf = 0; int32_t exponent = 0; if (thread->processor_ptr->arch_proc_options->QDSP6_MX_FP_ACC_EXP==0) { acc.hi = THREAD2STRUCT->future_accum_flt[ROW][COL].val[SEL].hi; acc.lo = THREAD2STRUCT->future_accum_flt[ROW][COL].val[SEL].lo; ovf = THREAD2STRUCT->future_accum_flt[ROW][COL].ovf[SEL]; exponent = (thread->processor_ptr->arch_proc_options->QDSP6_MX_FP_ACC_INT-2); acc = shiftl128(acc, 62-exponent); fMX_DEBUG_LOG(2, "HMX FLT MULT CALLBACK: pktid:%08x  A: %04x W: %04x ACC[%02d][%02d][%02d]: exponent=%d hi: %016llx lo: %016llx ovf: %02x", thread->pktid, (uint16_t)ACT, (uint16_t)WGT, ROW>>1, COL, SEL, exponent, acc.hi, acc.lo, ovf); } else { hmx_xfp_t acc_xfp = THREAD2STRUCT->future_accum_flt[ROW][COL].xfp[SEL]; acc = hmx_xfp_to_tb_callback(thread->processor_ptr, &exponent, &ovf, acc_xfp); fMX_DEBUG_LOG(2, "HMX XFP MULT CALLBACK          : pktid:%08x  A: %04x W: %04x ACC[%02d][%02d][%02d] exponent=%x Significand: 0x%02x.%016llx ovf=%02x true zero=%d channel=%d x_tap=%d y_tap=%d block=%d deep_block=%d", thread->pktid, (uint16_t)ACT, (uint16_t)WGT, ROW>>1, COL, SEL, exponent, (uint8_t)(acc.hi>>58) & 0xFF, (long long int)(acc.hi<<6), ovf, acc_xfp.status.zero, IN_CHAN, X_TAP, Y_TAP, BLOCK, DEEP_BLOCK); } thread->processor_ptr->options->hmx_mac_flt_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, (ROW>>1), COL, SEL, IN_CHAN, WGT, ACT, exponent, acc.hi, acc.lo, ovf, X_TAP, Y_TAP, BLOCK, DEEP_BLOCK); } }
#define fMX_VERIF_FXP_MAC_CALLBACK(ROW, COL, SEL, IN_CHAN, WGT, ACT, X_TAP, Y_TAP, BLOCK, DEEP_BLOCK, ACC) { if (thread->processor_ptr->options->hmx_mac_fxp_callback) { thread->processor_ptr->options->hmx_mac_fxp_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, ROW, COL, SEL, IN_CHAN, WGT, ACT, ACC, X_TAP, Y_TAP, BLOCK, DEEP_BLOCK); } }
#define fMX_HMX_ACC_FLT_OVF_CHECK(ACC, OVF_PTR, USR, IN_CHAN) { int opt = thread->processor_ptr->arch_proc_options->QDSP6_MX_FP_RATE-1; if ((IN_CHAN & opt) == opt) { hmx_fp16_acc_ovf_check(thread->processor_ptr, ACC, OVF_PTR, USR); } }
#define fMX_MULT_XFP(ROW,COL,SEL,ACT,WGT,IN_CHAN,X_TAP,Y_TAP,BLOCK,OUTPUT2X_UNUSED,DEEP_BLOCK,GRP_IDX,GRP_SIZE) { uint32_t RATE = thread->processor_ptr->arch_proc_options->QDSP6_MX_FP_RATE-1; uint32_t PARA_GROUP_SIZE = thread->processor_ptr->arch_proc_options->QDSP6_MX_COLS / thread->processor_ptr->arch_proc_options->QDSP6_MX_PARALLEL_GRPS; uint32_t mod_in_chan = IN_CHAN & RATE; uint32_t mod_col = COL % PARA_GROUP_SIZE; usr_fp_reg_t usr_reg = THREAD2STRUCT->usr_fp; hmx_xfp_t acc_xfp = THREAD2STRUCT->future_accum_flt[ROW][COL].xfp[SEL]; if((GRP_SIZE == RATE + 1) && (mod_col <= RATE) && (GRP_IDX%2 == 1)) WGT = 0; else if((GRP_SIZE == RATE + 1) && (mod_col > RATE) && (GRP_IDX%2 == 0)) WGT = 0; else if((GRP_SIZE < RATE) && ((mod_col/GRP_SIZE) != (GRP_IDX % (PARA_GROUP_SIZE/GRP_SIZE)) )) WGT = 0; fMX_DEBUG_LOG(2, "HMX FP16 XFP MULT INPUT        : pktid:%08x  A: %04x W: %04x ACC[%02d][%02d][%02d] in_chan=%d : { exp=%08x sig=%016llx status=%01x Q%02d.%02d e%02d}", thread->pktid, (uint16_t)ACT, (uint16_t)WGT, ROW>>1, COL, SEL, IN_CHAN, acc_xfp.exp, (long long int)acc_xfp.sig, acc_xfp.status.val, acc_xfp.INT, acc_xfp.FRAC, acc_xfp.EXP); THREAD2STRUCT->tmp_flt_acc_cache[ROW][COL][mod_in_chan] = hmx_fp_xfp_mult(thread->processor_ptr, usr_reg, ACT, WGT, THREAD2STRUCT->is_bf16); fMX_DEBUG_LOG(2, "HMX FP16 XFP MULT RESULT       : pktid:%08x  A: %04x W: %04x ACC[%02d][%02d][%02d] in_chan=%d x_tap=%d y_tap=%d : { exp=%08x sig=%016llx status=%08x Q%02d.%02d e%02d}, grp_size: %d", thread->pktid, (uint16_t)ACT, (uint16_t)WGT, ROW>>1, COL, SEL, IN_CHAN, X_TAP, Y_TAP, THREAD2STRUCT->tmp_flt_acc_cache[ROW][COL][mod_in_chan].exp, (long long int)THREAD2STRUCT->tmp_flt_acc_cache[ROW][COL][mod_in_chan].sig, THREAD2STRUCT->tmp_flt_acc_cache[ROW][COL][mod_in_chan].status.val, THREAD2STRUCT->tmp_flt_acc_cache[ROW][COL][mod_in_chan].INT, THREAD2STRUCT->tmp_flt_acc_cache[ROW][COL][mod_in_chan].FRAC, THREAD2STRUCT->tmp_flt_acc_cache[ROW][COL][mod_in_chan].EXP, GRP_SIZE); if (mod_in_chan == RATE) { acc_xfp = hmx_xfp_mac_reduce(thread->processor_ptr, usr_reg, &THREAD2STRUCT->tmp_flt_acc_cache[ROW][COL][0], acc_xfp, RATE+1); THREAD2STRUCT->future_accum_flt[ROW][COL].xfp[SEL] = acc_xfp; } fMX_VERIF_FLT_MAC_CALLBACK(ROW, COL, SEL, IN_CHAN, WGT, ACT, X_TAP, Y_TAP, BLOCK, DEEP_BLOCK); }
#define fMX_COMBINE_REDUNDANT_ACC(COMBINED,HI,LO,ROW,COL,SEL) { int32_t mode = thread->processor_ptr->arch_proc_options->hmx_8x4_mpy_mode; int32_t lo_msb = 1<<(thread->processor_ptr->arch_proc_options->QDSP6_MX_ACCUM_WIDTH-1); int32_t lo_mask = lo_msb-1; int32_t HI2 = HI << 4; COMBINED = (int64_t)((HI2 & 0xFFFFFFFF) + (LO & lo_mask) + ((mode) ? (LO & lo_msb) : -(LO & lo_msb))) ; }
#define fMX_MULT_FXP(ROW,COL,SEL,ACT,WGT,IN_CHAN,X_TAP,Y_TAP,BLOCK,OUTPUT2X_UNUSED,DEEP_BLOCK,GRP_IDX,GRP_SIZE) { if (thread->processor_ptr->arch_proc_options->QDSP6_MX_SUB_COLS>1) { int32_t mode = thread->processor_ptr->arch_proc_options->hmx_8x4_mpy_mode; int8_t wgt_in = (int8_t)WGT; int32_t act_in = (int32_t)((uint16_t)ACT); int32_t wgt_lo_msb = (wgt_in & 0x08); int32_t wgt_lo = (wgt_in & 0x07) + ((mode) ? wgt_lo_msb : -wgt_lo_msb); int32_t wgt_hi = (wgt_in - wgt_lo) >> 4; int32_t acc_lo = THREAD2STRUCT->future_accum_fxp[ROW][COL].w[SEL+0]; int32_t acc_hi = THREAD2STRUCT->future_accum_fxp[ROW][COL].w[SEL+2]; acc_lo += (act_in * wgt_lo); acc_hi += (act_in * wgt_hi); THREAD2STRUCT->future_accum_fxp[ROW][COL].w[SEL+0] = acc_lo; THREAD2STRUCT->future_accum_fxp[ROW][COL].w[SEL+2] = acc_hi; fMX_VERIF_FXP_MAC_CALLBACK(ROW, COL, SEL+0, IN_CHAN, WGT & 0xF, ACT, X_TAP, Y_TAP, BLOCK, DEEP_BLOCK, acc_lo); fMX_VERIF_FXP_MAC_CALLBACK(ROW, COL, SEL+2, IN_CHAN, ((WGT & 0xF0)>>4), ACT, X_TAP, Y_TAP, BLOCK, DEEP_BLOCK, acc_hi); int64_t combined_acc = 0; fMX_COMBINE_REDUNDANT_ACC(combined_acc, acc_hi, acc_lo , ROW, COL, SEL); fMX_DEBUG_LOG(1, "HMX FXP MULT: pktid:%08x X_TAP=%02d Y_TAP=%02d CHAN=%02d BLOCK=%02d A: 0x%02x W: 0x%02x = ACC[%02d][%02d][%02d].hi = 0x%08x .lo= 0x%08x combined=0x%08x",thread->pktid, X_TAP, Y_TAP, IN_CHAN, BLOCK, (uint8_t)ACT, (uint8_t)WGT, ROW, COL, SEL, acc_hi, acc_lo, (int32_t)combined_acc); } else { THREAD2STRUCT->future_accum_fxp[ROW][COL].w[SEL] += fMPY8US(ACT, WGT); int32_t combined_acc = THREAD2STRUCT->future_accum_fxp[ROW][COL].w[SEL]; fMX_VERIF_FXP_MAC_CALLBACK(ROW, COL, SEL, IN_CHAN, WGT, ACT, X_TAP, Y_TAP, BLOCK, DEEP_BLOCK, combined_acc); fMX_DEBUG_LOG(1, "HMX FXP MULT: pktid:%08x CHAN=%02d  A: 0x%02x W: 0x%02x = ACC[%02d][%02d][%02d] = 0x%08x",thread->pktid, IN_CHAN, (uint8_t)ACT, (uint8_t)WGT, ROW, COL, SEL, combined_acc); } }
#define fMX_MULT_FXP_SUBBYTE(ROW,COL,SEL,ACT,WGT,IN_CHAN,X_TAP,Y_TAP,BLOCK,OUTPUT2X,DEEP_BLOCK,GRP_IDX,GRP_SIZE) { int32_t acc_idx = SEL; acc_idx += (OUTPUT2X) ? 2 : 0; THREAD2STRUCT->future_accum_fxp[ROW][COL].w[acc_idx] += fMPY8US((uint8_t)ACT, (int8_t)WGT); int32_t acc = THREAD2STRUCT->future_accum_fxp[ROW][COL].w[acc_idx]; fMX_VERIF_FXP_MAC_CALLBACK(ROW, COL, acc_idx, IN_CHAN, WGT, ACT, X_TAP, Y_TAP, BLOCK, DEEP_BLOCK, acc); fMX_DEBUG_LOG(1, "HMX FXP MULT SUB BYTE: pktid:%08x CHAN=%02d X_TAP=%02d Y_TAP=%02d A=0x%02x W=0x%x = ACC[%02d][%02d][%02d].%s = 0x%08x", thread->pktid, IN_CHAN,X_TAP,Y_TAP, (uint8_t)ACT, (uint8_t)(WGT & 0xF), ROW, COL, SEL, (OUTPUT2X ? "hi" : "lo"), acc); }
#define fMX_MULT_ARRAY_PMU(SPATIAL,INPUT_CHANNEL,OUTPUT_CHANNEL,ACTIVATION,WEIGHT,FLT) { if (thread->processor_ptr->arch_proc_options->pmu_enable) { if (SPATIAL>=0) { int val = !( ((uint16_t)ACTIVATION == 0x0000) || ((uint16_t)WEIGHT == 0x0000) ); if (FLT) { val &= !( ((uint16_t)ACTIVATION == 0x8000) || ((uint16_t)WEIGHT == 0x8000) ); } THREAD2STRUCT->mpy_matrix[SPATIAL][INPUT_CHANNEL][OUTPUT_CHANNEL] = val; } } }
#define fMX_MULT(ROW,COL,ACC_SELECT,ACT,WGT_STREAM_IDX,MULT_FUNCTION,INPUT_CHANNEL,X_TAP,Y_TAP,BLOCK,DEEP_BLOCK, OUTPUT2X, FLT_MODE, GRP_IDX, GRP_SIZE) { uint8_t valid = THREAD2STRUCT->wgt_cache[WGT_STREAM_IDX][COL + (OUTPUT2X*32)].valid; if ((!THREAD2STRUCT->limit_execeeded) && valid && (ROW>=0)) { uint16_t wgt = THREAD2STRUCT->wgt_cache[WGT_STREAM_IDX][COL + (OUTPUT2X*32)].wgt; fMX_DEBUG_LOG(4,"WGT_SEL CACHE[%02d][%02d]=%02x", WGT_STREAM_IDX, COL, wgt); MULT_FUNCTION(ROW,COL,ACC_SELECT,ACT,wgt,INPUT_CHANNEL,X_TAP,Y_TAP,BLOCK,OUTPUT2X,DEEP_BLOCK,GRP_IDX, GRP_SIZE); fMX_MULT_ARRAY_PMU(output_idx, INPUT_CHANNEL, COL, ACT, wgt, FLT_MODE); } else { fMX_DEBUG_LOG(1, "HMX MULT: Dropped limit exceeded=%d WGT CACHE[%02d][%02d] valid=%d row roll over=%d", THREAD2STRUCT->limit_execeeded, WGT_STREAM_IDX, COL, valid, ROW); } }
#define fDEBUG_VERIF_ACC_PRINT(FLT) { }
#define fMX_GETCHANNELSIZE(PROC) get_hmx_channel_size(PROC)
#define fMX_GETADDRMASK(PROC) ~((1<<(fMX_GETCHANNELSIZE(PROC) + PROC->arch_proc_options->hmx_spatial_size))-1)
#define fMX_GETMASK(OUTPUT,START,Q,FP) { unsigned int spatial_mask = (((1<<thread->processor_ptr->arch_proc_options->hmx_spatial_size) - 1) << fMX_GETCHANNELSIZE(thread->processor_ptr)); unsigned int q_mask = ((1<<Q)-1) ; spatial_mask &= ~(q_mask << fMX_GETCHANNELSIZE(thread->processor_ptr)); spatial_mask |= q_mask; OUTPUT = (START & spatial_mask); }
#define fMX_MASKED_INC(OUTPUT,MASK) { OUTPUT = MASK & (~MASK+1); }
#define fMX_MASKED_INC(OUTPUT,MASK) { OUTPUT = MASK & (~MASK+1); }
#define fMX_INC_MASKED(IN,INC,MASK) (((IN | ~MASK) + (INC & MASK)) & MASK) | (IN & ~MASK)
#define fMX_INC_MASKED_OVERFLOW(OVERFLOW, OUT, IN,INC,MASK) { OVERFLOW = IN; OUT = (((IN | ~MASK) + (INC & MASK)) & MASK) | (IN & ~MASK); OVERFLOW = OUT < OVERFLOW; }
#define fMX_INC_TAP_MASKED(VAL,INC,MASK,DILATE) { VAL = fMX_INC_MASKED(VAL, INC, MASK); if (INC == 0) { VAL = -1; } else if (DILATE && (VAL>=0)) { VAL = fMX_INC_MASKED(VAL, INC, MASK); } }
#define fMX_CHECK_MAC_LIMIT(Y_TAP, X_TAP, BLOCK, BLOCK_END, INPUT_CH, INPUT_END, DEEP_BLOCK, DEEP_BLOCK_END, WGT_STREAM_IDX) { if(--THREAD2STRUCT->mac_cycle_limit == 0 ) { warn("HMX Last MAC cycle. Stopping on xtap=0x%x ytap=0x%x channel=0x%x (of 0x%x) block=0x%x.", Y_TAP, X_TAP,INPUT_CH, INPUT_END, BLOCK ); Y_TAP = -1; X_TAP = -1; BLOCK = BLOCK_END; INPUT_CH = INPUT_END; DEEP_BLOCK = DEEP_BLOCK_END; for(;WGT_STREAM_IDX<2048; WGT_STREAM_IDX++ ){ const int32_t output_ch_wgt_end = thread->processor_ptr->arch_proc_options->QDSP6_MX_COLS; for(int32_t output_ch_wgt_idx = 0; output_ch_wgt_idx < output_ch_wgt_end; output_ch_wgt_idx++) { THREAD2STRUCT->wgt_cache[WGT_STREAM_IDX][output_ch_wgt_idx].valid = 0; } } } }
#define fMX_WEIGHTS_RANGE_CHECK(STREAM_IDX,TAP,VAL) { if (!THREAD2STRUCT->wgt_cache[STREAM_IDX][0].valid) { TAP = VAL; THREAD2STRUCT->limit_execeeded = 1; warn("HMX exceeded maximum weights range, stopping HMX processing PA=%llx MAX=%llx", STREAM_IDX, THREAD2STRUCT->max_weight_pa); } }
#define fMX_COMPUTER_FILTER_SIZE(SIZE,START,MASK, MASK_INC) { unsigned int tmp = START & MASK; unsigned int done = 0; unsigned int count = 0; while(!done && tmp) { fMX_INC_MASKED_OVERFLOW(done, count, count, MASK_INC, MASK); done = (tmp == count) ? 1 : done; SIZE++; } SIZE++; }
#define fMX_COMPUTER_FILTER_SIZE_ABOVE(SIZE,START,MASK, MASK_INC) { unsigned int done = 0; unsigned int count = START & MASK; while(!done) { fMX_INC_MASKED_OVERFLOW(done, count, count, MASK_INC, MASK); if (!done) SIZE++; } SIZE++; }
#define fMXDEBUG_PRINT_TAP(X_TAP,Y_TAP,CH,DEEP_BLOCK,GROUP_IDX,INPUT_CH_IDX,INPUT_CH_IDX2,CH_STOP) { int x; int y; COMPUTE_MASKED_VAL(x,X_TAP,THREAD2STRUCT->tile_x_mask,12); COMPUTE_MASKED_VAL(y,Y_TAP,THREAD2STRUCT->tile_y_mask,12); fMX_DEBUG_LOG(2, "MX MULT: x_tap=%d y_tap=%d input_channel=%d deep_block=%d, group_idx=%d, input_ch_idx=%d, input_ch_idx2=%d, stop_ch=%d", x, y, CH,DEEP_BLOCK, GROUP_IDX, INPUT_CH_IDX, INPUT_CH_IDX2, CH_STOP); }
#define fMXDEBUG_PRINT_CH(BLOCK_IDX,CH_START,CH_END,DEEP_END) { fMX_DEBUG_LOG(2, "MX MULT: Block %d Channel Range: [0x%x, 0x%x] Deep Block Count=%d", BLOCK_IDX, CH_START, CH_END, DEEP_END); }
#define fMX_OPERAND_READY() { int hmx_power_off = (thread->processor_ptr->arch_proc_options->hmx_power_config == 0) ? thread->bq_on : 0; if ((THREAD2STRUCT->operand_ready!=3) || hmx_power_off) { if (thread->mem_access[1].hmx_ma.y_tap == 0) { thread->mem_access[1].cancelled = 1; thread->mem_access[0].cancelled = 1; thread->mem_access[1].valid = 0; thread->mem_access[0].valid = 0; } return; } if (EXCEPTION_DETECTED) return; }
#define fMX_CHECK_OPERANDS_SETUP_ACC() { fMX_OPERAND_READY(); if (!thread->mem_access[1].hmx_ma.flt) { memcpy(THREAD2STRUCT->future_accum_fxp, THREAD2STRUCT->accum_fxp, sizeof(hmx_acc_t)*MAX_ACCUMULATORS_DEPTH*MAX_ACCUMULATORS_SPATIAL); } else { memcpy(THREAD2STRUCT->future_accum_flt, THREAD2STRUCT->accum_flt, sizeof(hmx_acc_t)*MAX_ACCUMULATORS_DEPTH*MAX_ACCUMULATORS_SPATIAL); } }
#define fMX_TRUNCATE_TO_12B(VAL) { VAL = ((VAL << 52) >> 52); }
#define fMX_DONOTHING(VAL) { VAL = VAL; }
#define fVDOCHKPAGECROSS(BASE,SUM) if (UNLIKELY(thread->timing_on)) { thread->mem_access[slot].check_page_crosses = 1; thread->mem_access[slot].page_cross_base = BASE; thread->mem_access[slot].page_cross_sum = SUM; }
#define fMX_RNDSAT_ACC_U8(OUT, ACC, BIAS32, EXP, ZEROING, SCALE, RND, SAT, SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, LEGACY) { THREAD2STRUCT->array_cvt += (ACC>0); fMX_DEBUG_LOG(2, "HMX_CVT IN: ACC[%02d][%02d][%02d] = %08x BIAS = %08x pktid:%08x", SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, ACC, BIAS32, thread->pktid ); OUT = hmx_u8_cvt(thread->processor_ptr, ACC, BIAS32, EXP, ZEROING, SCALE, RND, SAT, thread->processor_ptr->arch_proc_options->hmx_v1, LEGACY); if (thread->processor_ptr->options->hmx_cvt_state_transfer_callback) { thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 0, SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, OUT); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 1, SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX][CHANNEL_IDX].uh[0]); } fMX_DEBUG_LOG(2, "HMX_CVT OUT: ACC[%02d][%02d][%02d] BYTE OUT=%02x pktid:%08x", SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, OUT, thread->pktid ); }
#define fMX_RNDSAT_ACC_U16(OUT, ACC_HL, ACC_LL, BIAS32, EXP, ZEROING, SCALE, RND, SAT, SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, LEGACY) { THREAD2STRUCT->array_cvt += ((ACC_HL>0) + (ACC_LL>0)) ; OUT = hmx_u16_cvt(thread->processor_ptr, ACC_HL, ACC_LL, BIAS32, EXP, ZEROING, SCALE, RND, SAT, thread->processor_ptr->arch_proc_options->QDSP6_MX_CVT_MPY_SZ, LEGACY); int convert_width = thread->processor_ptr->arch_proc_options->QDSP6_MX_CVT_WIDTH; if (thread->processor_ptr->options->hmx_cvt_state_transfer_callback) { thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 0, SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, ((OUT>>4) & ((1 << convert_width) - 1))); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 0, SPATIAL_IDX+1, CHANNEL_IDX, ACC_IDX, (((OUT>>(convert_width+4)) & 0xFF) << (convert_width - 8))); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 1, SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX][CHANNEL_IDX].uh[0]); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 1, SPATIAL_IDX+1, CHANNEL_IDX, ACC_IDX, THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX+1][CHANNEL_IDX].uh[0]); } fMX_DEBUG_LOG(2, "HMX_CVT: ACC[%02d][%02d][%02d] = HL: %08x LL: %08x HALF OUT=%02x pktid:%08x", SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, ACC_HL, ACC_LL, OUT, thread->pktid ); }
#define fMX_RNDSAT_ACC_U16x16(OUT, ACC_HH, ACC_HL, ACC_LH, ACC_LL, BIAS48, EXP, ZEROING, SCALE, RND, SAT, SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, LEGACY, OUTPUT_OFFSET, WRITE_UNC) { OUT = hmx_u16x16_cvt(thread->processor_ptr, ACC_HH, ACC_HL, ACC_LH, ACC_LL, BIAS48, EXP, ZEROING, SCALE, RND, SAT, thread->processor_ptr->arch_proc_options->hmx_v1, LEGACY); THREAD2STRUCT->array_cvt += (ACC_LH>0) + (ACC_LL>0) + (ACC_HH>0) + (ACC_HL>0); int convert_width = thread->processor_ptr->arch_proc_options->QDSP6_MX_CVT_WIDTH; if (thread->processor_ptr->options->hmx_cvt_state_transfer_callback) { thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 0, SPATIAL_IDX, CHANNEL_IDX + OUTPUT_OFFSET, ACC_IDX, ((OUT>>4) & ((1 << convert_width) - 1))); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 0, SPATIAL_IDX+1, CHANNEL_IDX + OUTPUT_OFFSET, ACC_IDX, (((OUT>>(convert_width+4)) & 0xFF) << (convert_width - 8))); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 0, SPATIAL_IDX, CHANNEL_IDX + !OUTPUT_OFFSET, ACC_IDX, WRITE_UNC ? 0 : THREAD2STRUCT->cvt_future_accum_fxp[SPATIAL_IDX][CHANNEL_IDX + !OUTPUT_OFFSET].uh[0]); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 0, SPATIAL_IDX+1, CHANNEL_IDX + !OUTPUT_OFFSET, ACC_IDX, WRITE_UNC ? 0 : THREAD2STRUCT->cvt_future_accum_fxp[SPATIAL_IDX+1][CHANNEL_IDX + !OUTPUT_OFFSET].uh[0]); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 1, SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX][CHANNEL_IDX].uh[0]); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 1, SPATIAL_IDX+1, CHANNEL_IDX, ACC_IDX, THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX+1][CHANNEL_IDX].uh[0]); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 1, SPATIAL_IDX, CHANNEL_IDX + 1, ACC_IDX, THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX][CHANNEL_IDX + 1].uh[0]); thread->processor_ptr->options->hmx_cvt_state_transfer_callback(thread->system_ptr, thread->processor_ptr, thread->pktid, 1, SPATIAL_IDX+1, CHANNEL_IDX + 1, ACC_IDX, THREAD2STRUCT->cvt_accum[THREAD2STRUCT->cvt_accum_current_index][SPATIAL_IDX+1][CHANNEL_IDX + 1].uh[0]); } fMX_DEBUG_LOG(2, "HMX_CVT: ACC[%02d][%02d][%02d] = HH: %08x HL: %08x LH: %08x LL: %08x HALF OUT=%02x pktid:%08x", SPATIAL_IDX, CHANNEL_IDX, ACC_IDX, ACC_HH, ACC_HL, ACC_LH, ACC_LL, OUT, thread->pktid ); }
#define COMPUTE_MASKED_VAL(VAL,VAL_MASK,MASK,SIZE) { VAL = 0; int j = 0; for (int i = 0; i < SIZE; i++) { if ((MASK >> i) & 0x1) { if (((VAL_MASK & MASK) >> i) & 0x1) { VAL += (1 << j); } j++; } } }
#define fMXRESET_ACTIVATION_CACHE() { memset(THREAD2STRUCT->act_cache, 0, sizeof(hmx_act_wgt_cache_t)*64*32*2); }
#define fMX_LD_ACT(INPUT_CH_STRIDE, BLOCK_IDX, FLT) { paddr_t block_size = thread->processor_ptr->arch_proc_options->hmx_block_size; paddr_t act_pa_base = thread->mem_access[1].paddr + BLOCK_IDX*block_size; fMX_DEBUG_LOG(4, "HMX Load Activations for block=%d at PA=%llx", BLOCK_IDX, (long long int)act_pa_base); for (uint32_t act_pa_offset = 0; act_pa_offset < block_size; act_pa_offset+=8) { paddr_t act_pa = act_pa_base + act_pa_offset; uint32_t cache_idx = act_pa_offset>>3; THREAD2STRUCT->act_cache_dw[cache_idx] = sim_mem_read8(thread->system_ptr, thread->threadId, act_pa); fMX_DEBUG_LOG(4, "HMX Load Activation=0x%016llx PA=%llx (offset: %llx)", (long long int)THREAD2STRUCT->act_cache_dw[cache_idx], (long long int)act_pa_base , (long long int)act_pa); } if ((thread->mem_access[1].hmx_ma.blocks == 1) && ((thread->mem_access[1].hmx_ma.y_tap > 1) || (thread->mem_access[1].hmx_ma.y_start != 0))) { act_pa_base = thread->mem_access[1].paddr + thread->mem_access[1].hmx_ma.dY; fMX_DEBUG_LOG(4, "HMX Load Activations for vertical block at PA=%llx to %llx", (long long int)act_pa_base, (long long int)(act_pa_base+block_size-1)); for (int act_pa_offset = 0; act_pa_offset < block_size; act_pa_offset+=8) { paddr_t act_pa = act_pa_base + act_pa_offset; uint32_t cache_idx = (2048+act_pa_offset)>>3; THREAD2STRUCT->act_cache_dw[cache_idx] = sim_mem_read8(thread->system_ptr, thread->threadId, act_pa); fMX_DEBUG_LOG(4, "HMX Load Activation=0x%016llx PA=%llx (offset: %llx)", (long long int)THREAD2STRUCT->act_cache_dw[cache_idx], (long long int)act_pa_base , (long long int)act_pa); } } }
#define fMX_COMPUTE_ACT_Y_OFFSET(ACT_Y_OFFSET,Y_TILE_IDX,Y_TAP_IDX,Y_TILE_MASK) { int32_t intra_tile_y_tmp = 0; int32_t y_next_tile = 0; ACT_Y_OFFSET = 0; if ((Y_TAP_IDX >= 0)) { fMX_INC_MASKED_OVERFLOW(y_next_tile, intra_tile_y_tmp, Y_TAP_IDX, Y_TILE_IDX, Y_TILE_MASK); intra_tile_y_tmp = intra_tile_y_tmp & 0x7FFFFFFF; } else { y_next_tile = 1; } ACT_Y_OFFSET += intra_tile_y_tmp; ACT_Y_OFFSET += y_next_tile * 0x800; }
#define fMX_SELECT_ACT(ACT,X_TAP_IDX,Y_TAP_IDX,X_TILE_IDX,Y_TILE_IDX,IN_CHANNEL_IDX,BLOCK_IDX,Y_TILE_MASK,ACT_Y_OFFSET,FLT) { if (!THREAD2STRUCT->limit_execeeded) { int32_t cache_idx = ACT_Y_OFFSET; cache_idx += X_TILE_IDX; cache_idx += IN_CHANNEL_IDX; ACT = (FLT) ? THREAD2STRUCT->act_cache_uh[cache_idx>>1] : THREAD2STRUCT->act_cache_ub[cache_idx]; fMX_DEBUG_LOG(4, "HMX ACT=%04x Cache Access from index=%d", (uint16_t)ACT, cache_idx); } }
#define fMX_VERIF_WGT_DECOMP_CALLBACK(BLOCK_IDX, LANE_IDX, VECTOR_IDX, METADATA_ADDR, META_ADDR_VALID, META_16BITS, VAL_HI_8_BYTES, VAL_LO_8_BYTES)
#define fMX_LD_WGT(WGT_ADDR, WGT_ADDR_END, UNPACK, OUTPUT_CHANNEL_SCALE, WGT_PER_WORD, FLT) { int32_t wgt_cache_idx = 0; fMX_DEBUG_LOG(3, "WGT_LOAD PA=%llx %llx, WGT_PER_WORD=%d, OUTPUT_CHANNEL_SCALE=%d", WGT_ADDR, WGT_ADDR_END, WGT_PER_WORD, OUTPUT_CHANNEL_SCALE); uint16_t negate_flt_wgt = THREAD2STRUCT->negate_flt_wgt << 15; int32_t block_idx = 0; const int32_t output_ch_wgt_end = thread->processor_ptr->arch_proc_options->QDSP6_MX_COLS; while(WGT_ADDR <= WGT_ADDR_END) { int8_t meta_addr_valid = 1; if(THREAD2STRUCT->wgtc_mode) { fMX_DEBUG_LOG(3, "HMX is in WGT DECOMPRESSION mode"); paddr_t wgt_uc_metadata_addr = WGT_ADDR + 4 * thread->processor_ptr->arch_proc_options->QDSP6_MX_COLS; const int32_t output_ch_wgt_lane_end = thread->processor_ptr->arch_proc_options->QDSP6_MX_COLS / 4; size4u_t wgtc_transpose_metadata[128] = {0}; size4u_t wgtc_metadata[128] = {0}; for(int32_t output_ch_wgt_lane_idx = 0; output_ch_wgt_lane_idx < output_ch_wgt_lane_end; output_ch_wgt_lane_idx++) { for(int32_t output_ch_idx=0; output_ch_idx<4; output_ch_idx++) { paddr_t output_ch_wgt_metadata_addr = wgt_uc_metadata_addr + 16 * output_ch_wgt_lane_idx + 4 * output_ch_idx; uint32_t wgtc_metadata_output_ch_raw = sim_mem_read4(thread->system_ptr, thread->threadId, output_ch_wgt_metadata_addr); for(int32_t byte_idx=0; byte_idx<4; byte_idx++) { int32_t metadata_transpose_idx = output_ch_wgt_lane_idx*16 + output_ch_idx*4 + byte_idx; wgtc_transpose_metadata[metadata_transpose_idx] = (wgtc_metadata_output_ch_raw >> (byte_idx * 8)) & 0xFF; } } } for(int32_t byte_idx=0; byte_idx<128; byte_idx++) { for(int32_t vector_idx=0; vector_idx<8; vector_idx++) { int32_t bit_pos = byte_idx % 8; if(WGT_ADDR == (WGT_ADDR_END & (~0x7f))) { wgtc_metadata[vector_idx*16 + byte_idx/8] |= 0x01 << bit_pos; meta_addr_valid = 0; } else { if((wgtc_transpose_metadata[byte_idx] >> vector_idx) & 0x1) wgtc_metadata[vector_idx*16 + byte_idx/8] |= 0x01 << bit_pos; } } } int32_t wgt_total_bytes_lane_cnt[8] = {0}; int32_t wgt_total_bytes = THREAD2STRUCT->wgtc_total_bytes + 1; int32_t wgt_local_total_bytes_lane[8] = {0}; for(int32_t vector_idx = 0; vector_idx < 8; vector_idx++) { for(int32_t output_ch_wgt_lane_idx = 0; output_ch_wgt_lane_idx < output_ch_wgt_lane_end; output_ch_wgt_lane_idx++) { paddr_t wgt_metadata_lane_addr = wgt_uc_metadata_addr + 16 * output_ch_wgt_lane_idx + vector_idx*2; paddr_t wgt_data_lane_addr = WGT_ADDR + THREAD2STRUCT->wgtc_start_offset + 16 * output_ch_wgt_lane_idx; fMX_DEBUG_LOG(3, "WGT DCOMPRESS: output_ch_wgt_lane_idx=%d, wgt_metadata_lane_addr=%llx, wgt_data_lane_addr=%llx, wgt_total_bytes=%d, vector_idx=%d", output_ch_wgt_lane_idx, wgt_metadata_lane_addr, wgt_data_lane_addr, wgt_local_total_bytes_lane[output_ch_wgt_lane_idx], vector_idx); uint32_t wgtc_cache_c_lane_raw = 0; size2u_t meta_16bits = 0; size8u_t val_8_bytes[2] = {0}; for(int32_t metadata_idx = 0; metadata_idx < 2; metadata_idx++) { int32_t metadata_pos = vector_idx*16 + output_ch_wgt_lane_idx*2 + metadata_idx; fMX_DEBUG_LOG(3, "WGT DCOMPRESS: metadata=%x, metadata_idx=%d", wgtc_metadata[metadata_pos], metadata_pos); meta_16bits += wgtc_metadata[metadata_pos] << (metadata_idx * 8); uint32_t wgt_4byte_raw = 0; for(int32_t bit_idx = 0; bit_idx < 8; bit_idx++) { paddr_t wgt_data_addr = wgt_data_lane_addr + (metadata_idx>>1)*16 + (wgt_total_bytes_lane_cnt[output_ch_wgt_lane_idx]); uint8_t wgt_byte_raw = 0; if(wgt_data_addr > WGT_ADDR_END) wgtc_cache_c_lane_raw = 0; else { wgtc_cache_c_lane_raw = sim_mem_read4(thread->system_ptr, thread->threadId, ((wgt_data_addr>>2)<<2)); } int32_t output_ch_c_idx = output_ch_wgt_lane_idx*4 + metadata_idx*2 + (bit_idx/4); wgt_cache_idx = block_idx * 8 * WGT_PER_WORD/OUTPUT_CHANNEL_SCALE + vector_idx * WGT_PER_WORD / OUTPUT_CHANNEL_SCALE; if(wgt_cache_idx >= 2148) wgt_cache_idx = 2147; if(((wgtc_metadata[metadata_pos] >> bit_idx) & 0x1) && (wgt_local_total_bytes_lane[output_ch_wgt_lane_idx] < wgt_total_bytes)) { wgt_byte_raw = (wgtc_cache_c_lane_raw >> ((wgt_total_bytes_lane_cnt[output_ch_wgt_lane_idx] % 4) * 8)) & 0xFF; wgt_total_bytes_lane_cnt[output_ch_wgt_lane_idx]++; if((wgt_total_bytes_lane_cnt[output_ch_wgt_lane_idx] % 16) == 0) { if(wgt_total_bytes_lane_cnt[output_ch_wgt_lane_idx] == 16) wgt_total_bytes_lane_cnt[output_ch_wgt_lane_idx] += 128; wgt_total_bytes_lane_cnt[output_ch_wgt_lane_idx] += 112; } wgt_local_total_bytes_lane[output_ch_wgt_lane_idx]++; } else { wgt_byte_raw = 0; } val_8_bytes[metadata_idx] += ((size8u_t)wgt_byte_raw) << ( bit_idx * 8 ); wgt_4byte_raw += ((size8u_t)wgt_byte_raw) << ( (bit_idx%4) * 8 ); fMX_DEBUG_LOG(3, "WGT DCOMPRESS: bit_idx=%d, wgt_4byte_raw=0x%08x, wgt_byte_raw=0x%02x", bit_idx, wgt_4byte_raw, wgt_byte_raw); if((bit_idx%4) == 3) { if (WGT_PER_WORD==2) { for(int32_t bit_select = 0, wgt_cache_idx2=wgt_cache_idx; bit_select < 32; bit_select += 16, wgt_cache_idx2++) { uint16_t unpacked_wgt = (wgt_4byte_raw >> bit_select) & 0xFFFF; THREAD2STRUCT->wgt_cache[wgt_cache_idx2][output_ch_c_idx].wgt = unpacked_wgt; THREAD2STRUCT->wgt_cache[wgt_cache_idx2][output_ch_c_idx].wgt ^= (FLT) ? negate_flt_wgt : 0; THREAD2STRUCT->wgt_cache[wgt_cache_idx2][output_ch_c_idx].valid = 1; fMX_DEBUG_LOG(3, "WGT_LOAD[%02d][%02d]=0x%04x raw_wgt=0x%08x PA=%llx unpack from bit=%d", wgt_cache_idx2, output_ch_c_idx, (uint16_t)unpacked_wgt, wgt_4byte_raw, WGT_ADDR, bit_select); } } else { const uint32_t bit_stride = 32/WGT_PER_WORD; for(int32_t bit_select = 0, wgt_cache_idx2=wgt_cache_idx, wgt_cache_idx3=wgt_cache_idx; bit_select < 8; bit_select+=bit_stride) { for(int32_t byte_select = 0; byte_select < 32; byte_select += 8) { int8_t packed_wgt = (int8_t)(wgt_4byte_raw >> byte_select) & 0xFF; int8_t unpacked_wgt = 0; UNPACK(unpacked_wgt, packed_wgt, bit_select); if ((OUTPUT_CHANNEL_SCALE == 2) && (bit_select == 4)) { THREAD2STRUCT->wgt_cache[wgt_cache_idx3][output_ch_c_idx + output_ch_wgt_end].wgt = unpacked_wgt; THREAD2STRUCT->wgt_cache[wgt_cache_idx3][output_ch_c_idx + output_ch_wgt_end].valid = 1; wgt_cache_idx3++; fMX_DEBUG_LOG(3, "WGT DCOMPRESS: WGT_LOAD[%02d][%02d]=0x%02x raw_wgt=0x%08x packed_wgt=0x%02x PA=%llx unpack from bit=%d byte=%d", wgt_cache_idx3-1, output_ch_c_idx+output_ch_wgt_end, (uint8_t)unpacked_wgt, wgt_4byte_raw, (uint8_t)packed_wgt, wgt_data_addr, bit_select, byte_select); } else { THREAD2STRUCT->wgt_cache[wgt_cache_idx2][output_ch_c_idx].wgt = unpacked_wgt; THREAD2STRUCT->wgt_cache[wgt_cache_idx2][output_ch_c_idx].valid = 1; wgt_cache_idx2++; fMX_DEBUG_LOG(3, "WGT DCOMPRESS: WGT_LOAD[%02d][%02d]=0x%02x raw_wgt=0x%08x packed_wgt=0x%02x PA=%llx unpack from bit=%d byte=%d", wgt_cache_idx2-1, output_ch_c_idx, (uint8_t)unpacked_wgt, wgt_4byte_raw, (uint8_t)packed_wgt, wgt_data_addr, bit_select, byte_select); } } } } wgt_4byte_raw = 0; } } } fMX_DEBUG_LOG(4, "WGT DCOMPRESS: block_idx=%d, lane_idx=%d vector_idx=%d, metadata_addr=%llx, meta_16bits=%x, val_hi_8_bytes=%llx, val_lo_8_bytes=%llx, WGT_ADDR=%llx, WGT_ADDR_END=%llx, wgt_total_bytes=%d", block_idx, output_ch_wgt_lane_idx, vector_idx, wgt_uc_metadata_addr, meta_16bits, val_8_bytes[1], val_8_bytes[0], WGT_ADDR, WGT_ADDR_END, wgt_total_bytes); fMX_VERIF_WGT_DECOMP_CALLBACK(block_idx, output_ch_wgt_lane_idx, vector_idx, wgt_uc_metadata_addr, meta_addr_valid, meta_16bits, val_8_bytes[1], val_8_bytes[0]); } } WGT_ADDR = (paddr_t)(((WGT_ADDR + (wgt_total_bytes << 3)) & (~0x7f)) + 0x80); block_idx++; wgt_cache_idx += WGT_PER_WORD/OUTPUT_CHANNEL_SCALE; } else { for(int32_t output_ch_wgt_idx = 0; output_ch_wgt_idx < output_ch_wgt_end; output_ch_wgt_idx++) { uint32_t raw_wgt = sim_mem_read4(thread->system_ptr, thread->threadId, WGT_ADDR); if (WGT_PER_WORD==2) { for(int32_t bit_select = 0, wgt_cache_idx2=wgt_cache_idx; bit_select < 32; bit_select += 16, wgt_cache_idx2++) { uint16_t unpacked_wgt = (raw_wgt >> bit_select) & 0xFFFF; THREAD2STRUCT->wgt_cache[wgt_cache_idx2][output_ch_wgt_idx].wgt = unpacked_wgt; THREAD2STRUCT->wgt_cache[wgt_cache_idx2][output_ch_wgt_idx].wgt ^= (FLT) ? negate_flt_wgt : 0; THREAD2STRUCT->wgt_cache[wgt_cache_idx2][output_ch_wgt_idx].valid = 1; fMX_DEBUG_LOG(4, "WGT_LOAD[%02d][%02d]=0x%04x raw_wgt=0x%08x PA=%llx unpack from bit=%d", wgt_cache_idx2, output_ch_wgt_idx, (uint16_t)unpacked_wgt, raw_wgt, WGT_ADDR, bit_select); } } else { const uint32_t bit_stride = 32/WGT_PER_WORD; for(int32_t bit_select = 0, wgt_cache_idx2=wgt_cache_idx, wgt_cache_idx3=wgt_cache_idx; bit_select < 8; bit_select+=bit_stride) { for(int32_t byte_select = 0; byte_select < 32; byte_select += 8) { int8_t packed_wgt = (int8_t)(raw_wgt >> byte_select) & 0xFF; int8_t unpacked_wgt = 0; UNPACK(unpacked_wgt, packed_wgt, bit_select); if ((OUTPUT_CHANNEL_SCALE == 2) && (bit_select == 4)) { THREAD2STRUCT->wgt_cache[wgt_cache_idx3][output_ch_wgt_idx + output_ch_wgt_end].wgt = unpacked_wgt; THREAD2STRUCT->wgt_cache[wgt_cache_idx3][output_ch_wgt_idx + output_ch_wgt_end].valid = 1; wgt_cache_idx3++; fMX_DEBUG_LOG(4, "WGT_LOAD[%02d][%02d]=0x%02x raw_wgt=0x%08x packed_wgt=0x%02x PA=%llx unpack from bit=%d byte=%d", wgt_cache_idx3-1, output_ch_wgt_idx+output_ch_wgt_end, (uint8_t)unpacked_wgt, raw_wgt, (uint8_t)packed_wgt, WGT_ADDR, bit_select, byte_select); } else { THREAD2STRUCT->wgt_cache[wgt_cache_idx2][output_ch_wgt_idx].wgt = unpacked_wgt; THREAD2STRUCT->wgt_cache[wgt_cache_idx2][output_ch_wgt_idx].valid = 1; wgt_cache_idx2++; fMX_DEBUG_LOG(4, "WGT_LOAD[%02d][%02d]=0x%02x raw_wgt=0x%08x packed_wgt=0x%02x PA=%llx unpack from bit=%d byte=%d", wgt_cache_idx2-1, output_ch_wgt_idx, (uint8_t)unpacked_wgt, raw_wgt, (uint8_t)packed_wgt, WGT_ADDR, bit_select, byte_select); } } } } WGT_ADDR += 4; } wgt_cache_idx += WGT_PER_WORD/OUTPUT_CHANNEL_SCALE; } } if (WGT_PER_WORD==2) { while( (wgt_cache_idx & 0x3) ) { const int32_t output_ch_wgt_end = thread->processor_ptr->arch_proc_options->QDSP6_MX_COLS; for(int32_t output_ch_wgt_idx = 0; output_ch_wgt_idx < output_ch_wgt_end; output_ch_wgt_idx++) { THREAD2STRUCT->wgt_cache[wgt_cache_idx][output_ch_wgt_idx].wgt = 0; THREAD2STRUCT->wgt_cache[wgt_cache_idx][output_ch_wgt_idx].valid = 1; THREAD2STRUCT->wgt_cache[wgt_cache_idx][output_ch_wgt_idx].wgt ^= (FLT) ? negate_flt_wgt : 0; fMX_DEBUG_LOG(4, "WGT_LOAD[%02d][%02d]=0x0 Set to zero not enough weights provided FP case", wgt_cache_idx, output_ch_wgt_idx); } wgt_cache_idx++; } } for(;wgt_cache_idx < 2048; wgt_cache_idx++ ) { const int32_t output_ch_wgt_end = thread->processor_ptr->arch_proc_options->QDSP6_MX_COLS * OUTPUT_CHANNEL_SCALE; for(int32_t output_ch_wgt_idx = 0; output_ch_wgt_idx < output_ch_wgt_end; output_ch_wgt_idx++) { THREAD2STRUCT->wgt_cache[wgt_cache_idx][output_ch_wgt_idx].valid = 0; } } }
#define fALIGN_CVT(ADDR, FORMAT) ADDR &= (~((1<<(fMX_GETCHANNELSIZE(thread->processor_ptr)+2))-1)) << FORMAT
#define fALIGN_FXP_DEPTH(ADDR,SCALE) ADDR &= ~((thread->processor_ptr->arch_proc_options->QDSP6_MX_COLS*4*SCALE) - 1)
#define fALIGN_BLOCK(ADDR) ADDR &= ~((1<<(fMX_GETCHANNELSIZE(thread->processor_ptr)+ thread->processor_ptr->arch_proc_options->hmx_spatial_size))-1)
#define fMX_SIGN_EXTEND_BITS(VAL,SELECT,MASK,EXT) (((int8_t)(((VAL >> SELECT) & MASK) << EXT)) >> EXT)
#define fMX_UNPACK_NONE(OUT,IN,BIT_SELECT) { OUT = IN; }
#define fMX_UNPACK_BYTE_FROM_BYTE(OUT,IN,BIT_SELECT) { OUT = IN; THREAD2STRUCT->weight_bits = 8; }
#define fMX_UNPACK_SM_FROM_BYTE(OUT,IN,BIT_SELECT) { OUT = ((((int8_t)(IN & 0xFF) >> 7)) & 0x7F) ^ IN; THREAD2STRUCT->weight_bits = 8; }
#define fMX_UNPACK_1SBIT_FROM_BYTE(OUT,IN,BIT_SELECT) { OUT = (((int8_t)(IN & 0xFF) >> BIT_SELECT) & 0x1) ? -1 : 1 ; if (THREAD2STRUCT->force_zero) { OUT = 0; } THREAD2STRUCT->weight_bits = 1; }
#define fMX_UNPACK_1BIT_FROM_BYTE(OUT,IN,BIT_SELECT) { OUT = ((int8_t)(IN & 0xFF) >> BIT_SELECT) & 0x1; THREAD2STRUCT->weight_bits = 1; }
#define fMX_UNPACK_NIBBLE_FROM_BYTE(OUT,IN,BIT_SELECT) { OUT = fMX_SIGN_EXTEND_BITS((int8_t)(IN & 0xFF), BIT_SELECT , 0xF, 4); THREAD2STRUCT->weight_bits = 4; }
#define fMX_UNPACK_CRUMB_FROM_BYTE(OUT,IN,BIT_SELECT) { OUT = fMX_SIGN_EXTEND_BITS((int8_t)(IN & 0xFF), BIT_SELECT, 0x3, 6); THREAD2STRUCT->weight_bits = 2; }
#define fMX_UNPACK_SCRUMB_FROM_BYTE(OUT,IN,BIT_SELECT) { OUT = fMX_SIGN_EXTEND_BITS((int8_t)(IN & 0xFF), BIT_SELECT, 0x3, 6); OUT = ((size1s_t)OUT >= 0) ? 2-OUT : OUT; if (THREAD2STRUCT->force_zero) { OUT = 0; } THREAD2STRUCT->weight_bits = 2; }
#define fMX_LOAD_BIAS_LO(OUT_IDX,EA,PA) { paddr_t pa = PA+4*OUT_IDX; size4u_t bias_word = sim_mem_read4(thread->system_ptr, thread->threadId, pa); THREAD2STRUCT->future_bias[OUT_IDX].val[0] = bias_word; THREAD2STRUCT->future_bias[OUT_IDX].val[1] = 0; fMX_DEBUG_LOG(2,"Bias Loaded[%d][0]=%08x", OUT_IDX, bias_word); }
#define fMX_LOAD_BIAS_HI(OUT_IDX,EA,PA) { paddr_t pa = PA+4*OUT_IDX + 128; size4u_t bias_word = sim_mem_read4(thread->system_ptr, thread->threadId, pa); THREAD2STRUCT->future_bias[OUT_IDX].val[1] = bias_word; fMX_DEBUG_LOG(2,"Bias Loaded[%d][1]=%08x", OUT_IDX, bias_word); }
#define fMX_STORE_BIAS(OUT_IDX,EA) {}
#define fMX_STORE_BIAS_DOUBLE(OUT_IDX,EA) {}
#define fMX_SELECT_BIAS(OUT_IDX) (THREAD2STRUCT->fxp_commit_state.bias_update ? THREAD2STRUCT->future_bias[OUT_IDX] : THREAD2STRUCT->bias[OUT_IDX])
#define fMX_UPDATE_ACC(FLT) if (FLT) { THREAD2STRUCT->flt_commit_state.acc_update = 1; } else { THREAD2STRUCT->fxp_commit_state.acc_update = 1; }
#define fMX_COMPUTE_ACC_INDEX(OUTPUT_IDX,EVEN_ODD,X_TAP_IDX,X_TILE_IDX,X_TILE_MASK,Y_TILE_IDX,CURRENT_ACC) { int a0 = CURRENT_ACC; int overflow = 0; if (X_TAP_IDX >= 0) { fMX_INC_MASKED_OVERFLOW(overflow, OUTPUT_IDX, X_TAP_IDX, X_TILE_IDX, X_TILE_MASK); EVEN_ODD = (overflow) ? (a0 ^ 0x1) & 0x1 : a0 & 0x1; } else { OUTPUT_IDX = X_TILE_IDX; EVEN_ODD = (a0 ^ 0x1) & 0x1; } OUTPUT_IDX |= Y_TILE_IDX; unsigned int mask = (1<<thread->mem_access[1].hmx_ma.format)-1; unsigned int temp = (OUTPUT_IDX >> fMX_GETCHANNELSIZE(thread->processor_ptr)) & ~mask; OUTPUT_IDX = temp | (OUTPUT_IDX & mask); if (overflow && (thread->mem_access[1].hmx_ma.drop || thread->mem_access[0].hmx_ma.deep)) { OUTPUT_IDX = -1; } }
#define fMX_GET_ACC_INDEX(IDX,Q_OFFSET) { unsigned int temp = (IDX >> fMX_GETCHANNELSIZE(thread->processor_ptr)) & ~((1<<Q_OFFSET)-1); IDX = temp | (IDX & ((1<<Q_OFFSET)-1)); }
#define fVNOSAT_UBYTE(OUT,IN) OUT = IN & 0xFF
#define fVNOSATHF(VAL)
#define CHECK_ACCESS_RANGE(EXC,PADDR,LEN) { vaddr_t page_mask = (1ULL<<thread->mem_access[slot].xlate_info.size)-1; paddr_t page_of_start = (PADDR & ~page_mask); paddr_t page_of_end = ((PADDR + LEN) & ~page_mask); EXC |= (page_of_start != page_of_end); }

#endif
