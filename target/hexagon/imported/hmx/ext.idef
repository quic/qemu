/*
 *  Copyright(c) 2019-2020 Qualcomm Innovation Center, Inc. All Rights Reserved.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/*************************************************************************************
*
* NPU matrix multiply instruction
*
***************************************************************************************/

#ifndef EXTINSN
#define EXTINSN Q6INSN
#define __SELF_DEF_EXTINSN 1
#endif



#define MX_ACTIVATION(TAG,SYNTAX, TYPE, FORMAT_OFFSET, BLOCK_TYPE) \
EXTINSN(TAG,SYNTAX,ATTRIBS(A_SHARED_EXTENSION,A_HMX,A_LOAD,A_MEMLIKE,A_VTCM_ALLBANK_ACCESS,A_EA_PAGECROSS,A_HMX_BLOCK_ALIGN,A_NOTE_MX_PAIR,A_PAIR_1OF2),"Matrix Multiply",  \
{\
	fMX_ACTIVATION_INIT(RsV,RtV,TYPE, FORMAT_OFFSET,BLOCK_TYPE);\
	fMX_ACT_DESC();\
})

#define MXMEM_WEIGHT(TAG,SYNTAX,TYPE,WEIGHTS_PER_BYTE_LOG,UNPACK,SHIFT,BLOCK_TYPE) \
EXTINSN(TAG,SYNTAX,ATTRIBS(A_SHARED_EXTENSION,A_HMX,A_LOAD,A_RESTRICT_SLOT0ONLY,A_MEMLIKE,A_VTCM_ALLBANK_ACCESS,A_EA_PAGECROSS,A_NOTE_MX_PAIR,A_PAIR_2OF2),"Matrix Multiply",  \
{\
	fMX_WEIGHT_INIT(RsV, RtV,TYPE,BLOCK_TYPE, WEIGHTS_PER_BYTE_LOG);\
	fHIDE(fMX_CHECK_OPERANDS_SETUP_ACC();)	/* Only Execute Instruction if both operands havee been registered */ \
	SHIFT()\
	MX_MULT(WEIGHTS_PER_BYTE_LOG,UNPACK,size1s_t)\
})


#define MX_MULT(WEIGHTS_PER_BYTE_LOG,UNPACK,TYPES)\
	fHIDE(int tile_y_mask = THREAD2STRUCT->tile_y_mask;) \
	fHIDE(int tile_x_mask = THREAD2STRUCT->tile_x_mask;) \
	fHIDE(int tile_x_mask_msb = tile_x_mask | (1<<31);) \
	fHIDE(int tile_y_mask_msb = tile_y_mask | (1<<31);) \
	fHIDE(int tile_y_inc = THREAD2STRUCT->tile_y_inc;) \
	fHIDE(int tile_x_inc = THREAD2STRUCT->tile_x_inc;) \
	fHIDE(int y_dilate = thread->mem_access[1].hmx_ma.y_dilate;) \
	fHIDE(int x_dilate = thread->mem_access[1].hmx_ma.x_dilate;) \
	fHIDE(int format = thread->mem_access[1].hmx_ma.format;) \
	fHIDE(int input_ch_end_last_block = thread->mem_access[1].hmx_ma.ch_stop << format;) \
	fHIDE(int input_ch_start_first_block = thread->mem_access[1].hmx_ma.ch_start << format;) \
	fHIDE(int input_ch_stride = 1 << format;) \
	fHIDE(int input_channels = 1 << (fMX_GETCHANNELSIZE(thread->processor_ptr) + format);) \
	fHIDE(int output_channels = thread->processor_ptr->arch_proc_options->hmx_output_depth;) \
	fHIDE(paddr_t weight_addr = thread->mem_access[0].paddr;)\
	fHIDE(int block_end = thread->mem_access[1].hmx_ma.blocks;)\
	fHIDE(THREAD2STRUCT->weight_count = WEIGHTS_PER_BYTE_LOG;)\
	fHIDE(int input_weight_idx = 0;)\
	fHIDE(int pmu_block = 0;)\
	fHIDE(int deep_mode = thread->mem_access[0].hmx_ma.deep;)\
	fHIDE(int flt_mode = thread->mem_access[1].hmx_ma.flt;)\
	fHIDE(int deep_block_end = deep_mode ? 2 : 1 ;)\
	fHIDE(int current_acc = flt_mode ? THREAD2STRUCT->current_acc_flt : THREAD2STRUCT->current_acc_fxp;)\
	fHIDE(vaddr_t weight_inc = flt_mode ? 256 : 128 ; )\
	for(int block_idx = 0; block_idx < block_end; block_idx++) {\
		fHIDE(int input_ch_end = 0;) \
		fHIDE(int input_ch_start = 0;) \
		input_ch_end = (((block_idx + 1) >= block_end)) ? input_ch_end_last_block : input_channels;\
		input_ch_start = (block_idx == 0) ? input_ch_start_first_block : 0;\
		fHIDE(fMXDEBUG_PRINT_CH(block_idx,input_ch_start,input_ch_end,deep_block_end);)\
		fHIDE(int y_tap_idx  = thread->mem_access[1].hmx_ma.y_start;)\
		fHIDE(int y_tap_stop = thread->mem_access[1].hmx_ma.y_stop;)\
		fHIDE(int y_tap_decoded  = 0;)\
		while (y_tap_idx>=0) {\
			for(int deep_block_idx = 0; deep_block_idx < deep_block_end; deep_block_idx++) { \
				fHIDE(int x_tap_decoded  = 0;)\
				fHIDE(int x_tap_idx  = thread->mem_access[1].hmx_ma.x_start;)\
				fHIDE(int x_tap_stop = thread->mem_access[1].hmx_ma.x_stop;)\
				while (x_tap_idx>=0) {\
					for(int input_ch_idx = input_ch_start; input_ch_idx < input_ch_end; input_ch_idx += 4*input_ch_stride) {\
						fHIDE(fMXLOAD_WEIGHTS(weight_addr, input_weight_idx, flt_mode );)\
						for(int input_ch_idx2 = input_ch_idx; input_ch_idx2 < input_ch_idx + 4*input_ch_stride; input_ch_idx2 += input_ch_stride) {\
							\
							fHIDE(fMXDEBUG_PRINT_TAP(x_tap_idx,y_tap_idx,input_ch_idx2,deep_block_idx);)\
							fHIDE(int intra_tile_y= 0;)\
							while (intra_tile_y>=0) {\
								fHIDE(int intra_tile_x = 0;)\
								while (intra_tile_x>=0) {\
									fHIDE(TYPES activation=0;)\
									fHIDE(int output_idx=0;) \
									fHIDE(int acc_select =0;) \
									fMX_COMPUTE_ACC_INDEX(output_idx, acc_select, x_tap_idx, intra_tile_x, tile_x_mask, intra_tile_y, current_acc);\
									fMXLOAD_ACTIVATION(activation, x_tap_idx, y_tap_idx, intra_tile_x, intra_tile_y, input_ch_idx2, block_idx, tile_y_mask, flt_mode);\
									for(int output_ch_idx = 0; output_ch_idx < output_channels; output_ch_idx++) {\
										fHIDE(TYPES weight=0;)\
										fHIDE(TYPES weight_valid=0;)\
										fMXSELECT_WEIGHT(weight, weight_valid, weight_addr, WEIGHTS_PER_BYTE_LOG, UNPACK, output_ch_idx, input_weight_idx,flt_mode);\
										fMX_MULT(output_idx, output_ch_idx, acc_select, activation, weight, weight_valid, flt_mode, (input_ch_idx2 >> format), x_tap_decoded, y_tap_decoded,block_idx, deep_block_idx );\
										fHIDE(fMX_MULT_ARRAY_PMU(output_idx, (input_ch_idx2 >> format), output_ch_idx, activation, weight, flt_mode);)\
									}\
									fMX_INC_TAP_MASKED(intra_tile_x, tile_x_inc, tile_x_mask_msb, 0);\
								}\
								fMX_INC_TAP_MASKED(intra_tile_y, tile_y_inc, tile_y_mask_msb, 0);\
							}\
							fMX_INCREMENT_WEIGHT_ADDR(input_weight_idx, weight_addr, weight_inc, WEIGHTS_PER_BYTE_LOG);\
						}\
						fHIDE(fMX_CHECK_MAC_LIMIT(y_tap_idx, x_tap_idx, block_idx, block_end, input_ch_idx,input_ch_end, deep_block_idx, deep_block_end);)\
					}\
					fHIDE(fMX_UPDATE_ARRAY_PMU(flt_mode, pmu_block);)\
					fMX_INC_TAP_MASKED(x_tap_idx, tile_x_inc, tile_x_mask_msb, x_dilate);\
					fHIDE(if (x_tap_idx > x_tap_stop) x_tap_idx = -1;)\
					fHIDE(fMX_WEIGHTS_RANGE_CHECK(weight_addr, x_tap_idx,-1);)\
					fHIDE(x_tap_decoded++;)\
				}\
				fHIDE(current_acc = (deep_mode) ? current_acc ^ 0x1 : current_acc;)\
				fHIDE(fMX_WEIGHTS_RANGE_CHECK(weight_addr, y_tap_idx,-1);)\
			}\
			fMX_INC_TAP_MASKED(y_tap_idx, tile_y_inc, tile_y_mask_msb, y_dilate);\
			fHIDE(if (y_tap_idx > y_tap_stop) y_tap_idx = -1;)\
			fHIDE(fMX_WEIGHTS_RANGE_CHECK(weight_addr, y_tap_idx,-1);)\
			fHIDE(y_tap_decoded++;)\
		}\
		fHIDE(fMX_WEIGHTS_RANGE_CHECK(weight_addr, block_idx,block_end);)\
	}\
	fHIDE(fDEBUG_VERIF_ACC_PRINT(flt_mode);)\
	fHIDE(fMX_UPDATE_ACC(flt_mode);)\


#define FORMAT_DM 0
#define FORMAT_SM 2

#define MULTI_BLOCK 0
#define SINGLE_BLOCK_ONLY 1

#define MX_ALIGNED 0
#define MX_ABOVE 1



// Lahaina 8-bit
MX_ACTIVATION(M8_mxmem_blk_sm_act_ub,  "activation.ub=mxmem(Rs32,Rt32)",              HMX_UB, FORMAT_SM, HMX_ACT_BLOCK)
MX_ACTIVATION(M8_mxmem_blk_dm_act_ub,  "activation.ub=mxmem(Rs32,Rt32):cm",           HMX_UB, FORMAT_DM, HMX_ACT_BLOCK)
MX_ACTIVATION(M8_mxmem_sm_act_ub,      "activation.ub=mxmem(Rs32,Rt32):deep",         HMX_UB, FORMAT_SM, HMX_ACT_DEEP)
MX_ACTIVATION(M8_mxmem_dm_act_ub,      "activation.ub=mxmem(Rs32,Rt32):deep:cm",      HMX_UB, FORMAT_DM, HMX_ACT_DEEP)
MX_ACTIVATION(M8_mxmemu_blk_sm_act_ub, "activation.ub=mxmem(Rs32,Rt32):above",        HMX_UB, FORMAT_SM, HMX_ACT_ABOVE)
MX_ACTIVATION(M8_mxmemu_blk_dm_act_ub, "activation.ub=mxmem(Rs32,Rt32):above:cm",     HMX_UB, FORMAT_DM, HMX_ACT_ABOVE)
MX_ACTIVATION(M8_mxmems_blk_sm_act_ub, "activation.ub=mxmem(Rs32,Rt32):single",       HMX_UB, FORMAT_SM, HMX_ACT_SINGLE)
MX_ACTIVATION(M8_mxmems_blk_dm_act_ub, "activation.ub=mxmem(Rs32,Rt32):single:cm",    HMX_UB, FORMAT_DM, HMX_ACT_SINGLE)
MX_ACTIVATION(M8_mxmemd_blk_sm_act_ub, "activation.ub=mxmem(Rs32,Rt32):dilate",       HMX_UB, FORMAT_SM, HMX_ACT_DILATE)
MX_ACTIVATION(M8_mxmemd_blk_dm_act_ub, "activation.ub=mxmem(Rs32,Rt32):dilate:cm",    HMX_UB, FORMAT_DM, HMX_ACT_DILATE)
//MX_ACTIVATION(M8_mxmemb_blk_sm_act_ub, "activation.ub=mxmem(Rs32,Rt32):batch",        HMX_UB, FORMAT_SM, HMX_ACT_BATCH)
//MX_ACTIVATION(M8_mxmemb_blk_dm_act_ub, "activation.ub=mxmem(Rs32,Rt32):batch:cm",     HMX_UB, FORMAT_DM, HMX_ACT_BATCH)


#define MXMEM_WEIGHT_INSN(TYPE, TYPE2, SCALE, UNPACK) \
MXMEM_WEIGHT(M8_mxmem_wei_##TYPE,        "weight." TYPE2 "=mxmem(Rs32,Rt32)",        HMX_B, SCALE, UNPACK,   fMX_NO_SHIFT_ACC, HMX_WEI_NORMAL) \
MXMEM_WEIGHT(M8_mxmems_wei_##TYPE,       "weight." TYPE2 "=mxmem(Rs32,Rt32):single", HMX_B, SCALE, UNPACK,   fMX_NO_SHIFT_ACC, HMX_WEI_SINGLE) \
MXMEM_WEIGHT(M8_mxmemdr_wei_##TYPE,      "weight." TYPE2 "=mxmem(Rs32,Rt32):drop",   HMX_B, SCALE, UNPACK,   fMX_NO_SHIFT_ACC, HMX_WEI_DROP) \
MXMEM_WEIGHT(M8_mxmemdp_wei_##TYPE,      "weight." TYPE2 "=mxmem(Rs32,Rt32):deep",   HMX_B, SCALE, UNPACK,   fMX_NO_SHIFT_ACC, HMX_WEI_DEEP) \
MXMEM_WEIGHT(M8_mxmema_wei_##TYPE,       "weight." TYPE2 "=mxmem(Rs32,Rt32):after",  HMX_B, SCALE, UNPACK,   fMX_NO_SHIFT_ACC, HMX_WEI_AFTER) \
MXMEM_WEIGHT(M8_mxmemdi_wei_##TYPE,      "weight." TYPE2 "=mxmem(Rs32,Rt32):dilate", HMX_B, SCALE, UNPACK,   fMX_NO_SHIFT_ACC, HMX_WEI_DILATE)

MXMEM_WEIGHT_INSN(b,   "b",    0, fMX_UNPACK_BYTE_FROM_BYTE)
MXMEM_WEIGHT_INSN(sm,  "sm",   0, fMX_UNPACK_SM_FROM_BYTE)
MXMEM_WEIGHT_INSN(n,   "n",    1, fMX_UNPACK_NIBBLE_FROM_BYTE)
MXMEM_WEIGHT_INSN(c,   "c",    2, fMX_UNPACK_CRUMB_FROM_BYTE)
MXMEM_WEIGHT_INSN(sc,  "sc",   2, fMX_UNPACK_SCRUMB_FROM_BYTE)
MXMEM_WEIGHT_INSN(b1,  "ubit", 3, fMX_UNPACK_1BIT_FROM_BYTE)
MXMEM_WEIGHT_INSN(sb1, "sbit", 3, fMX_UNPACK_1SBIT_FROM_BYTE)








//TODO: Combine these into one somehow

#define MXMEMCONVERT_U8(TAG,OPCODE,SAT,FORMAT_OFFSET,RSV,RTV,DIRECTION,CLEAR_ACC) \
EXTINSN(TAG, OPCODE,  ATTRIBS(A_SHARED_EXTENSION,A_RESTRICT_SLOT0ONLY,A_HMX,A_MEMLIKE,A_HMX_BLOCK_ALIGN,A_STORE,A_VTCM_ALLBANK_ACCESS,A_EA_PAGECROSS),"Matrix Convert",  \
{   \
	fEA_REG(RSV);\
	fALIGN_CVT(EA, FORMAT_OFFSET);\
	fHIDE(hmx_convert_init(thread,insn->slot, EA, RSV, RTV, FORMAT_OFFSET, DIRECTION, HMX_UB);)\
	fHIDE(if (EXCEPTION_DETECTED) return;)\
	fHIDE(if (thread->bq_on) return;)\
	fHIDE(int spatial_size = 1<<thread->processor_ptr->arch_proc_options->hmx_spatial_size;)\
	fHIDE(int output_depth = thread->processor_ptr->arch_proc_options->hmx_output_depth;)\
	fHIDE(int acc_select = THREAD2STRUCT->current_acc_fxp;)\
	for(int spatial_idx = 0; spatial_idx < spatial_size; spatial_idx++) { \
		for(int output_idx = 0; output_idx < output_depth; output_idx++) { \
			fHIDE(size2u_t byte = 0;)\
            fHIDE(size8s_t acc  = 0;)\
			fHIDE(hmx_bias_t bias_reg = fMX_SELECT_BIAS(output_idx);)\
			acc = fMX_SELECT_ACCUMULATOR_FXP(spatial_idx, output_idx, acc_select);\
			fMX_RNDSAT_ACC_U8(byte, acc, bias_reg.fxp.bias32, bias_reg.fxp.exp, bias_reg.fxp.sig, bias_reg.fxp.rnd_bit, SAT, spatial_idx, output_idx, acc_select);\
			fMX_CONVERTED_ACCUMULATOR_FXP(spatial_idx, output_idx, byte);\
		}\
	}\
	fHIDE(fMX_UPDATE_CVT_ARRAY_PMU(0);)\
	CLEAR_ACC();\
})

#define MXMEMCONVERT_16x8(TAG,OPCODE,SAT,RSV,RTV,DIRECTION,CLEAR_ACC) \
EXTINSN(TAG, OPCODE,  ATTRIBS(A_SHARED_EXTENSION,A_RESTRICT_SLOT0ONLY,A_HMX,A_MEMLIKE,A_HMX_BLOCK_ALIGN,A_STORE,A_VTCM_ALLBANK_ACCESS,A_EA_PAGECROSS),"Matrix Convert",  \
{   \
	fEA_REG(RSV);\
	fALIGN_CVT(EA, FORMAT_SM);\
	fHIDE(hmx_convert_init(thread,insn->slot, EA, RSV, RTV, FORMAT_SM, DIRECTION, HMX_UH);)\
	fHIDE(if (EXCEPTION_DETECTED) return;)\
	fHIDE(if (thread->bq_on) return;)\
	fHIDE(int spatial_size = 1<<thread->processor_ptr->arch_proc_options->hmx_spatial_size;)\
	fHIDE(int output_depth = thread->processor_ptr->arch_proc_options->hmx_output_depth;)\
	fHIDE(int acc_select = THREAD2STRUCT->current_acc_fxp;)\
	for(int spatial_idx = 0; spatial_idx < spatial_size; spatial_idx+=2) { \
		for(int output_idx = 0; output_idx < output_depth; output_idx++) { \
            fHIDE(size2u_t halfword;)\
            fHIDE(size8s_t acc_ll;)\
			fHIDE(size8s_t acc_hl;)\
			fHIDE(hmx_bias_t bias_reg = fMX_SELECT_BIAS(output_idx);)\
			acc_ll = fMX_SELECT_ACCUMULATOR_FXP(spatial_idx+0, output_idx, acc_select);\
			acc_hl = fMX_SELECT_ACCUMULATOR_FXP(spatial_idx+1, output_idx, acc_select);\
			fMX_RNDSAT_ACC_U16(halfword, acc_hl, acc_ll, bias_reg.fxp.bias32, bias_reg.fxp.exp, bias_reg.fxp.sig, bias_reg.fxp.rnd_bit, SAT, spatial_idx, output_idx, acc_select);\
			fMX_CONVERTED_ACCUMULATOR_FXP(spatial_idx+0, output_idx, (halfword & 0xFF));\
			fMX_CONVERTED_ACCUMULATOR_FXP(spatial_idx+1, output_idx, ((halfword>>8) & 0xFF));\
		}\
	}\
	fHIDE(fMX_UPDATE_CVT_ARRAY_PMU(0);)\
	CLEAR_ACC();\
})

#define MXMEMCONVERT_16x16(TAG,OPCODE,SAT,RSV,RTV,DIRECTION,CLEAR_ACC) \
EXTINSN(TAG, OPCODE,  ATTRIBS(A_SHARED_EXTENSION,A_RESTRICT_SLOT0ONLY,A_HMX,A_MEMLIKE,A_HMX_BLOCK_ALIGN,A_STORE,A_VTCM_ALLBANK_ACCESS,A_EA_PAGECROSS),"Matrix Convert",  \
{   \
	fEA_REG(RSV);\
	fALIGN_CVT(EA, FORMAT_SM);\
	fHIDE(hmx_convert_init(thread,insn->slot, EA, RSV, RTV, FORMAT_SM, DIRECTION, HMX_UH_UH);)\
	fHIDE(if (EXCEPTION_DETECTED) return;)\
	fHIDE(if (thread->bq_on) return;)\
	fHIDE(int spatial_size = 1<<thread->processor_ptr->arch_proc_options->hmx_spatial_size;)\
	fHIDE(int output_depth = thread->processor_ptr->arch_proc_options->hmx_output_depth;)\
	fHIDE(int acc_select = THREAD2STRUCT->current_acc_fxp;)\
	for(int spatial_idx = 0; spatial_idx < spatial_size; spatial_idx+=2) { \
		for(int output_idx = 0; output_idx < output_depth; output_idx+=2) { \
            fHIDE(size2u_t halfword;)\
            fHIDE(size8s_t acc_ll;)\
			fHIDE(size8s_t acc_hl;)\
			fHIDE(size8s_t acc_lh;)\
			fHIDE(size8s_t acc_hh;)\
			fHIDE(hmx_bias_t bias_reg2 = fMX_SELECT_BIAS(output_idx+1);)\
			fHIDE(hmx_bias_t bias_reg = fMX_SELECT_BIAS(output_idx);)\
			fHIDE(size2u_t channel_offset = RSV & 0x40 ? 16 : 0;)\
			acc_ll = fMX_SELECT_ACCUMULATOR_FXP(spatial_idx+0, output_idx+0, acc_select);\
			acc_hl = fMX_SELECT_ACCUMULATOR_FXP(spatial_idx+1, output_idx+0, acc_select);\
			acc_lh = fMX_SELECT_ACCUMULATOR_FXP(spatial_idx+0, output_idx+1, acc_select);\
			acc_hh = fMX_SELECT_ACCUMULATOR_FXP(spatial_idx+1, output_idx+1, acc_select);\
			fMX_RNDSAT_ACC_U16x16(halfword, acc_hh, acc_hl, acc_lh, acc_ll, (size8s_t)bias_reg.fxp.bias32 << 16, bias_reg.fxp.exp, (bias_reg2.fxp.sig << 10) + bias_reg.fxp.sig, bias_reg.fxp.rnd_bit, SAT, spatial_idx, output_idx, acc_select);\
			fMX_CONVERTED_ACCUMULATOR_FXP(spatial_idx+0, (output_idx / 2) + channel_offset, (halfword & 0xFF));\
			fMX_CONVERTED_ACCUMULATOR_FXP(spatial_idx+1, (output_idx / 2) + channel_offset, ((halfword>>8) & 0xFF));\
		}\
	}\
	fHIDE(fMX_UPDATE_CVT_ARRAY_PMU(0);)\
	CLEAR_ACC();\
})

#define HMX_NOSAT 0
#define HMX_SAT 1

MXMEMCONVERT_U8(M8_mxcvtl_sat_ub,      	"mxmem(Rs32,Rt32):before:sat.ub=acc",           	HMX_SAT, FORMAT_SM, RsV, RtV, HMX_CVT_BEFORE, fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_U8(M8_mxcvtl_dm_sat_ub,   	"mxmem(Rs32,Rt32):before:cm:sat.ub=acc",        	HMX_SAT, FORMAT_DM, RsV, RtV, HMX_CVT_BEFORE, fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_U8(M8_mxcvtl_ub,          	"mxmem(Rs32,Rt32):before.ub=acc",               	HMX_NOSAT, FORMAT_SM, RsV, RtV, HMX_CVT_BEFORE, fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_U8(M8_mxcvtl_dm_ub,       	"mxmem(Rs32,Rt32):before:cm.ub=acc",            	HMX_NOSAT, FORMAT_DM, RsV, RtV, HMX_CVT_BEFORE, fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_U8(M8_mxcvtl_sat_ub_r,    	"mxmem(Rs32,Rt32):before:retain:sat.ub=acc",    	HMX_SAT, FORMAT_SM, RsV, RtV, HMX_CVT_BEFORE, fMX_NOCLEAR_ACC)
MXMEMCONVERT_U8(M8_mxcvtl_dm_sat_ub_r,	"mxmem(Rs32,Rt32):before:retain:cm:sat.ub=acc", 	HMX_SAT, FORMAT_DM, RsV, RtV, HMX_CVT_BEFORE, fMX_NOCLEAR_ACC)
MXMEMCONVERT_U8(M8_mxcvtl_ub_r,        	"mxmem(Rs32,Rt32):before:retain.ub=acc",        	HMX_NOSAT, FORMAT_SM, RsV, RtV, HMX_CVT_BEFORE, fMX_NOCLEAR_ACC)
MXMEMCONVERT_U8(M8_mxcvtl_dm_ub_r,     	"mxmem(Rs32,Rt32):before:retain:cm.ub=acc",     	HMX_NOSAT, FORMAT_DM, RsV, RtV, HMX_CVT_BEFORE, fMX_NOCLEAR_ACC)
MXMEMCONVERT_U8(M8_mxcvtr_sat_ub,      	"mxmem(Rs32,Rt32):after:sat.ub=acc",            	HMX_SAT, FORMAT_SM, RsV, RtV, HMX_CVT_AFTER,  fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_U8(M8_mxcvtr_dm_sat_ub,   	"mxmem(Rs32,Rt32):after:cm:sat.ub=acc",         	HMX_SAT, FORMAT_DM, RsV, RtV, HMX_CVT_AFTER,  fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_U8(M8_mxcvtr_ub,          	"mxmem(Rs32,Rt32):after.ub=acc",                	HMX_NOSAT, FORMAT_SM, RsV, RtV, HMX_CVT_AFTER,  fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_U8(M8_mxcvtr_dm_ub,       	"mxmem(Rs32,Rt32):after:cm.ub=acc",             	HMX_NOSAT, FORMAT_DM, RsV, RtV, HMX_CVT_AFTER,  fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_U8(M8_mxcvtr_sat_ub_r,    	"mxmem(Rs32,Rt32):after:retain:sat.ub=acc",     	HMX_SAT, FORMAT_SM, RsV, RtV, HMX_CVT_AFTER,  fMX_NOCLEAR_ACC)
MXMEMCONVERT_U8(M8_mxcvtr_dm_sat_ub_r, 	"mxmem(Rs32,Rt32):after:retain:cm:sat.ub=acc",  	HMX_SAT, FORMAT_DM, RsV, RtV, HMX_CVT_AFTER,  fMX_NOCLEAR_ACC)
MXMEMCONVERT_U8(M8_mxcvtr_ub_r,        	"mxmem(Rs32,Rt32):after:retain.ub=acc",         	HMX_NOSAT, FORMAT_SM, RsV, RtV, HMX_CVT_AFTER,  fMX_NOCLEAR_ACC)
MXMEMCONVERT_U8(M8_mxcvtr_dm_ub_r,     	"mxmem(Rs32,Rt32):after:retain:cm.ub=acc",      	HMX_NOSAT, FORMAT_DM, RsV, RtV, HMX_CVT_AFTER,  fMX_NOCLEAR_ACC)

MXMEMCONVERT_16x8(M8_mxcvtb_sat_uh,      "mxmem(Rs32,Rt32):before:sat.uh=acc:2x1",           HMX_SAT, 	RsV, RtV, HMX_CVT_BEFORE, fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_16x8(M8_mxcvtb_uh,          "mxmem(Rs32,Rt32):before.uh=acc:2x1",               HMX_NOSAT, RsV, RtV, HMX_CVT_BEFORE, fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_16x8(M8_mxcvtb_sat_uh_r,    "mxmem(Rs32,Rt32):before:retain:sat.uh=acc:2x1",    HMX_SAT, 	RsV, RtV, HMX_CVT_BEFORE, fMX_NOCLEAR_ACC)
MXMEMCONVERT_16x8(M8_mxcvtb_uh_r,        "mxmem(Rs32,Rt32):before:retain.uh=acc:2x1",        HMX_NOSAT, RsV, RtV, HMX_CVT_BEFORE, fMX_NOCLEAR_ACC)
MXMEMCONVERT_16x8(M8_mxcvta_sat_uh,      "mxmem(Rs32,Rt32):after:sat.uh=acc:2x1",            HMX_SAT, 	RsV, RtV, HMX_CVT_AFTER,  fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_16x8(M8_mxcvta_uh,          "mxmem(Rs32,Rt32):after.uh=acc:2x1",                HMX_NOSAT, RsV, RtV, HMX_CVT_AFTER,  fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_16x8(M8_mxcvta_sat_uh_r,    "mxmem(Rs32,Rt32):after:retain:sat.uh=acc:2x1",     HMX_SAT, 	RsV, RtV, HMX_CVT_AFTER,  fMX_NOCLEAR_ACC)
MXMEMCONVERT_16x8(M8_mxcvta_uh_r,        "mxmem(Rs32,Rt32):after:retain.uh=acc:2x1",         HMX_NOSAT, RsV, RtV, HMX_CVT_AFTER,  fMX_NOCLEAR_ACC)

MXMEMCONVERT_16x16(M8_mxcvtb_sat_uh2x2,   "mxmem(Rs32,Rt32):before:sat.uh=acc:2x2",        HMX_SAT,   RsV, RtV, HMX_CVT_BEFORE, fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_16x16(M8_mxcvtb_uh2x2,       "mxmem(Rs32,Rt32):before.uh=acc:2x2",            HMX_NOSAT, RsV, RtV, HMX_CVT_BEFORE, fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_16x16(M8_mxcvtb_sat_uh2x2_r, "mxmem(Rs32,Rt32):before:retain:sat.uh=acc:2x2", HMX_SAT,   RsV, RtV, HMX_CVT_BEFORE, fMX_NOCLEAR_ACC)
MXMEMCONVERT_16x16(M8_mxcvtb_uh2x2_r,     "mxmem(Rs32,Rt32):before:retain.uh=acc:2x2",     HMX_NOSAT, RsV, RtV, HMX_CVT_BEFORE, fMX_NOCLEAR_ACC)
MXMEMCONVERT_16x16(M8_mxcvta_sat_uh2x2,   "mxmem(Rs32,Rt32):after:sat.uh=acc:2x2",         HMX_SAT,   RsV, RtV, HMX_CVT_AFTER,  fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_16x16(M8_mxcvta_uh2x2,       "mxmem(Rs32,Rt32):after.uh=acc:2x2",             HMX_NOSAT, RsV, RtV, HMX_CVT_AFTER,  fMX_CLEAR_ACC_FXP)
MXMEMCONVERT_16x16(M8_mxcvta_sat_uh2x2_r, "mxmem(Rs32,Rt32):after:retain:sat.uh=acc:2x2",  HMX_SAT,   RsV, RtV, HMX_CVT_AFTER,  fMX_NOCLEAR_ACC)
MXMEMCONVERT_16x16(M8_mxcvta_uh2x2_r,     "mxmem(Rs32,Rt32):after:retain.uh=acc:2x2",      HMX_NOSAT, RsV, RtV, HMX_CVT_AFTER,  fMX_NOCLEAR_ACC)


//MXMEMCONVERT_FP16(M8_mxcvtl_sat_hi_hf,    "mxmem(Rs32,Rt32):before:hi.hf=acc",         HMX_NOSAT,  RsV, RtV, HMX_CVT_BEFORE, fMX_CLEAR_ACC_FLT, HMX_FP_CVT_HI)
//MXMEMCONVERT_FP16(M8_mxcvtl_sat_lo_hf,    "mxmem(Rs32,Rt32):before:lo.hf=acc",         HMX_NOSAT,  RsV, RtV, HMX_CVT_BEFORE, fMX_CLEAR_ACC_FLT, HMX_FP_CVT_LO)
//MXMEMCONVERT_FP16(M8_mxcvtl_sat_hi_hf_r,  "mxmem(Rs32,Rt32):before:retain:hi.hf=acc",  HMX_NOSAT,  RsV, RtV, HMX_CVT_BEFORE, fMX_NOCLEAR_ACC,   HMX_FP_CVT_HI)
//MXMEMCONVERT_FP16(M8_mxcvtl_sat_lo_hf_r,  "mxmem(Rs32,Rt32):before:retain:lo.hf=acc",  HMX_NOSAT,  RsV, RtV, HMX_CVT_BEFORE, fMX_NOCLEAR_ACC,   HMX_FP_CVT_LO)
//MXMEMCONVERT_FP16(M8_mxcvtr_sat_hi_hf,    "mxmem(Rs32,Rt32):after:hi.hf=acc",          HMX_NOSAT,  RsV, RtV, HMX_CVT_AFTER,  fMX_CLEAR_ACC_FLT, HMX_FP_CVT_HI)
//MXMEMCONVERT_FP16(M8_mxcvtr_sat_lo_hf,    "mxmem(Rs32,Rt32):after:lo.hf=acc",          HMX_NOSAT,  RsV, RtV, HMX_CVT_AFTER,  fMX_CLEAR_ACC_FLT, HMX_FP_CVT_LO)
//MXMEMCONVERT_FP16(M8_mxcvtr_sat_hi_hf_r,  "mxmem(Rs32,Rt32):after:retain:hi.hf=acc",   HMX_NOSAT,  RsV, RtV, HMX_CVT_AFTER,  fMX_NOCLEAR_ACC,   HMX_FP_CVT_HI)
//MXMEMCONVERT_FP16(M8_mxcvtr_sat_lo_hf_r,  "mxmem(Rs32,Rt32):after:retain:lo.hf=acc",   HMX_NOSAT,  RsV, RtV, HMX_CVT_AFTER,  fMX_NOCLEAR_ACC,   HMX_FP_CVT_HI)




EXTINSN(M8_mxmem_bias,  "bias=mxmem(Rs32)",  ATTRIBS(A_SHARED_EXTENSION,A_MEMLIKE,A_LOAD,A_HMX,A_RESTRICT_NOSLOT1_STORE,A_RESTRICT_SLOT0ONLY), "Matrix Bias and Scale",
{
	fHIDE(int output_depth = thread->processor_ptr->arch_proc_options->hmx_output_depth;)
	fEA_REG(RsV);
	fHIDE(hmx_bias_init(thread, insn->slot, EA, access_type_hmx_load_bias, thread->processor_ptr->arch_proc_options->hmx_output_depth*4);)
	fALIGN_FXP_DEPTH(EA,1);
	fHIDE(if (EXCEPTION_DETECTED) return;)
	for(int output_idx = 0; output_idx < output_depth; output_idx++) {
		fMX_LOAD_BIAS_LO(output_idx, EA, thread->mem_access[insn->slot].paddr);
	}
	fHIDE(THREAD2STRUCT->fxp_commit_state.bias_update=1;)
})
EXTINSN(M8_mxmem_st_bias,    "mxmem(Rs32)=bias", ATTRIBS(A_SHARED_EXTENSION,A_MEMLIKE,A_STORE,A_RESTRICT_NOSLOT1_STORE,A_RESTRICT_SLOT0ONLY,A_HMX), "Store Matrix Bias and Scale", \
{
	fHIDE(int output_depth = thread->processor_ptr->arch_proc_options->hmx_output_depth;)
	fEA_REG(RsV);
	fHIDE(hmx_bias_init(thread, insn->slot, EA, access_type_hmx_store_bias, thread->processor_ptr->arch_proc_options->hmx_output_depth*4);)
	fALIGN_FXP_DEPTH(EA,1);
	fHIDE(if (EXCEPTION_DETECTED) return;)
	for(int output_idx = 0; output_idx < output_depth; output_idx++) {
		fMX_STORE_BIAS(output_idx, EA);
	}
	fHIDE(THREAD2STRUCT->fxp_commit_state.bias_write = 1;)
})

EXTINSN(M8_mxmem2_bias,  "bias=mxmem2(Rs32)",  ATTRIBS(A_SHARED_EXTENSION,A_VTCM_ALLBANK_ACCESS,A_MEMLIKE,A_LOAD,A_HMX,A_RESTRICT_NOSLOT1_STORE,A_RESTRICT_SLOT0ONLY), "Matrix Bias and Scale",
{
	fHIDE(int output_depth = thread->processor_ptr->arch_proc_options->hmx_output_depth;)
	fEA_REG(RsV);
	fHIDE(hmx_bias_init(thread, insn->slot, EA, access_type_hmx_load_bias, thread->processor_ptr->arch_proc_options->hmx_output_depth*8);)
	fALIGN_FXP_DEPTH(EA,2);
	fHIDE(if (EXCEPTION_DETECTED) return;)
	for(int output_idx = 0; output_idx < output_depth; output_idx++) {
		fMX_LOAD_BIAS_LO(output_idx, EA, thread->mem_access[insn->slot].paddr);
		fMX_LOAD_BIAS_HI(output_idx, EA, thread->mem_access[insn->slot].paddr);
	}
	fHIDE(THREAD2STRUCT->fxp_commit_state.bias_update=1;)
})
EXTINSN(M8_mxmem2_st_bias,    "mxmem2(Rs32)=bias", ATTRIBS(A_SHARED_EXTENSION,A_VTCM_ALLBANK_ACCESS,A_MEMLIKE,A_STORE,A_RESTRICT_NOSLOT1_STORE,A_RESTRICT_SLOT0ONLY,A_HMX), "Store Matrix Bias and Scale", \
{
	fHIDE(int output_depth = thread->processor_ptr->arch_proc_options->hmx_output_depth;)
	fEA_REG(RsV);
	fHIDE(hmx_bias_init(thread, insn->slot, EA, access_type_hmx_store_bias, thread->processor_ptr->arch_proc_options->hmx_output_depth*8);)
	fALIGN_FXP_DEPTH(EA,2);
	fHIDE(if (EXCEPTION_DETECTED) return;)
	for(int output_idx = 0; output_idx < output_depth; output_idx++) {
		fMX_STORE_BIAS_DOUBLE(output_idx, EA);
	}
	fHIDE(THREAD2STRUCT->fxp_commit_state.bias_write = 2;)
})



EXTINSN(M8_mxclracc,    "mxclracc",     ATTRIBS(A_SHARED_EXTENSION,A_HMX,A_MEMLIKE_PACKET_RULES,A_RESTRICT_SLOT0ONLY), "Clear both fxp accumulators", {	fMX_CLEAR_BOTH_ACC_FXP(); })
EXTINSN(M8_mxswap,      "mxswapacc",     ATTRIBS(A_SHARED_EXTENSION,A_HMX,A_HMX_ACC,A_MEMLIKE_PACKET_RULES,A_RESTRICT_SLOT0ONLY), "Swap fxp accumulators", {	fMX_SWAP_ACC_FXP(); })


EXTINSN(M8_mxaccshl,    "acc=mxshl(acc,#16)",     ATTRIBS(A_SHARED_EXTENSION,A_HMX,A_MEMLIKE_PACKET_RULES,A_RESTRICT_SLOT0ONLY,A_NOTE_NOLAHAINAV1), "Left shift accumulator",
{
	fHIDE(memcpy(THREAD2STRUCT->future_accum_fxp, THREAD2STRUCT->accum_fxp, sizeof(hmx_acc_fxp_t)*MAX_ACCUMULATORS_DEPTH*MAX_ACCUMULATORS_SPATIAL);)
	fHIDE(int current_acc = THREAD2STRUCT->current_acc_fxp;)
	fHIDE(int spatial_size = 1<<thread->processor_ptr->arch_proc_options->hmx_spatial_size;)
	fHIDE(int output_depth = thread->processor_ptr->arch_proc_options->hmx_output_depth;)
	for(int spatial_idx = 0; spatial_idx < spatial_size; spatial_idx++) {
		for(int output_idx = 0; output_idx < output_depth; output_idx++) {
			fMX_SHL16_ACCUMULATOR_FXP(spatial_idx, output_idx, current_acc);
		}
	}
	fHIDE(THREAD2STRUCT->fxp_commit_state.acc_update = 1;)
})


// DEBUG PRINTS, VECX attribute for now, probably doesn't need any attribute
EXTINSN(M8_pv64d, "pmxd", ATTRIBS(A_SHARED_EXTENSION,A_HMX,A_VDBG,A_FAKEINSN,A_MEMLIKE), "Matrix Accumulator Print", { hmx_debug_print_acc(thread, !HMX_HEX, HMX_FULL, 0); })
EXTINSN(M8_pv64,  "pmx",  ATTRIBS(A_SHARED_EXTENSION,A_HMX,A_VDBG,A_FAKEINSN,A_MEMLIKE), "Matrix Accumulator Print", { hmx_debug_print_acc(thread,  HMX_HEX, HMX_FULL, 0); })
EXTINSN(M8_pv64dfp, "pmxfpd", ATTRIBS(A_SHARED_EXTENSION,A_HMX,A_VDBG,A_FAKEINSN,A_MEMLIKE), "Matrix Accumulator Print", { hmx_debug_print_acc(thread, !HMX_HEX, HMX_FULL, 1); })
EXTINSN(M8_pv64fp,  "pmxfp",  ATTRIBS(A_SHARED_EXTENSION,A_HMX,A_VDBG,A_FAKEINSN,A_MEMLIKE), "Matrix Accumulator Print", { hmx_debug_print_acc(thread,  HMX_HEX, HMX_FULL, 1); })
EXTINSN(M8_pldacc,  "pmxaccpreload",  ATTRIBS(A_SHARED_EXTENSION,A_HMX,A_VDBG,A_FAKEINSN,A_MEMLIKE), "Matrix Accumulator Print", { hmx_preload_file(thread); })


#ifdef __SELF_DEF_EXTINSN
#undef EXTINSN
#undef __SELF_DEF_EXTINSN
#endif
