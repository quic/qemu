/*
 *  Copyright (c) 2019 Qualcomm Innovation Center, Inc. All Rights Reserved.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* There are 32 general user regs and up to   
 *  32 user control regs.
 * 
 * $Id$
 */


DEF_REG(REG_R_REGS,          /* Tag */
	"General Registers", /* Name */
	"r%02d",                 /* Symbol for register */
	32,                  /* How many are there */
	0)                   /* The position in register array of 1st element */

#define REG_LR 31
#define REG_FP 30
#define REG_SP 29
//#define REG_GP 28

DEF_REG(REG_SA0,"Start Address 0",         "sa0", 1,NUM_GEN_REGS+0)
DEF_REG(REG_LC0,"Loop Count 0",            "lc0", 1,NUM_GEN_REGS+1)
DEF_REG(REG_SA1,"Start Address 1",         "sa1", 1,NUM_GEN_REGS+2)
DEF_REG(REG_LC1,"Loop Count 1",            "lc1", 1,NUM_GEN_REGS+3)
DEF_REG(REG_PQ,"Predicate Quad",	  "p3:0", 1,NUM_GEN_REGS+4)
DEF_REG(REG_M,"Modifier Register",         "m%d", 2,NUM_GEN_REGS+6)     
DEF_REG(REG_USR,"User status register",    "usr", 1,NUM_GEN_REGS+8)
DEF_REG(REG_PC,"Program Counter",           "pc", 1,NUM_GEN_REGS+9)   
DEF_REG(REG_UGP,"User general pointer",    "ugp", 1,NUM_GEN_REGS+10)
DEF_REG(REG_GP, "Global pointer",          "gp",  1,NUM_GEN_REGS+11)
DEF_REG(REG_CSA, "Circular Start",          "cs%d",2,NUM_GEN_REGS+12)
DEF_REG(REG_UPCYCLE_LO,"User PCycle Lo","upcyclelo",1,NUM_GEN_REGS+14)
DEF_REG(REG_UPCYCLE_HI,"User PCycle Hi","upcyclehi",1,NUM_GEN_REGS+15)

DEF_REG(REG_FRAMELIMIT,"Frame Limit", "framelimit",1,NUM_GEN_REGS+16)
DEF_REG(REG_FRAMEKEY,"Frame Key",       "framekey",1,NUM_GEN_REGS+17)
DEF_REG(REG_PKTCNT_LO,"Packet Count Lo","pktcntlo",1,NUM_GEN_REGS+18)
DEF_REG(REG_PKTCNT_HI,"Packet Count Hi","pktcnthi",1,NUM_GEN_REGS+19)

//DEF_REG(REG_UPMUCNT0,"User pmucnt0",    "upmucnt0",1,NUM_GEN_REGS+22)
//DEF_REG(REG_UPMUCNT1,"User pmucnt1",    "upmucnt1",1,NUM_GEN_REGS+23)
//DEF_REG(REG_UPMUCNT2,"User pmucnt2",    "upmucnt2",1,NUM_GEN_REGS+24)
//DEF_REG(REG_UPMUCNT3,"User pmucnt3",    "upmucnt3",1,NUM_GEN_REGS+25)
//DEF_REG(REG_UPMUCNT3,"User pmucnt4",    "upmucnt4",1,NUM_GEN_REGS+26)
//DEF_REG(REG_UPMUCNT3,"User pmucnt5",    "upmucnt5",1,NUM_GEN_REGS+27)
//DEF_REG(REG_UPMUCNT3,"User pmucnt6",    "upmucnt6",1,NUM_GEN_REGS+28)
//DEF_REG(REG_UPMUCNT3,"User pmucnt7",    "upmucnt7",1,NUM_GEN_REGS+29)

DEF_REG(REG_UTIMERLO,"User timer lo",    "utimerlo",1,NUM_GEN_REGS+30)
DEF_REG(REG_UTIMERHI,"User timer hi",    "utimerhi",1,NUM_GEN_REGS+31)

/* FIXME: we are wasting more than 16 regs of empty space in the
   thread->Regs[] array. We should not associsate the regs array
   index with the encoding index for these special regs.
   Needs to be fixed in external api as well as here
*/
DEF_REG(REG_SGP,"System Gen Pointer",    "sgp%d", 2, NUM_GEN_REGS+32)
DEF_REG(REG_TID,"Software Thread ID",     "stid", 1, NUM_GEN_REGS+34) 
DEF_REG(REG_ELR,"Exception Link Register", "elr", 1, NUM_GEN_REGS+35)
DEF_REG(REG_BADVA0,"Slot 0 BADVA",      "badva0", 1, NUM_GEN_REGS+36)
DEF_REG(REG_BADVA1,"Slot 1 BADVA",      "badva1", 1, NUM_GEN_REGS+37)
DEF_REG(REG_SSR,"System Status Register",  "ssr", 1, NUM_GEN_REGS+38) 
DEF_REG(REG_CCR,"Cache Control Register",  "ccr", 1, NUM_GEN_REGS+39)
DEF_REG(REG_TNUM,"hardware thread ID",    "htid", 1, NUM_GEN_REGS+40)
DEF_REG(REG_BADVA,"Bad Virtual Address", "badva", 1, NUM_GEN_REGS+41)
DEF_REG(REG_IMASK,"Interrupt Mask",      "imask", 1, NUM_GEN_REGS+42)
DEF_REG(REG_GEVB,"Guest Event Vector Base","gevb",1, NUM_GEN_REGS+43)

/* Put G reg map at the end? */
/* FIXME: EJP: I allocated all possible regs for now, thread->Regs array still
 * too big */

DEF_REG(REG_GELR,"Guest Event Link Register","gelr",1,NUM_GEN_REGS+48)
DEF_REG(REG_GSR,"Guest Status Register",      "gsr",1,NUM_GEN_REGS+49)
DEF_REG(REG_GOSP,"Guest Other Stack Pointer","gosp",1,NUM_GEN_REGS+50)
DEF_REG(REG_GBADVA,"Guest BADVA",          "gbadva",1,NUM_GEN_REGS+51)

DEF_REG(REG_GCOMMIT_1T,"Guest Commit with 1T running", "gcommit1t",1,NUM_GEN_REGS+52)
DEF_REG(REG_GCOMMIT_2T,"Guest Commit with 2T running", "gcommit2t",1,NUM_GEN_REGS+53)
DEF_REG(REG_GCOMMIT_3T,"Guest Commit with 3T running", "gcommit3t",1,NUM_GEN_REGS+54)
DEF_REG(REG_GCOMMIT_4T,"Guest Commit with 4T running", "gcommit4t",1,NUM_GEN_REGS+55)
DEF_REG(REG_GCOMMIT_5T,"Guest Commit with 5T running", "gcommit5t",1,NUM_GEN_REGS+56)
DEF_REG(REG_GCOMMIT_6T,"Guest Commit with 6T running", "gcommit6t",1,NUM_GEN_REGS+57)

DEF_REG(REG_GCYCLE_1T,"Guest Cycles with 1T running", "gpcycle1t",1,NUM_GEN_REGS+58)
DEF_REG(REG_GCYCLE_2T,"Guest Cycles with 2T running", "gpcycle2t",1,NUM_GEN_REGS+59)
DEF_REG(REG_GCYCLE_3T,"Guest Cycles with 3T running", "gpcycle3t",1,NUM_GEN_REGS+60)
DEF_REG(REG_GCYCLE_4T,"Guest Cycles with 4T running", "gpcycle4t",1,NUM_GEN_REGS+61)
DEF_REG(REG_GCYCLE_5T,"Guest Cycles with 5T running", "gpcycle5t",1,NUM_GEN_REGS+62)
DEF_REG(REG_GCYCLE_6T,"Guest Cycles with 6T running", "gpcycle6t",1,NUM_GEN_REGS+63)



DEF_REG(REG_GPMUCNT4,"Guest PMUCNT4",    "gpmucnt4",1,NUM_GEN_REGS+64)
DEF_REG(REG_GPMUCNT5,"Guest PMUCNT5",    "gpmucnt5",1,NUM_GEN_REGS+65)
DEF_REG(REG_GPMUCNT6,"Guest PMUCNT6",    "gpmucnt6",1,NUM_GEN_REGS+66)
DEF_REG(REG_GPMUCNT7,"Guest PMUCNT7",    "gpmucnt7",1,NUM_GEN_REGS+67)
DEF_REG(REG_GPCYCLO, "Guest PCYCLELO",  "gpcyclelo",1,NUM_GEN_REGS+72)
DEF_REG(REG_GPCYCHI, "Guest PCYCLEHI",  "gpcyclehi",1,NUM_GEN_REGS+73)
DEF_REG(REG_GPMUCNT0,"Guest PMUCNT0",    "gpmucnt0",1,NUM_GEN_REGS+74)
DEF_REG(REG_GPMUCNT1,"Guest PMUCNT1",    "gpmucnt1",1,NUM_GEN_REGS+75)
DEF_REG(REG_GPMUCNT2,"Guest PMUCNT2",    "gpmucnt2",1,NUM_GEN_REGS+76)
DEF_REG(REG_GPMUCNT3,"Guest PMUCNT3",    "gpmucnt3",1,NUM_GEN_REGS+77)




//DEF_REG(REG_A,  "Address Registers",          "a%d",64,NUM_GEN_REGS+80)

#if 0 // no ptw
DEF_REG(REG_SCTLR,   "A0: System Control Register", "sctlr", 1,REG_GELR+32)
DEF_REG(REG_TTBCR,   "A2: TTBCR",                   "ttbcr", 1,REG_SCTLR+2)
DEF_REG(REG_TTBCR2,  "A3: TTBCR2",                 "ttbcr2", 1,REG_SCTLR+3)
DEF_REG(REG_TTBR0L,  "A4: TTBR0L",                 "ttbr0l", 1,REG_SCTLR+4)
DEF_REG(REG_TTBR0H,  "A5: TTBR0H",                 "ttbr0h", 1,REG_SCTLR+5)
DEF_REG(REG_TTBR1L,  "A6: TTBR1L",                 "ttbr0l", 1,REG_SCTLR+6)
DEF_REG(REG_TTBR1H,  "A7: TTBR1H",                 "ttbr0h", 1,REG_SCTLR+7)
DEF_REG(REG_MAIRL,   "A10: MAIRL",                  "mairl", 1,REG_SCTLR+10)
DEF_REG(REG_MAIRH,   "A11: MAIRH",                  "mairh", 1,REG_SCTLR+11)
DEF_REG(REG_IPARL,   "A14: IPARL",                  "iparl", 1,REG_SCTLR+14)
DEF_REG(REG_IPARH,   "A15: IPARH",                  "iparh", 1,REG_SCTLR+15)
DEF_REG(REG_VSCTLR,  "A16: VSCTLR",                "vsctlr", 1,REG_SCTLR+16)
DEF_REG(REG_VOPAQUE, "Invisible Values",          "vopaque", 1,REG_VSCTLR+1)
DEF_REG(REG_VTTBCR,  "A18: VTTBCR",                "vttbcr", 1,REG_VSCTLR+2)
DEF_REG(REG_VTTBCR2, "A19: VTTBCR2",              "vttbcr2", 1,REG_VSCTLR+3)
DEF_REG(REG_VTTBRL,  "A20: VTTBRL",                "vttbrl", 1,REG_VSCTLR+4)
DEF_REG(REG_VTTBRH,  "A21: VTTBRH",                "vttbrh", 1,REG_VSCTLR+5)
DEF_REG(REG_PARL,    "A30: PARL",                    "parl", 1,REG_VSCTLR+14)
DEF_REG(REG_PARH,    "A31: PARH",                    "parh", 1,REG_VSCTLR+15)
DEF_REG(REG_HSCTLR,  "A32: HSCTLR",                "hsctlr", 1,REG_VSCTLR+16)
DEF_REG(REG_HTTBCR,  "A34: HTTBCR",                "httbcr", 1,REG_HSCTLR+2)
DEF_REG(REG_HTTBCR2, "A35: HTTBCR2",              "httbcr2", 1,REG_HSCTLR+3)
DEF_REG(REG_HTTBRL,  "A36: HTTBR",                 "httbrl", 1,REG_HSCTLR+4)
DEF_REG(REG_HTTBRH,  "A37: HTTBR",                 "httbrh", 1,REG_HSCTLR+5)
DEF_REG(REG_HMAIRL,  "A36: HMAIRL",                "hmairl", 1,REG_HSCTLR+8)
DEF_REG(REG_HMAIRH,  "A37: HMAIRH",                "hmairh", 1,REG_HSCTLR+9)
DEF_REG(REG_HOPAQUE, "Invisible Values",          "hopaque", 1,REG_HSCTLR+1)

// EJP: we probably want to put VMID somewhere in the per-thread space
//DEF_REG(CBAR,    "A10: CBAR",                    "cbar", 1,REG_SCTLR+10)
//DEF_REG(CBA2R,   "A11: CBA2R",                  "cba2r", 1,REG_SCTLR+11)
#endif
/* Global registers */
DEF_GLOBAL_REG(REG_EVB,"Exception Vector Base",   "evb", 1, 0)
DEF_GLOBAL_REG(REG_MODECTL,"Mode Control",    "modectl", 1, 1)
DEF_GLOBAL_REG(REG_SYSCONF,"System Config",    "syscfg", 1, 2)
//DEF_GLOBAL_REG(REG_EVB1,"Event Vector Base (alt)","evb1",1, 3)
#ifdef NEW_INTERRUPTS
DEF_GLOBAL_REG(REG_IPENDAD,"Interrupts Pending and Auto Disabled",  "ipendad", 1, 4)
#else
DEF_GLOBAL_REG(REG_IPEND,"Interrupts Pending",  "ipend", 1, 4)
#endif
DEF_GLOBAL_REG(REG_VID,"Vector ID","vid",                1, 5)
#ifndef NEW_INTERRUPTS
DEF_GLOBAL_REG(REG_IAD,"Interrupt Auto Disable","iad",   1, 6)
#else
DEF_GLOBAL_REG(REG_VID1,"Vector ID 1","vid1",   1, 6)
#endif
DEF_GLOBAL_REG(REG_BESTWAIT,"Best Waiting","bestwait",   1, 7)
#ifndef NEW_INTERRUPTS
DEF_GLOBAL_REG(REG_IEL,"Interrupt Edge/Level","iel",     1, 8)
#endif
DEF_GLOBAL_REG(REG_SCHEDCFG,"Scheduling Assist Cfg","schedcfg", 1, 9)
#ifndef NEW_INTERRUPTS
DEF_GLOBAL_REG(REG_IAHL,"Interrupt Active High/Low","iahl", 1, 10)
#endif
DEF_GLOBAL_REG(REG_CFGBASE,"Config Base","cfgbase",      1, 11)
DEF_GLOBAL_REG(REG_DIAG,"DIAG",                  "diag", 1, 12)
DEF_GLOBAL_REG(REG_REV,"Revision",               "rev",  1, 13)
DEF_GLOBAL_REG(REG_PCYCLELO,"pcyclelo",      "pcyclelo", 1, 14)
DEF_GLOBAL_REG(REG_PCYCLEHI,"pcyclehi",      "pcyclehi", 1, 15)


DEF_GLOBAL_REG(REG_ISDBST,"ISDB status",              "isdbst", 1, 16)
DEF_GLOBAL_REG(REG_ISDBCFG0,"ISDB cfg0",            "isdbcfg0", 1, 17)
DEF_GLOBAL_REG(REG_ISDBCFG1,"ISDB cfg1",            "isdbcfg1", 1, 18)

DEF_GLOBAL_REG(REG_LIVELOCK,"livelock",	              "livelock",1,19) /* CR #35 */

DEF_GLOBAL_REG(REG_BRKPTPC0,"ISDB brkpt PC0",       "brkptpc0", 1, 20)
DEF_GLOBAL_REG(REG_BRKPTCFG0,"ISDB brkpt cfg0" ,   "brkptcfg0", 1, 21)
DEF_GLOBAL_REG(REG_BRKPTPC1,"ISDB brkpt PC1",       "brkptpc1", 1, 22)
DEF_GLOBAL_REG(REG_BRKPTCFG1,"ISDB brkpt cfg1",    "brkptcfg1", 1, 23)
DEF_GLOBAL_REG(REG_ISDBMBXIN,"ISDB mailbox in",    "isdbmbxin", 1, 24)
DEF_GLOBAL_REG(REG_ISDBMBXOUT,"ISDB mailbox out", "isdbmbxout", 1, 25)
DEF_GLOBAL_REG(REG_ISDBEN,"ISDB en",                  "isdben", 1, 26)
DEF_GLOBAL_REG(REG_ISDBGPR,"ISDB gpr",                "isdbgpr",1, 27)

DEF_GLOBAL_REG(REG_PMUCNT4,"PMU Counter 4",          "pmucnt4", 1, 28)
DEF_GLOBAL_REG(REG_PMUCNT5,"PMU Counter 5",          "pmucnt5", 1, 29)
DEF_GLOBAL_REG(REG_PMUCNT6,"PMU Counter 6",          "pmucnt6", 1, 30)
DEF_GLOBAL_REG(REG_PMUCNT7,"PMU Counter 7",          "pmucnt7", 1, 31)

DEF_GLOBAL_REG(REG_PMUCNT0,"PMU Counter 0",          "pmucnt0", 1, 32)
DEF_GLOBAL_REG(REG_PMUCNT1,"PMU Counter 1",          "pmucnt1", 1, 33)
DEF_GLOBAL_REG(REG_PMUCNT2,"PMU Counter 2",          "pmucnt2", 1, 34)
DEF_GLOBAL_REG(REG_PMUCNT3,"PMU Counter 3",          "pmucnt3", 1, 35)
DEF_GLOBAL_REG(REG_PMUEVTCFG,"PMU Event Config",   "pmuevtcfg", 1, 36)
DEF_GLOBAL_REG(REG_PMUSTID0,"PMU STID Match 0",     "pmustid0", 1, 37)
DEF_GLOBAL_REG(REG_PMUEVTCFG1,"PMU Event Config1",   "pmuevtcfg1", 1, 38)
DEF_GLOBAL_REG(REG_PMUSTID1,"PMU STID Match 1",     "pmustid1", 1, 39)


DEF_GLOBAL_REG(REG_TIMERLO,"Timer Lo",               "timerlo", 1, 40)
DEF_GLOBAL_REG(REG_TIMERHI,"Timer Hi",               "timerhi", 1, 41)

DEF_GLOBAL_REG(REG_PMUCFG,"PMU Configuration",        "pmucfg", 1, 42)

/* AVS register */
DEF_GLOBAL_REG(REG_RGDR2,"rgdr2",		     "rgdr2",1,43)

/* Chicken type registers CR index 60-63 */
DEF_GLOBAL_REG(REG_RGDR,"rgdr",                      "rgdr",1,44)
DEF_GLOBAL_REG(REG_TURKEY,"Gobble Gobble",		     "turkey",1,45)
DEF_GLOBAL_REG(REG_DUCK,"Quack Quack",		         "duck",1,46)
DEF_GLOBAL_REG(REG_CHICKEN,"cluck cluck",            "chicken",1, 47)


/* Registers that do not actually have accessability in the core */
DEF_GLOBAL_REG(REG_COMMIT_1T,"Commit with 1T running", "commit1t",1,48)
DEF_GLOBAL_REG(REG_COMMIT_2T,"Commit with 2T running", "commit2t",1,49)
DEF_GLOBAL_REG(REG_COMMIT_3T,"Commit with 3T running", "commit3t",1,50)
DEF_GLOBAL_REG(REG_COMMIT_4T,"Commit with 4T running", "commit4t",1,51)
DEF_GLOBAL_REG(REG_COMMIT_5T,"Commit with 5T running", "commit5t",1,52)
DEF_GLOBAL_REG(REG_COMMIT_6T,"Commit with 6T running", "commit6t",1,53)
DEF_GLOBAL_REG(REG_CYCLE_1T,"Cycles with 1T running", "pcycle1t",1,54)
DEF_GLOBAL_REG(REG_CYCLE_2T,"Cycles with 2T running", "pcycle2t",1,55)
DEF_GLOBAL_REG(REG_CYCLE_3T,"Cycles with 3T running", "pcycle3t",1,56)
DEF_GLOBAL_REG(REG_CYCLE_4T,"Cycles with 4T running", "pcycle4t",1,57)
DEF_GLOBAL_REG(REG_CYCLE_5T,"Cycles with 5T running", "pcycle5t",1,58)
DEF_GLOBAL_REG(REG_CYCLE_6T,"Cycles with 6T running", "pcycle6t",1,59)


DEF_GLOBAL_REG(REG_STFINST,"Stuff Instruction",      "stfinst", 1, 60)
DEF_GLOBAL_REG(REG_ISDBCMD,"ISDB Command",           "isdbcmd", 1, 61)
DEF_GLOBAL_REG(REG_ISDBVER,"ISDB Version",           "isdbver", 1, 62)
DEF_GLOBAL_REG(REG_BRKPTINFO,"Breakpoint Info",    "brkptinfo", 1, 63)






#if 0 // no ptw
DEF_GLOBAL_REG(REG_TLBLL,"Low word of low dword of TLB interface", "tlbll",1, 48+12)
DEF_GLOBAL_REG(REG_TLBLH,"Hi  word of low dword of TLB interface", "tlblh",1, 48+13)
DEF_GLOBAL_REG(REG_TLBHL,"Low word of hi  dword of TLB interface", "tlbhl",1, 48+14)
DEF_GLOBAL_REG(REG_TLBHH,"Hi  word of hi  dword of TLB interface", "tlbhh",1, 48+15)
#endif

/* These registers have no use in core -- they are subsystem
   defined/used. We keep them here so that all registers in the
   core+subsystem can live in a central database.
*/              
DEF_SUBSYS_REG(REG_BRKPTINFO,"ISDB Breakpoint Info",128)
DEF_SUBSYS_REG(REG_STFINST,"ISDB Stuff Instruction",129)
DEF_SUBSYS_REG(REG_ISDBCMD,"ISDB Command",130)
DEF_SUBSYS_REG(REG_ISDBVER,"ISDB Version",131)


/* Shared TLB */


/* For registers that have individual fields, 
   explain them here
     DEF_REG_FIELD(tag,
                   name,
                   bit start offset,
                   width,
                   description
*/	
/* SSR fields */
DEF_REG_FIELD(SSR_CAUSE,"cause",0,8,"8-bit read-write field that contains the reason for various exception conditions. The contents of the Cause field depend on the exception type.")
DEF_REG_FIELD(SSR_ASID,"asid",8,7,"7-bit read-write field that contains the Address Space Identifier. This number is used as a tag extension in virtual addressing.")
DEF_REG_FIELD(SSR_UM,"um",16,1,"read-write bit that, together with the EX bit, indicates whether the thread is in User mode.")
DEF_REG_FIELD(SSR_EX,"ex",17,1,"read-write bit that is set when an interrupt or exception is accepted. This bit provides an indication that an interrupt or exception is currently being processed. The bit is cleared upon execution of the return from the exception instruction (rte). Interrupts are disabled when EX is set.")
DEF_REG_FIELD(SSR_IE,"ie",18,1,"read-write bit that indicates whether the global interrupt is enabled or disabled.")
DEF_REG_FIELD(SSR_GM,"gm",19,1,"Guest mode bit that, together with the EX bit, indicates whether the thread is in Guest mode.")
DEF_REG_FIELD(SSR_V0, "v0",20,1,"read-write bit that indicates whether the BADVA0 register contents are associated with a valid slot 0 memory instruction.")
DEF_REG_FIELD(SSR_V1, "v1",21,1,"read-write bit that indicates whether the BADVA1 register contents are associated with a valid slot 1 memory instruction.")
DEF_REG_FIELD(SSR_BVS,"bvs",22,1,"read-write bit for the BADVA Selector, which indicates whether BADVA0 or BADVA1 contains the faulting address.")
DEF_REG_FIELD(SSR_CE, "ce",23,1,"read-write bit for Cycle Enable, which grants user or guest read permissions to the PCYCLE register aliases in the user control register file.")
DEF_REG_FIELD(SSR_PE, "pe",24,1,"PMU Enable bit that grants guest read permissions to the PMU register aliases in the user control register file.")
DEF_REG_FIELD(SSR_BP, "bp",25,1,"Internal Bus Priority bit. Memory requests generated by threads with BP=1 are given priority over requests generated by threads with BP=0.")
//DEF_REG_FIELD(SSR_TW, "tw",26,1,"Deprecated")	/* Table Walk */
//DEF_REG_FIELD(SSR_ES, "es",26,1,"Deprecated")	/* EVB Select */
DEF_REG_FIELD(SSR_XA, "xa",27,3,"Three read-write bits for Extension Active, which control operation of an attached coprocessor")	/* eXtension Active, if we remove XE we could call this XE */
DEF_REG_FIELD(SSR_SS, "ss",30,1,"read-write bit for Single Step, which enables single-step exceptions.")
DEF_REG_FIELD(SSR_XE, "xe",31,1,"read-write bit for Coprocessor Enable, which enables use of an attached coprocessor.")	/* eXtension Enabled, I would prefer to eliminate and make XA=0 no extension, saves a bit */

DEF_REG_FIELD(CCR_L1ICP,"l1icp",0,2,"")
DEF_REG_FIELD(CCR_L1DCP,"l1dcp",3,2,"")
DEF_REG_FIELD(CCR_L2CP,"l2cp",6,2,"")

DEF_REG_FIELD(CCR_HFI,"hfi",16,1,"If set (1), honor the USR[HFI] settings, otherwise disable hardware prefetching into I$.")
DEF_REG_FIELD(CCR_HFD,"hfd",17,1,"If set (1), honor the USR[HFD] settings, otherwise disable hardware prefetching into D$.")
DEF_REG_FIELD(CCR_HFIL2,"hfil2",18,1,"This feature is deprecated. These bits are reserved and should not be set.")
DEF_REG_FIELD(CCR_HFDL2,"hfdl2",19,1,"This bit is reserved. For compatibility with earlier versions, it is a read-write bit, but should always be written with zero to ensure forward compatibility.")
DEF_REG_FIELD(CCR_SFD,"sfd",20,1,"If clear (0), the dcfetch and l2fetch instructions are treated as a NOPs. If set (1), dcfetch and l2fetch attempt to prefetch data based on the cacheability (CCCC) and partition (L1DCP, L2CP, L1DP, L2PART) settings")

DEF_REG_FIELD(CCR_GIE,"gie",24,1,"When set, enables interrupts in guest mode.")
DEF_REG_FIELD(CCR_GTE,"gte",25,1,"When set, enables trap0 in guest mode.")
DEF_REG_FIELD(CCR_GEE,"gee",26,1,"When set, enables error (?) in guest mode.")
DEF_REG_FIELD(CCR_GRE,"gre",27,1,"When set, enables return and get/set interrupt in guest mode.")
DEF_REG_FIELD(CCR_VV1,"vv1",29,1,"Virtualize VIC 1")
DEF_REG_FIELD(CCR_VV2,"vv2",30,1,"Virtualize VIC 2")
DEF_REG_FIELD(CCR_VV3,"vv3",31,1,"Virtualize VIC 3")

DEF_REG_FIELD(ELR_WR,"elr_wr",2,30,"The Exception Link Register is a 30-bit read-write register. The two least significant bits are hard-wired to zero. This register is set to a PC value when an exception or interrupt occurs. For external interrupts, the PC value in ELR is guaranteed to be consistent with the register state; i.e., the PC points to the next packet to process. If an exception occurs, ELR is set to the PC of the packet that caused the exception for all exception types except TRAP. For TRAP exceptions, ELR is set to the next packet. Imprecise exceptions will set ELR to an indeterminate value.")

DEF_REG_FIELD(IMASK_MASK,"mask",0,16,"IMASK is an 8-bit read-write register used to hold a per-thread interrupt mask.")
DEF_REG_FIELD(GP_WR,"gp_wr",6,26,"")

/*  Added for mutability field completeness; remove if we add fields  */
DEF_REG_FIELD(PC_PC,"pc",0,32,"Program counter")  
DEF_REG_FIELD(BADVA_BADVA,"badva",0,32,"Two 32-bit read-write registers to hold bad virtual address information. BADVA0 is used to hold exception addresses generated from slot 0 and the instruction fetch. BADVA1 is used to hold the exception addresses from slot 1.")
DEF_REG_FIELD(REV_REV,"rev",0,32,"Holds the revid for the core.")

/*  Hrm this could get ugly.  Need to revisit XML parser for the register alias/name.  */
DEF_REG_FIELD(C04_P0,"p0",0,8,"")
DEF_REG_FIELD(C04_P1,"p1",8,8,"")
DEF_REG_FIELD(C04_P2,"p2",16,8,"")
DEF_REG_FIELD(C04_P3,"p3",24,8,"")

/* MREG fields */
DEF_REG_FIELD(M0_I_HI,"I_HI",28,4,"")
DEF_REG_FIELD(M0_I_LO,"I_LO",17,7,"")
DEF_REG_FIELD(M0_K,"K",24,4,"")
DEF_REG_FIELD(M1_I_HI,"I_HI",28,4,"")
DEF_REG_FIELD(M1_I_LO,"I_LO",17,7,"")
DEF_REG_FIELD(M1_K,"K",24,4,"")



/* USR fields */
DEF_REG_FIELD(USR_OVF,"ovf",0,1,"Sticky Saturation Overflow - Set when saturation occurs while executing instruction that specifies optional saturation, remains set until explicitly cleared by a USR=Rs instruction.")
DEF_REG_FIELD(USR_FPINVF,"fpinvf",1,1,"Floating-point IEEE Invalid Sticky Flag.")
DEF_REG_FIELD(USR_FPDBZF,"fpdbzf",2,1,"Floating-point IEEE Divide-By-Zero Sticky Flag.")
DEF_REG_FIELD(USR_FPOVFF,"fpovff",3,1,"Floating-point IEEE Overflow Sticky Flag.")
DEF_REG_FIELD(USR_FPUNFF,"fpunff",4,1,"Floating-point IEEE Underflow Sticky Flag.")
DEF_REG_FIELD(USR_FPINPF,"fpinpf",5,1,"Floating-point IEEE Inexact Sticky Flag.")

DEF_REG_FIELD(USR_LPCFG,"lpcfg",8,2,"Hardware Loop Configuration: Number of loop iterations (0-3) remaining before pipeline predicate should be set.")
DEF_REG_FIELD(USR_PKTCNT_U,"pktcnt_u",10,1,"Enable packet counting in User mode.")
DEF_REG_FIELD(USR_PKTCNT_G,"pktcnt_g",11,1,"Enable packet counting in Guest mode.")
DEF_REG_FIELD(USR_PKTCNT_M,"pktcnt_m",12,1,"Enable packet counting in Monitor mode.")
DEF_REG_FIELD(USR_HFD,"hfd",13,2,"Two bits that let the user control the amount of L1 hardware data cache prefetching (up to 4 cache lines): 00: No prefetching, 01: Prefetch Loads with post-updating address mode when execution is within a hardware loop, 10: Prefetch any hardware-detected striding Load when execution is within a hardware loop, 11: Prefetch any hardware-detected striding Load.")
DEF_REG_FIELD(USR_HFI,"hfi",15,2,"Two bits that let the user control the amount of L1 instruction cache prefetching. 00: No prefetching, 01: Allow prefetching of at most 1 additional cache line, 10: Allow prefetching of at most 2 additional cache lines.")
DEF_REG_FIELD(USR_HFIL2,"hfil2",18,2,"This feature is deprecated. These bits should are reserved and should not be set.")

DEF_REG_FIELD(USR_FPRND, "fprnd",22,2,"Rounding Mode for Floating-Point Instructions: 00: Round to nearest, ties to even (default), 01: Toward zero, 10: Downward (toward negative infinity), 11: Upward (toward positive infinity).")

DEF_REG_FIELD(USR_FPINVE,"fpinve",25,1,"Enable trap on IEEE Invalid.")
DEF_REG_FIELD(USR_FPDBZE,"fpdbze",26,1,"Enable trap on IEEE Divide-By-Zero.")
DEF_REG_FIELD(USR_FPOVFE,"fpovfe",27,1,"Enable trap on IEEE Overflow.")
DEF_REG_FIELD(USR_FPUNFE,"fpunfe",28,1,"Enable trap on IEEE Underflow.")
DEF_REG_FIELD(USR_FPINPE,"fpinpe",29,1,"Enable trap on IEEE Inexact.")
DEF_REG_FIELD(USR_PFA,"pfa",31,1,"L2 Prefetch Active: Set when non-blocking l2fetch instruction is prefetching requested data, remains set until l2fetch prefetch operation is completed (or not active).")		/* read-only */


/* Guest Fields */

DEF_REG_FIELD(GSR_CAUSE,"cause",0,16,"Guest mode event cause.")
DEF_REG_FIELD(GSR_SS,"ss",29,1,"Guest mode single step bit.")
DEF_REG_FIELD(GSR_IE,"ie",30,1,"Guest mode interrrupt enable.")
DEF_REG_FIELD(GSR_UM,"um",31,1,"Guest mode user mode(?)")

/* STID fields */
DEF_REG_FIELD(STID_STID,"stid",0,8,"This 8-bit read-write field holds the software thread identifier (STID). It is used by the hardware debugger (ISDB) to match breakpoints. The performance monitor logic can also use it as a counting match criteria.")
DEF_REG_FIELD(STID_PRIO,"prio",16,8,"This 8-bit read-write field holds the priority of a thread with lower numbers indicating higher priority, zero being the highest priority possible. The hardware will ensure that threads running in Monitor mode are not given a low priority.")

/* SYSCFG fields */
DEF_REG_FIELD(SYSCFG_MMUEN,"MMUEN",0,1,"read-write bit that enables the MMU.")
DEF_REG_FIELD(SYSCFG_ICEN,"ICEN",1,1,"read-write bit that enables the instruction cache. The I-bit and M-bit work together to control fetch behavior")
DEF_REG_FIELD(SYSCFG_DCEN,"DCEN",2,1,"read-write bit that enables the data cache. The D-bit and M-bit work together to control load/store behavior.")
DEF_REG_FIELD(SYSCFG_ISDBTRUSTED,"ISDBTRUSTED",3,1,"read-write bit that controls ISDB TRUSTED behavior.")
DEF_REG_FIELD(SYSCFG_GIE,"GIE",4,1,"read-write global interrupt enable bit. When clear (0), all interrupts to all threads are masked. The interrupts can be received and accumulated in the IPEND registers, but they are not delivered to any thread until the G-bit is set (1).")
DEF_REG_FIELD(SYSCFG_ISDBREADY,"ISDBCOREREADY",5,1,"read-write bit that controls ISDB_CORE_READY.")
DEF_REG_FIELD(SYSCFG_PCYCLEEN,"PCYCLEEN",6,1,"read-write bit that controls the operation of the 64-bit free-running PCYCLE counter.")
DEF_REG_FIELD(SYSCFG_V2X,"V2X",7,1,"read-write bit reserved for use by an optional coprocessor.")
DEF_REG_FIELD(SYSCFG_IGNOREDABORT,"IDA",8,1,"read-write bit that causes data aborts to be ignored when set.")
DEF_REG_FIELD(SYSCFG_PM,"PM",9,1,"Enables the Performance Monitor Unit (PMU).")
#if 0
DEF_REG_FIELD(SYSCFG_K2LOCK,"K2",10,1,"")
#endif
DEF_REG_FIELD(SYSCFG_TLBLOCK,"TL",11,1,"Control the operation of the hardware TLB lock.")
DEF_REG_FIELD(SYSCFG_K0LOCK,"KL",12,1,"Control the operation of the hardware kernel lock.")
DEF_REG_FIELD(SYSCFG_BQ,"BQ",13,1,"Controls the bus Quality-of-Service: 0: Bus resources are per-thread for highest Quality-of-Service, 1: Bus resources are shared for highest performance. State changes of BQ must only be attempted when the processor is in single thread mode. Any state change must be immediately followed and preceded by a SynchT.")
DEF_REG_FIELD(SYSCFG_PRIO,"PRIO",14,1,"Controls the Hardware Priority Scheduling feature. 0: Disabled, 1: When DMT enabled, implementations can allocate more processing bandwidth to threads with higher priority. The priority is indicated in the PRIO field of STID register.")
DEF_REG_FIELD(SYSCFG_DMT,"DMT",15,1,"Controls Multi-Thread Scheduling. 0: Use strict Interleaved Multi-threading scheduling (IMT mode). 1: Allow threads to dynamically utilize idle resources from other threads (DMT mode).")
DEF_REG_FIELD(SYSCFG_L2CFG,"L2CFG",16,3,"read-write bits that configure L2 cache TCM/CACHE partition.")
DEF_REG_FIELD(SYSCFG_ITCM,"ITCM",19,1,"read-write bit that enables the Instruction TCM.")
DEF_REG_FIELD(SYSCFG_CLADEN,"CLADEN",20,1,"CLADE Cache Compression Enable.")
DEF_REG_FIELD(SYSCFG_L2NWA,"L2NWA",21,1,"When set, L2 is configured as no-write-allocate.")
DEF_REG_FIELD(SYSCFG_L2NRA,"L2NRA",22,1,"When set, L2 is configured as no-read-allocate.")
DEF_REG_FIELD(SYSCFG_L2WB,"L2WB",23,1,"When set, L2 is configured as Write-back.")
DEF_REG_FIELD(SYSCFG_L2P,"L2P",24,1,"read-write bit that enables L2 memory parity protection.")
#if 0
DEF_REG_FIELD(SYSCFG_AUTOTLBLOCKEN,"TE",10,1,"")
#endif
DEF_REG_FIELD(SYSCFG_SLVCTL0,"SLVCTL0",25,2,"Slave 0 Control - Sets the behavior of the slave to accesses by external devices. 00: TCM only. Any other access is an error. Reset value. 01: TCM and locked L2 cache lines. Any other access is an error. 10: Re-mastering, TCM, and locked L2 cache lines. 11: Disabled. Any access is an error.")
DEF_REG_FIELD(SYSCFG_SLVCTL1,"SLVCTL1",27,2,"Slave 0 Control - Sets the behavior of the slave to accesses by external devices. 00: TCM only. Any other access is an error. Reset value. 01: TCM and locked L2 cache lines. Any other access is an error. 10: Re-mastering, TCM, and locked L2 cache lines. 11: Disabled. Any access is an error.")

DEF_REG_FIELD(SYSCFG_L2PARTSIZE,"L2PART",29,2,"read-write bits that control partitioning for the L2 cache.")
DEF_REG_FIELD(SYSCFG_L2GCA,"L2GCA",31,1,"Read-only status bit, when set, it indicates that an L2 Global Cacheop (l2gclean, l2gcleaninv) is active.")

/* VIC Fields */
DEF_REG_FIELD(VID_VID0,"VID0",0,10,"Vector ID register field corresponding to the default L2 Vector Interrupt Controller VIC0 which attaches the lowest priority L1 interrupt. It can be read via a CR transfer. After writing, isync must be used.")
DEF_REG_FIELD(VID_VID1,"VID1",16,10,"Vector ID register field corresponding to the L2 Vector Interrupt Controller VIC1.")
DEF_REG_FIELD(VID1_VID2,"VID2",0,10,"Vector ID register field corresponding to the L2 Vector Interrupt Controller VIC2.")
DEF_REG_FIELD(VID1_VID3,"VID3",16,10,"Vector ID register field corresponding to the L2 Vector Interrupt Controller VIC3.")

/* IPENDAD Fields */
DEF_REG_FIELD(IPENDAD_IPEND,"IPEND",0,16,"The Interrupt Pending field (IPEND) is an 8-bit field containing bits that indicate which interrupts are pending. Interrupts are prioritized from interrupt 0 (highest priority) to interrupt 7 (lowest priority).")
DEF_REG_FIELD(IPENDAD_IAD,"IAD",16,16,"The Interrupt Auto Disable field (IAD) is an 8-bit field that provides a global interrupt mask. When an interrupt is delivered to a thread, the corresponding bit in this field is set, which then disables that interrupt. When the software is ready to accept the interrupt again, the CIAD instruction is used to clear the appropriate bits in the IPENDAD.IAD field.")

/* MODECTL fields */
DEF_REG_FIELD(MODECTL_E,"Enabled",0,8,"The MODECTL register reflects the current processing mode of all threads. E bits when set mean that the corresponding thread is on.")
DEF_REG_FIELD(MODECTL_W,"Wait",16,8,"W bit, when set means the thread, if on, is in wait mode.")

/* PTE fields */
DEF_REG_FIELD(PTE_PPD,"PPD",0,24,"Physical page number that the corresponding virtual Page maps to. The PA field maps the lower 35-bit space. This is a appended to the EP bit to map the full 36-bit (64GB) address space.")
DEF_REG_FIELD(PTE_C,"C",24,4,"Cacheability attributes for the page.")
DEF_REG_FIELD(PTE_U,"U",28,1,"User mode permitted - if set (1), User mode is allowed to access this page per the R/W/X bits. If cleared (0) a User mode access results in a permissions violation.")
DEF_REG_FIELD(PTE_R,"R",29,1,"Read-enable - set if User mode and Guest mode programs are allowed to read this page.")
DEF_REG_FIELD(PTE_W,"W",30,1,"Write-enable - set if User mode and Guest mode programs are allowed to write this page.")
DEF_REG_FIELD(PTE_X,"X",31,1,"Execute-enable - set if User mode and Guest mode programs are allowed to execute from this page.")
DEF_REG_FIELD(PTE_VPN,"VPN",32,20,"Virtual page number that is matched against the load or store address.")
DEF_REG_FIELD(PTE_ASID,"ASID",52,7,"7-bit address space identifier (tag extender)")
DEF_REG_FIELD(PTE_ATR0,"ATR0",59,1,"General purpose attribute bit kept as an attribute of each cache line, can be connected to the bus interface as needed by the system. The behavior is system-dependent.")
DEF_REG_FIELD(PTE_ATR1,"ATR1",60,1,"General purpose attribute bit kept as an attribute of each cache line, can be connected to the bus interface as needed by the system. The behavior is system-dependent.")
DEF_REG_FIELD(PTE_PA35,"PA35",61,1,"The Extra Physical bit is the most-significant physical address bit.")
DEF_REG_FIELD(PTE_G,"G",62,1,"Global bit. If the Global bit is set, then the ASID is ignored in the match.")
DEF_REG_FIELD(PTE_V,"V",63,1,"Valid bit. indicates whether this entry should be used for matching or not. This bit is cleared on reset for all TLB entries.")

DEF_REG_FIELD(EVB_WR,"evb_wr",8,24,"The Event Vector Base (EVB) register is a 24-bit register that contains the vector table base address. When an exception or interrupt occurs, control is re-directed to an address relative to the EVB.")
//DEF_REG_FIELD(EVB1_WR,"evb1_wr",8,24,"")

DEF_REG_FIELD(BESTWAIT_PRIO,"PRIO",0,9,"")

DEF_REG_FIELD(SCHEDCFG_INTNO,"INTNO",0,4,"")
DEF_REG_FIELD(SCHEDCFG_ENABLED,"EN",8,1,"The BESTWAIT register is programmed by the RTOS to hold the priority of the highest priority task that is waiting to run on a hardware thread. If the effective priority of any hardware thread is worse than the BESTWAIT register value, the hardware triggers the reschedule interrupt and resets the BESTWAIT register to 0x1FF.")

#if 0
DEF_REG_FIELD(TLBHI_VPN,"VPN",0,20,"")
DEF_REG_FIELD(TLBHI_ASID,"ASID",20,6,"")
DEF_REG_FIELD(TLBHI_G,"G",28,1,"")
DEF_REG_FIELD(TLBHI_V,"V",29,1,"")
//DEF_REG_FIELD(TLBHI_T,"ASID",0,20,"")
//DEF_REG_FIELD(TLBHI_D,"D",31,1,"")

DEF_REG_FIELD(TLBLO_PPN,"PPN",0,20,"")
DEF_REG_FIELD(TLBLO_MASK,"MASK",20,3,"")
DEF_REG_FIELD(TLBLO_C,"C",26,3,"")
DEF_REG_FIELD(TLBLO_R,"R",29,1,"")
DEF_REG_FIELD(TLBLO_W,"W",30,1,"")
DEF_REG_FIELD(TLBLO_X,"X",31,1,"")

DEF_REG_FIELD(TLBIDX_INDEX,"INDEX",0,5,"")
DEF_REG_FIELD(TLBIDX_H,"H",31,0,"")
#endif


/* ISDB ST fields */
DEF_REG_FIELD(ISDBST_WAITRUN,"WAITRUN",24,8,"These bits indicate which threads are in wait vs. run mode. They reflect the W bit field of the core MODECTL register. Bit 24 is used for TNUM0, bit 25 for TNUM1, etc.")
DEF_REG_FIELD(ISDBST_ONOFF,"ONOFF",16,8,"These bits indicate which threads are in Off mode. They reflect the E bit field of the core MODECTL register. Bit 16 is used for TNUM0, bit 17 for TNUM1, etc. A thread that is off cannot be debugged, e.g., if ISDB commands are sent to a thread that is off then the results are undefined.")
DEF_REG_FIELD(ISDBST_DEBUGMODE,"DEBUGMODE",8,8,"These bits indicate which threads are in Debug mode. Bit 8 is used for thread0, bit 9 for thread1, etc. If these bits indicate a thread is in Debug mode, then the wait/run mode bit (above) indicates the mode before entering Debug mode.")
DEF_REG_FIELD(ISDBST_STUFFSTATUS,"STUFFSTATUS",5,1,"0: Stuff instruction was successful, 1: Stuff instruction caused an exception.") 
DEF_REG_FIELD(ISDBST_CMDSTATUS,"CMDSTATUS",4,1,"0: ISDB command status was successful, 1: ISDB command failed. It could be from ISDB_TRUSTED settings or because the thread experienced a TLB miss and could not proceed because another thread was holding the TLB lock.")
DEF_REG_FIELD(ISDBST_PROCMODE,"PROCMODE",3,1,"")
DEF_REG_FIELD(ISDBST_MBXINSTATUS,"MBXINSTATUS",2,1,"ISDB mailbox in (ISDB --> core) status. This bit is cleared (0) when the core reads the mailbox in register meaning empty, and set (1) when the written by APB, meaning full.")
DEF_REG_FIELD(ISDBST_MBXOUTSTATUS,"MBXOUTSTATUS",1,1,"ISDB mailbox out (core --> ISDB) status. This bit is set (1) when written by the core meaning full and cleared (0) when read by APB, meaning empty.")
DEF_REG_FIELD(ISDBST_READY,"READY",0,1,"0: ISDB is busy with a command, 1: ISDB ready to accept a new command.")

/* ISDB config fields */
DEF_REG_FIELD(ISDBCFG0_LINKETM_BKPT1,"LINK_ETM_HWBRKPT1",28,1,"Deprecated: should not be set.")
DEF_REG_FIELD(ISDBCFG0_LINKETM_BKPT0,"LINK_ETM_HWBRKPT0",27,1,"Deperecated: should not be set.")
DEF_REG_FIELD(ISDBCFG0_BKPT1EN,"HWBRKPT1ENABLE",26,1,"When set, enables hardware breakpoint 1.")
DEF_REG_FIELD(ISDBCFG0_BKPT0EN,"HWBRKPT0ENABLE",25,1,"When set, enables hardware breakpoint 0.")
DEF_REG_FIELD(ISDBCFG0_DBGGID,"DBGINTDIS",24,1,"Global interrupt disable when any thread in Debug mode. 0: Interrupts are disabled for threads in Debug mode, enabled for other threads, 1: Interrupts are disabled for all threads when any thread is in Debug mode.")
DEF_REG_FIELD(ISDBCFG0_EXTRESMASK,"EXTRESMASK",16,8,"This 4-bit field indicates which threads are to resume upon external resume signal. The least-significant bit is for TNUM0, the next bit for TNUM1, and so on. Upon an external resume signal, for threads that have the mask bit set, if that thread is in Debug mode, then it resumes its previous mode, otherwise there is no effect.")
DEF_REG_FIELD(ISDBCFG0_EXTBRKMASK,"EXTBRKMASK",8,8,"This 4-bit field indicates which threads are to break upon an external breakpoint request. The least-significant bit is for TNUM0, the next bit for TNUM1, and so on. Upon an external breakpoint signal, for threads that have the mask bit set, if that thread is in not in Debug mode, then it enters Debug mode, otherwise there is no effect.")
DEF_REG_FIELD(ISDBCFG0_ETMBRKMASK,"ETMBRKMASK",0,8,"This field is reserved for use by ETM.")
DEF_REG_FIELD(ISDBCFG1_BRK1MASK,"BRK1MASK",24,8,"Break1 TNUM mask. Upon hitting hardware breakpoint 1, the thread that hit the breakpoint enters Debug mode. Also, the threads defined in this mask also enter Debug mode.")
DEF_REG_FIELD(ISDBCFG1_BRK0MASK,"BRK0MASK",16,8,"Break0 TNUM mask. Upon hitting the hardware breakpoint 0, the thread that hit the breakpoint enters Debug mode. Also, the threads defined in this mask also enter Debug mode.")
DEF_REG_FIELD(ISDBCFG1_SWBRKMASK,"SWBRKMASK",8,8,"SWBRKPT TNUM mask. This 4-bit field indicates which additional threads are to break upon a brkpt instruction execution. The least-significant bit is for TNUM0, the next bit for TNUM1, and so on. Upon brkpt instruction execution, the thread that executed brkpt enters Debug mode. Also, the threads that have a bit set (1) in this mask enter Debug mode.")
DEF_REG_FIELD(ISDBCFG1_BRKEVMASK,"BRKEVMASK",0,8,"BREAK EVENT TNUM mask. There is a interrupt signal BREAK_EVENT that goes from ISDB to the MSM. Whenever a TNUM indicated in this mask goes into Debug mode, the BREAK_EVENT interrupt is raised. Bit 0 is for TNUM0, bit 1 for TNUM1, etc.")

/* ISDB BRKPTINFO */
DEF_REG_FIELD(BRKPTINFO_CAUSETH,"CAUSETH",24,6,"Reserved")
DEF_REG_FIELD(BRKPTINFO_TH5SRC,"TH5SRC",15,3,"If thread 5 is in debug mode, these bits indicate what caused the transition to Debug mode; undefined otherwise. 000=Hardware breakpoint 0, 001=Hardware breakpoint 1, 010=brkpt instruction, 011=ETM breakpoint, 100=APB breakpoint, 101=External breakpoint, 110=Reserved, 111=Reserved.")
DEF_REG_FIELD(BRKPTINFO_TH4SRC,"TH4SRC",12,3,"If thread 4 is in debug mode, these bits indicate what caused the transition to Debug mode; undefined otherwise. 000=Hardware breakpoint 0, 001=Hardware breakpoint 1, 010=brkpt instruction, 011=ETM breakpoint, 100=APB breakpoint, 101=External breakpoint, 110=Reserved, 111=Reserved.")
DEF_REG_FIELD(BRKPTINFO_TH3SRC,"TH3SRC",9,3,"If thread 3 is in debug mode, these bits indicate what caused the transition to Debug mode; undefined otherwise. 000=Hardware breakpoint 0, 001=Hardware breakpoint 1, 010=brkpt instruction, 011=ETM breakpoint, 100=APB breakpoint, 101=External breakpoint, 110=Reserved, 111=Reserved.")
DEF_REG_FIELD(BRKPTINFO_TH2SRC,"TH2SRC",6,3,"If thread 2 is in debug mode, these bits indicate what caused the transition to Debug mode; undefined otherwise. 000=Hardware breakpoint 0, 001=Hardware breakpoint 1, 010=brkpt instruction, 011=ETM breakpoint, 100=APB breakpoint, 101=External breakpoint, 110=Reserved, 111=Reserved.")
DEF_REG_FIELD(BRKPTINFO_TH1SRC,"TH1SRC",3,3,"If thread 1 is in debug mode, these bits indicate what caused the transition to Debug mode; undefined otherwise. 000=Hardware breakpoint 0, 001=Hardware breakpoint 1, 010=brkpt instruction, 011=ETM breakpoint, 100=APB breakpoint, 101=External breakpoint, 110=Reserved, 111=Reserved.")
DEF_REG_FIELD(BRKPTINFO_TH0SRC,"TH0SRC",0,3,"If thread 0 is in debug mode, these bits indicate what caused the transition to Debug mode; undefined otherwise. 000=Hardware breakpoint 0, 001=Hardware breakpoint 1, 010=brkpt instruction, 011=ETM breakpoint, 100=APB breakpoint, 101=External breakpoint, 110=Reserved, 111=Reserved.")

/* ISDB BRKPTCFG */
DEF_REG_FIELD(BRKPTCFG0_TID,"TID",18,8,"An 8-bit value that is optionally matched against the per-thread TID register bits 7:0")
DEF_REG_FIELD(BRKPTCFG0_USEPC,"USEPC",17,1,"PC match - when set (1), use BRKPTPC0 to match breakpoint 0, otherwise do not.")
DEF_REG_FIELD(BRKPTCFG0_USEASID,"USEASID",16,1,"ASID match enabled - when set (1), use ASID to match breakpoint 0, otherwise do not use ASID.")
DEF_REG_FIELD(BRKPTCFG0_USETID,"USETID",15,1,"TID match enabled - when set (1), use TID to match breakpoint 0, otherwise do not use TID.")
DEF_REG_FIELD(BRKPTCFG0_PAEXT,"PAEXT",8,4,"PA extenders. Additional 4 bits for matching 36-bit physical addresses.")
DEF_REG_FIELD(BRKPTCFG0_ASID,"ASID",1,7,"A 7-bit ASID value optionally used in the breakpoint match. The value in this field is compared against the ASID value in the per-thread monitor status register.")
DEF_REG_FIELD(BRKPTCFG0_VP,"VP",0,1,"When set (1), BRKPT0 holds a physical address, virtual otherwise.")

DEF_REG_FIELD(BRKPTCFG1_TID,"TID",18,8,"An 8-bit value that is optionally matched against the per-thread TID register bits 7:0")
DEF_REG_FIELD(BRKPTCFG1_USEPC,"USEPC",17,1,"PC match - when set (1), use BRKPTPC0 to match breakpoint 0, otherwise do not.")
DEF_REG_FIELD(BRKPTCFG1_USEASID,"USEASID",16,1,"ASID match enabled - when set (1), use ASID to match breakpoint 0, otherwise do not use ASID.")
DEF_REG_FIELD(BRKPTCFG1_USETID,"USETID",15,1,"TID match enabled - when set (1), use TID to match breakpoint 0, otherwise do not use TID.")
DEF_REG_FIELD(BRKPTCFG1_PAEXT,"PAEXT",8,4,"PA extenders. Additional 4 bits for matching 36-bit physical addresses.")
DEF_REG_FIELD(BRKPTCFG1_ASID,"ASID",1,7,"A 7-bit ASID value optionally used in the breakpoint match. The value in this field is compared against the ASID value in the per-thread monitor status register.")
DEF_REG_FIELD(BRKPTCFG1_VP,"VP",0,1,"When set (1), BRKPT0 holds a physical address, virtual otherwise.")

/* ISDB BRKPTPC0 */
DEF_REG_FIELD(BRKPTPC0_BRKPTPC,"BRKPTPC",2,30,"The value programmed in this register is used to compare against a thread's PC register.")
DEF_REG_FIELD(BRKPTPC0_RES,"RES",0,2,"Reserved")

/* ISDB BRKPTPC1 */
DEF_REG_FIELD(BRKPTPC1_BRKPTPC,"BRKPTPC",2,30,"The value programmed in this register is used to compare against a thread's PC register.")
DEF_REG_FIELD(BRKPTPC1_RES,"RES",0,2,"Reserved")



/* ISDB CMD */

DEF_REG_FIELD(ISDBCMD_TMASK,"TMASK",8,6,"TNUM Mask to indicate which thread the command corresponds to. (Bit 8 for thread0, bit 9 for thread1, etc.)")
DEF_REG_FIELD(ISDBCMD_PRIV,"PRIV",6,2,"Stuff instruction privilege level. 00=User mode, 01=Guest mode, 10=Monitor mode.")
DEF_REG_FIELD(ISDBCMD_CMD,"CMD",0,3,"Specifies ISDB command. 000=NOP, 001=Break, 010=Resume, 011=Istep, 100=Stuff, 101=Reset_Assert, 110=Interrupt, 111=Reserved")

/* ISDB EN */

DEF_REG_FIELD(ISDBEN_PREVPOW,"PREVPOW",4,1,"The host debugger uses this bit to tell the core not to power down because a debug session is active or ISDB registers are being programmed.")
DEF_REG_FIELD(ISDBEN_TRUSTED,"TRUSTED",3,1,"This READONLY bit reflects the value of the core SYSCFG ISDB_TRUSTED bit.")
DEF_REG_FIELD(ISDBEN_SECUREEN,"SECUREEN",2,1,"When set to 1, indicates that ISDB debugging is supported through APB interface.")
DEF_REG_FIELD(ISDBEN_CLKOFF,"CLKOFF",1,1,"The ISDBEN register can always be read/written regardless of this bit. For other ISDB registers, the behavior of this bit is: 0=ISDB clock is ON and all ISDB registers can be accessed normally, 1=ISDB clock is OFF and ISDB register read-writes produce undefined behavior.")
DEF_REG_FIELD(ISDBEN_JTAGEN,"JTAGEN",0,1,"Enable ISDB when set to 1.")


/* PMU CONFIG */
DEF_REG_FIELD(PMUCFG_MODE,"MODE",16,3,"Thread mode mask: 0=No qualifications, 1,2,3,4=Counters count only if as many threads are active and others are in WAIT/STOP, 5=Counters count only if 2 threads are active and on same cluster, 6=Counters count only if 2 threads are active and on different clusters.")


DEF_REG_FIELD(PMUCFG_MSBCNT7,"MSBCNT7",14,2,"Counter 7 event MSB.")
DEF_REG_FIELD(PMUCFG_MSBCNT6,"MSBCNT6",12,2,"Counter 6 event MSB.")
DEF_REG_FIELD(PMUCFG_MSBCNT5,"MSBCNT5",10,2,"Counter 5 event MSB.")
DEF_REG_FIELD(PMUCFG_MSBCNT4,"MSBCNT4",8,2,"Counter 4 event MSB.")
DEF_REG_FIELD(PMUCFG_MSBCNT3,"MSBCNT3",6,2,"Counter 3 event MSB.")
DEF_REG_FIELD(PMUCFG_MSBCNT2,"MSBCNT2",4,2,"Counter 2 event MSB.")
DEF_REG_FIELD(PMUCFG_MSBCNT1,"MSBCNT1",2,2,"Counter 1 event MSB.")
DEF_REG_FIELD(PMUCFG_MSBCNT0,"MSBCNT0",0,2,"Counter 0 event MSB. If this bit is clear, the counter will count legacy event number chosen by the corresponding PMUEVTCFG0/1 field. If the bit is set, then PMUEVTCFG0/1 field points to a extended event.")


DEF_REG_FIELD(GEVB_WR,"gevb_wr",8,24,"The upper 24 bits of Guest Event Vector Base (GEVB) register contains the vector table base address for events taken in Monitor mode. The lower 8 bits are hard-wired to zero making it 256-byte aligned.")


DEF_REG_MUTABILITY(REG_PC,0x00000000)
DEF_REG_MUTABILITY(REG_ELR,0xfffffffc)
DEF_REG_MUTABILITY(REG_SSR,0xfbff7fff)
DEF_REG_MUTABILITY(REG_CCR,0xef1f00db)
DEF_REG_MUTABILITY(REG_GEVB,0xffffff00)
DEF_REG_MUTABILITY(REG_BADVA,0xffffffff)
DEF_REG_MUTABILITY(REG_TID,0x00ff00ff)
DEF_REG_MUTABILITY(REG_TNUM,0x00000000)
DEF_REG_MUTABILITY(REG_USR,0x3ecfff3f)
DEF_REG_MUTABILITY(REG_GP, 0xFFFFFFC0)
DEF_REG_MUTABILITY(REG_UPCYCLE_LO, 0x0)
DEF_REG_MUTABILITY(REG_UPCYCLE_HI, 0x0)
DEF_REG_MUTABILITY(REG_UTIMERLO, 0x0)
DEF_REG_MUTABILITY(REG_UTIMERHI, 0x0)
DEF_GLOBAL_REG_MUTABILITY(REG_REV,0x00000000)
#ifdef NEW_INTERRUPTS
DEF_GLOBAL_REG_MUTABILITY(REG_IPENDAD,0x00000000)
DEF_REG_MUTABILITY(REG_IMASK,0x0000ffff)
DEF_GLOBAL_REG_MUTABILITY(REG_VID,0x03ff03ff)
DEF_GLOBAL_REG_MUTABILITY(REG_VID1,0x03ff03ff)
#else
DEF_GLOBAL_REG_MUTABILITY(REG_IPEND,0x00000000)
DEF_REG_MUTABILITY(REG_IMASK,0xffffffff)
DEF_GLOBAL_REG_MUTABILITY(REG_IAD,0x00000000)
DEF_GLOBAL_REG_MUTABILITY(REG_IAHL,0xffffffff)
DEF_GLOBAL_REG_MUTABILITY(REG_IEL,0xffffffff)
DEF_GLOBAL_REG_MUTABILITY(REG_VID,0x03ff03ff)
#endif
DEF_GLOBAL_REG_MUTABILITY(REG_PCYCLEHI,0xffffffff)
DEF_GLOBAL_REG_MUTABILITY(REG_PCYCLELO,0xffffffff)
DEF_GLOBAL_REG_MUTABILITY(REG_EVB,0xffffff00)
//DEF_GLOBAL_REG_MUTABILITY(REG_EVB1,0xffffff00)
#if 0
DEF_GLOBAL_REG_MUTABILITY(REG_TLBLO,0xfd7fffff)
DEF_GLOBAL_REG_MUTABILITY(REG_TLBHI,0x33ffffff)
DEF_GLOBAL_REG_MUTABILITY(REG_TLBIDX,0x8000003f)
#endif
DEF_GLOBAL_REG_MUTABILITY(REG_BESTWAIT,0x000001ff)
DEF_GLOBAL_REG_MUTABILITY(REG_SCHEDCFG,0x0000010f)
DEF_GLOBAL_REG_MUTABILITY(REG_MODECTL,0x00000000)
DEF_GLOBAL_REG_MUTABILITY(REG_SYSCONF,0x7fffe3ff) /* EJP: KL,TL not modifiable directly. v60: no autolock */
DEF_GLOBAL_REG_MUTABILITY(REG_ISDBST,0x00000000)
DEF_GLOBAL_REG_MUTABILITY(REG_ISDBMBXIN,0x00000000)
DEF_GLOBAL_REG_MUTABILITY(REG_CFGBASE,0x00000000)
DEF_GLOBAL_REG_MUTABILITY(REG_DIAG,0x000000ff)
DEF_GLOBAL_REG_MUTABILITY(REG_ISDBCFG0,0x1f0F0F0F)
DEF_GLOBAL_REG_MUTABILITY(REG_ISDBCFG1,0x0F0F0F0F)
DEF_GLOBAL_REG_MUTABILITY(REG_LIVELOCK,0xffffffff)
DEF_GLOBAL_REG_MUTABILITY(REG_BRKPTPC0,0xfffffffc)
DEF_GLOBAL_REG_MUTABILITY(REG_BRKPTCFG0,0x03ff8fff)
DEF_GLOBAL_REG_MUTABILITY(REG_BRKPTPC1,0xfffffffc)
DEF_GLOBAL_REG_MUTABILITY(REG_BRKPTCFG1,0x03ff8fff)
DEF_GLOBAL_REG_MUTABILITY(REG_ISDBEN,0x00000001)
DEF_GLOBAL_REG_MUTABILITY(REG_ISDBGPR,0xffffffff)

DEF_GLOBAL_REG_MUTABILITY(REG_ISDBCMD,0x00003fC7)
DEF_GLOBAL_REG_MUTABILITY(REG_ISDBVER,0x0)
DEF_GLOBAL_REG_MUTABILITY(REG_BRKPTINFO,0x0)

DEF_GLOBAL_REG_MUTABILITY(REG_TIMERLO,0x0)
DEF_GLOBAL_REG_MUTABILITY(REG_TIMERHI,0x0)

DEF_GLOBAL_REG_MUTABILITY(REG_CHICKEN,0xffffffff)
//DEF_GLOBAL_REG_MUTABILITY(REG_ACC0,0xffffffff)
//DEF_GLOBAL_REG_MUTABILITY(REG_ACC1,0x000fffff)
DEF_GLOBAL_REG_MUTABILITY(REG_RGDR,0xffffffff)

DEF_GLOBAL_REG_MUTABILITY(REG_PMUCFG,0xffffffff)
DEF_GLOBAL_REG_MUTABILITY(REG_RGDR2,0xffffffff)

#define TLB_MUTABILITY 0xffffffffffffffffULL



#ifndef DEF_REG_WAITSAVED
#define DEF_REG_WAITSAVED(...) /* NOTHING */
#define SELF_DEF_REG_WAITSAVED
#endif

#ifndef DEF_GLOBAL_REG_WAITSAVED
#define DEF_GLOBAL_REG_WAITSAVED(...) /* NOTHING */
#define SELF_DEF_GLOBAL_REG_WAITSAVED
#endif

#ifndef DEF_GLOBAL_REG_THREADMASK
#define DEF_GLOBAL_REG_THREADMASK(...) /* NOTHING */
#define SELF_DEF_GLOBAL_REG_THREADMASK
#endif

DEF_REG_WAITSAVED(REG_PC)
DEF_REG_WAITSAVED(REG_SGP)
DEF_REG_WAITSAVED(REG_SGP+1)
DEF_REG_WAITSAVED(REG_SSR)
DEF_REG_WAITSAVED(REG_IMASK)
DEF_REG_WAITSAVED(REG_TID)


DEF_GLOBAL_REG_WAITSAVED(REG_EVB)
DEF_GLOBAL_REG_WAITSAVED(REG_MODECTL)
DEF_GLOBAL_REG_WAITSAVED(REG_SYSCONF)
#ifdef NEW_INTERRUPTS
DEF_GLOBAL_REG_WAITSAVED(REG_IPENDAD)
#else
DEF_GLOBAL_REG_WAITSAVED(REG_IPEND)
DEF_GLOBAL_REG_WAITSAVED(REG_IAD)
DEF_GLOBAL_REG_WAITSAVED(REG_IEL)
DEF_GLOBAL_REG_WAITSAVED(REG_IAHL)
#endif
DEF_GLOBAL_REG_WAITSAVED(REG_SCHEDCFG)
DEF_GLOBAL_REG_WAITSAVED(REG_BESTWAIT)
DEF_GLOBAL_REG_WAITSAVED(REG_PCYCLELO)
DEF_GLOBAL_REG_WAITSAVED(REG_PCYCLEHI)
DEF_GLOBAL_REG_WAITSAVED(REG_ISDBST)
DEF_GLOBAL_REG_WAITSAVED(REG_ISDBCFG0)
DEF_GLOBAL_REG_WAITSAVED(REG_ISDBCFG1)
DEF_GLOBAL_REG_WAITSAVED(REG_BRKPTPC0)
DEF_GLOBAL_REG_WAITSAVED(REG_BRKPTCFG0)
DEF_GLOBAL_REG_WAITSAVED(REG_BRKPTPC1)
DEF_GLOBAL_REG_WAITSAVED(REG_BRKPTCFG1)
DEF_GLOBAL_REG_WAITSAVED(REG_ISDBMBXIN)
DEF_GLOBAL_REG_WAITSAVED(REG_ISDBMBXOUT)
DEF_GLOBAL_REG_WAITSAVED(REG_ISDBEN)
DEF_GLOBAL_REG_WAITSAVED(REG_ISDBGPR)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUCNT0)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUCNT1)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUCNT2)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUCNT3)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUCNT4)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUCNT5)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUCNT6)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUCNT7)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUEVTCFG)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUEVTCFG1)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUCFG)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUSTID0)
DEF_GLOBAL_REG_WAITSAVED(REG_PMUSTID1)
DEF_GLOBAL_REG_WAITSAVED(REG_RGDR)
DEF_GLOBAL_REG_WAITSAVED(REG_RGDR2)
DEF_GLOBAL_REG_WAITSAVED(REG_TURKEY)
DEF_GLOBAL_REG_WAITSAVED(REG_DUCK)
DEF_GLOBAL_REG_WAITSAVED(REG_CHICKEN)

DEF_GLOBAL_REG_WAITSAVED(REG_GCOMMIT_1T)
DEF_GLOBAL_REG_WAITSAVED(REG_GCOMMIT_2T)
DEF_GLOBAL_REG_WAITSAVED(REG_GCOMMIT_3T)
DEF_GLOBAL_REG_WAITSAVED(REG_GCOMMIT_4T)
DEF_GLOBAL_REG_WAITSAVED(REG_GCOMMIT_5T)
DEF_GLOBAL_REG_WAITSAVED(REG_GCOMMIT_6T)

DEF_GLOBAL_REG_WAITSAVED(REG_GCYCLE_1T)
DEF_GLOBAL_REG_WAITSAVED(REG_GCYCLE_2T)
DEF_GLOBAL_REG_WAITSAVED(REG_GCYCLE_3T)
DEF_GLOBAL_REG_WAITSAVED(REG_GCYCLE_4T)
DEF_GLOBAL_REG_WAITSAVED(REG_GCYCLE_5T)
DEF_GLOBAL_REG_WAITSAVED(REG_GCYCLE_6T)

// DEF_GLOBAL_REG_THREADMASK(REG_PMUCFG,PMUCFG_MASK)
DEF_GLOBAL_REG_THREADMASK(REG_ISDBST,ISDBST_WAITRUN)
DEF_GLOBAL_REG_THREADMASK(REG_ISDBST,ISDBST_ONOFF)
DEF_GLOBAL_REG_THREADMASK(REG_ISDBST,ISDBST_DEBUGMODE)
DEF_GLOBAL_REG_THREADMASK(REG_ISDBCFG0,ISDBCFG0_EXTRESMASK)
DEF_GLOBAL_REG_THREADMASK(REG_ISDBCFG0,ISDBCFG0_EXTBRKMASK)
DEF_GLOBAL_REG_THREADMASK(REG_ISDBCFG0,ISDBCFG0_ETMBRKMASK)
DEF_GLOBAL_REG_THREADMASK(REG_ISDBCFG1,ISDBCFG1_BRK1MASK)
DEF_GLOBAL_REG_THREADMASK(REG_ISDBCFG1,ISDBCFG1_BRK0MASK)
DEF_GLOBAL_REG_THREADMASK(REG_ISDBCFG1,ISDBCFG1_SWBRKMASK)
DEF_GLOBAL_REG_THREADMASK(REG_ISDBCFG1,ISDBCFG1_BRKEVMASK)

#ifdef SELF_DEF_REG_WAITSAVED
#undef SELF_DEF_REG_WAITSAVED
#undef DEF_REG_WAITSAVED
#endif


#ifdef SELF_DEF_GLOBAL_REG_WAITSAVED
#undef SELF_DEF_GLOBAL_REG_WAITSAVED
#undef DEF_GLOBAL_REG_WAITSAVED
#endif


#ifdef SELF_DEF_GLOBAL_REG_THREADMASK
#undef SELF_DEF_GLOBAL_REG_THREADMASK
#undef DEF_GLOBAL_REG_THREADMASK
#endif


#ifndef DEF_REG_ARES
#define DEF_REG_ARES(...) /* NOTHING */
#define SELF_DEF_REG_ARES
#endif

#ifndef DEF_GLOBAL_REG_ARES
#define DEF_GLOBAL_REG_ARES(...) /* NOTHING */
#define SELF_DEF_GLOBAL_REG_ARES
#endif

//Core Ares S_cregs
DEF_REG_ARES(REG_TNUM, "Core Reset", 0)
DEF_REG_ARES(REG_GEVB, "Core Reset", 0)
DEF_GLOBAL_REG_ARES(REG_TIMERLO, "Core Reset", 0)
DEF_GLOBAL_REG_ARES(REG_TIMERHI, "Core Reset", 0)

//Core Ares U_cregs
DEF_REG_ARES(REG_SA0, "Core Reset", 0)
DEF_REG_ARES(REG_SA1, "Core Reset", 0)
DEF_REG_ARES(REG_FRAMELIMIT, "Core Reset", 0)
DEF_REG_ARES(REG_FRAMEKEY, "Core Reset", 0)
DEF_REG_ARES(REG_PKTCNT_LO, "Core Reset", 0)
DEF_REG_ARES(REG_PKTCNT_HI, "Core Reset", 0)
DEF_REG_ARES(REG_UTIMERLO,  "Core Reset", 0)
DEF_REG_ARES(REG_UTIMERHI,  "Core Reset", 0)

//Arch Ares S_cregs
DEF_REG_ARES(REG_SSR, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_EVB, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_MODECTL, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_SYSCONF, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_ISDBCFG0, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_ISDBCFG1, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_LIVELOCK, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_BRKPTPC0, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_BRKPTCFG0, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_BRKPTPC1, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_BRKPTCFG1, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_ISDBEN, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_ISDBGPR, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_RGDR, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_RGDR2, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_TURKEY, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_DUCK, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_CHICKEN, "Arch Reset", 1)
DEF_GLOBAL_REG_ARES(REG_STFINST, "Arch Reset", 0)
DEF_GLOBAL_REG_ARES(REG_ISDBCMD, "Arch Reset", 0)

//Ret Ares S_cregs
DEF_REG_ARES(REG_SGP, "Ret Reset", 1)
DEF_REG_ARES(REG_SGP+1, "Ret Reset", 1)
DEF_REG_ARES(REG_TID, "Ret Reset", 1)
DEF_REG_ARES(REG_CCR, "Ret Reset", 1)
DEF_REG_ARES(REG_IMASK, "Ret Reset", 1)
DEF_REG_ARES(REG_GPCYCLO, "Ret Reset", 1)
DEF_REG_ARES(REG_GPCYCHI, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_IPENDAD, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_VID, "Ret Reset", 0)
DEF_GLOBAL_REG_ARES(REG_VID1, "Ret Reset", 0)
DEF_GLOBAL_REG_ARES(REG_BESTWAIT, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_SCHEDCFG, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_DIAG, "Ret Reset", 0)
DEF_GLOBAL_REG_ARES(REG_PCYCLELO, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PCYCLEHI, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_ISDBST, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_ISDBMBXIN, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_ISDBMBXOUT, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUCNT4, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUCNT5, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUCNT6, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUCNT7, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUCNT0, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUCNT1, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUCNT2, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUCNT3, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUEVTCFG, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUSTID0, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUEVTCFG1, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUSTID1, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_PMUCFG, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_BRKPTINFO, "Ret Reset", 0)

DEF_GLOBAL_REG_ARES(REG_COMMIT_1T, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_COMMIT_2T, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_COMMIT_3T, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_COMMIT_4T, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_COMMIT_5T, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_COMMIT_6T, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_CYCLE_1T, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_CYCLE_2T, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_CYCLE_3T, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_CYCLE_4T, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_CYCLE_5T, "Ret Reset", 1)
DEF_GLOBAL_REG_ARES(REG_CYCLE_6T, "Ret Reset", 1)


//Ret Ares G_cregs
DEF_REG_ARES(REG_GCOMMIT_1T, "Ret Reset", 1)
DEF_REG_ARES(REG_GCOMMIT_2T, "Ret Reset", 1)
DEF_REG_ARES(REG_GCOMMIT_3T, "Ret Reset", 1)
DEF_REG_ARES(REG_GCOMMIT_4T, "Ret Reset", 1)
DEF_REG_ARES(REG_GCOMMIT_5T, "Ret Reset", 1)
DEF_REG_ARES(REG_GCOMMIT_6T, "Ret Reset", 1)

DEF_REG_ARES(REG_GCYCLE_1T, "Ret Reset", 1)
DEF_REG_ARES(REG_GCYCLE_2T, "Ret Reset", 1)
DEF_REG_ARES(REG_GCYCLE_3T, "Ret Reset", 1)
DEF_REG_ARES(REG_GCYCLE_4T, "Ret Reset", 1)
DEF_REG_ARES(REG_GCYCLE_5T, "Ret Reset", 1)
DEF_REG_ARES(REG_GCYCLE_6T, "Ret Reset", 1)

DEF_REG_ARES(REG_GPMUCNT4, "Ret Reset", 1)
DEF_REG_ARES(REG_GPMUCNT5, "Ret Reset", 1)
DEF_REG_ARES(REG_GPMUCNT6, "Ret Reset", 1)
DEF_REG_ARES(REG_GPMUCNT7, "Ret Reset", 1)
DEF_REG_ARES(REG_GPCYCLO, "Ret Reset", 1)
DEF_REG_ARES(REG_GPCYCHI, "Ret Reset", 1)
DEF_REG_ARES(REG_GPMUCNT0, "Ret Reset", 1)
DEF_REG_ARES(REG_GPMUCNT1, "Ret Reset", 1)
DEF_REG_ARES(REG_GPMUCNT2, "Ret Reset", 1)
DEF_REG_ARES(REG_GPMUCNT3, "Ret Reset",1 )

//Ret Ares U_cregs
DEF_REG_ARES(REG_PQ, "Ret Reset", 0)
DEF_REG_ARES(REG_USR, "Ret Reset", 0)
DEF_REG_ARES(REG_PC, "Ret Reset", 1)
DEF_REG_ARES(REG_UPCYCLE_LO, "Ret Reset", 0)
DEF_REG_ARES(REG_UPCYCLE_HI, "Ret Reset", 0)


//NRet Ares G_cregs
DEF_REG_ARES(REG_GELR, "NRet Reset", 0)
DEF_REG_ARES(REG_GSR, "NRet Reset", 0)
DEF_REG_ARES(REG_GOSP, "NRet Reset", 0)
DEF_REG_ARES(REG_GBADVA, "NRet Reset", 0)

//NRet Ares U_cregs
DEF_REG_ARES(REG_LC0, "NRet Reset", 0)
DEF_REG_ARES(REG_LC1, "NRet Reset", 0)
DEF_REG_ARES(REG_M, "NRet Reset", 0)
DEF_REG_ARES(REG_M+1, "NRet Reset", 0)
DEF_REG_ARES(REG_UGP, "NRet Reset", 0)
DEF_REG_ARES(REG_GP, "NRet Reset", 0)
DEF_REG_ARES(REG_CSA, "NRet Reset", 0)
DEF_REG_ARES(REG_CSA+1, "NRet Reset", 0)


//NRET Ares S_cregs
DEF_REG_ARES(REG_ELR, "NRet Reset", 0)
DEF_REG_ARES(REG_BADVA0, "NRet Reset", 0)
DEF_REG_ARES(REG_BADVA1, "NRet Reset", 0)
DEF_REG_ARES(REG_BADVA, "NRet Reset", 0)

#ifdef SELF_DEF_REG_ARES
#undef SELF_DEF_REG_ARES
#undef DEF_REG_ARES
#endif

#ifdef SELF_DEF_GLOBAL_REG_ARES
#undef SELF_DEF_GLOBAL_REG_ARES
#undef DEF_GLOBAL_REG_ARES
#endif


#include "l2regs.def"
