/*
 *  Copyright(c) 2019-2020 Qualcomm Innovation Center, Inc. All Rights Reserved.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

DEF_MACRO(
	LIKELY,		/* NAME */
	(X),		/* PARAMS */
	"X",		/* sdescr */
	"X",		/* ldescr */
	__builtin_expect((X),1), /* BEH */
	()		/* attribs */
)

DEF_MACRO(
	UNLIKELY,	/* NAME */
	(X),		/* PARAMS */
	"X",		/* sdescr */
	"X",		/* ldescr */
	__builtin_expect((X),0), /* BEH */
	()		/* attribs */
)

DEF_MACRO(
	CANCEL, /* macro name */
	, /* parameters */
	"NOP", /* short description */
	"NOP this instruction", /* long description */
	{if (thread->last_pkt) thread->last_pkt->slot_cancelled |= (1<<insn->slot); return;} , /* behavior */
	(A_CONDEXEC)
)

DEF_MACRO(
	LOAD_CANCEL, /* macro name */
	(EA), /* parameters */
	"NOP", /* short description */
	"NOP this instruction", /* long description */
	{mem_general_load_cancelled(thread,EA,insn);CANCEL;} , /* behavior */
	(A_CONDEXEC)
)

DEF_MACRO(
	STORE_CANCEL, /* macro name */
	(EA), /* parameters */
	"NOP", /* short description */
	"NOP this instruction", /* long description */
	{mem_general_store_cancelled(thread,EA,insn);CANCEL;} , /* behavior */
	(A_CONDEXEC)
)

DEF_MACRO(
	fMAX, /* macro name */
	(A,B), /* parameters */
	"max(A,B)", /* short description */
	"the larger of A and B", /* long description */
	(((A) > (B)) ? (A) : (B)), /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fMIN, /* macro name */
	(A,B), /* parameters */
	"min(A,B)", /* short description */
	"the smaller of A and B", /* long description */
	(((A) < (B)) ? (A) : (B)), /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fABS, /* macro name */
	(A), /* parameters */
	"ABS(A)", /* short description */
	"if A is less than zero then A=-A", /* long description */
	(((A)<0)?(-(A)):(A)), /* behavior */
	/* optional attributes */
)


/* Bit insert */
DEF_MACRO(
	fINSERT_BITS,(REG,WIDTH,OFFSET,INVAL),
	"REG[(WIDTH-1+OFFSET):OFFSET]=INVAL",
	"REG[(WIDTH-1+OFFSET):OFFSET]=INVAL",
        {
	   REG = ((REG) & ~(((fCONSTLL(1)<<(WIDTH))-1)<<(OFFSET))) | (((INVAL) & ((fCONSTLL(1)<<(WIDTH))-1)) << (OFFSET));
        },
	/* attribs */
)

/* Bit extract */
DEF_MACRO(
	fEXTRACTU_BITS,(INREG,WIDTH,OFFSET),
	"INREG[(WIDTH+OFFSET-1):OFFSET]",
	"INREG[(WIDTH+OFFSET-1):OFFSET]",
	(fZXTN(WIDTH,32,(INREG >> OFFSET))),
	/* attribs */
)

DEF_MACRO(
	fEXTRACTU_BIDIR,(INREG,WIDTH,OFFSET),
	"INREG[(WIDTH+OFFSET-1):OFFSET]",
	"INREG[(WIDTH+OFFSET-1):OFFSET]",
	(fZXTN(WIDTH,32,fBIDIR_LSHIFTR((INREG),(OFFSET),4_8))),
	/* attribs */
)

DEF_MACRO(
	fEXTRACTU_RANGE,(INREG,HIBIT,LOWBIT),
	"INREG[HIBIT:LOWBIT]",
	"INREG[HIBIT:LOWBIT]",
	(fZXTN((HIBIT-LOWBIT+1),32,(INREG >> LOWBIT))),
	/* attribs */
)

DEF_MACRO(
	f8BITSOF,(VAL),
	"VAL ? 0xff : 0x00",
	"VAL ? 0xff : 0x00",
	( (VAL) ? 0xff : 0x00),
	/* attribs */
)

DEF_MACRO(
	fLSBOLD,(VAL),
	"VAL[0]",
	"Least significant bit of VAL",
	((VAL) & 1),
	()
)

DEF_MACRO(
	fLSBNEW,(PNUM),
	"PNUM.new[0]",
	"Least significant bit of new PNUM",
	predlog_read(thread,PNUM),
	()
)

DEF_MACRO(
	fLSBNEW0,,
	"P0.new[0]",
	"Least significant bit of new P0",
	predlog_read(thread,0),
	()
)

DEF_MACRO(
	fLSBNEW1,,
	"P1.new[0]",
	"Least significant bit of new P1",
	predlog_read(thread,1),
	()
)

DEF_MACRO(
	fLSBOLDNOT,(VAL),
	"!VAL[0]",
	"!Least significant bit of VAL",
	(!fLSBOLD(VAL)),
	()
)

DEF_MACRO(
	fLSBNEWNOT,(PNUM),
	"!PNUM.new[0]",
	"!Least significant bit of new PNUM",
	(!fLSBNEW(PNUM)),
	()
)

DEF_MACRO(
	fLSBNEW0NOT,,
	"!P0.new[0]",
	"!Least significant bit of new P0",
	(!fLSBNEW0),
	()
)

DEF_MACRO(
	fLSBNEW1NOT,,
	"P1.new[0]",
	"Least significant bit of new P1",
	(!fLSBNEW1),
	()
)

DEF_MACRO(
	fNEWREG,(RNUM),
	"RNUM.new",
	"Register value produced in this packet",
	({if (newvalue_missing(thread,RNUM) ||
      IS_CANCELLED(insn->new_value_producer_slot)) CANCEL; reglog_read(thread,RNUM);}),
	(A_DOTNEWVALUE,A_RESTRICT_SLOT0ONLY)
)
// Store new with a missing newvalue or cancelled goes out as a zero byte store in V65
// take advantage of the fact that reglog_read returns zero for not valid rnum
DEF_MACRO(
	fNEWREG_ST,(RNUM),
	"RNUM.new",
	"Register value produced in this packet for store",
	({if (newvalue_missing(thread,RNUM) ||
      IS_CANCELLED(insn->new_value_producer_slot)) { STORE_ZERO; RNUM = -1; }; reglog_read(thread,RNUM);}),
	(A_DOTNEWVALUE,A_RESTRICT_SLOT0ONLY)
)

DEF_MACRO(
	fSATUVALN,(N,VAL),
	"N-Bit Unsigned Saturation Value for sign of VAL",
	"N-Bit Unsigned Saturation Value for sign of VAL",
	({fSET_OVERFLOW(); ((VAL) < 0) ? 0 : ((1LL<<(N))-1);}),
	()
)

DEF_MACRO(
	fSATVALN,(N,VAL),
	"N-Bit Saturation Value for sign of VAL",
	"N-Bit Saturation Value for sign of VAL",
	({fSET_OVERFLOW(); ((VAL) < 0) ? (-(1LL<<((N)-1))) : ((1LL<<((N)-1))-1);}),
	()
)

DEF_MACRO(
	fZXTN, /* macro name */
	(N,M,VAL),
	"zxt_{N->M}(VAL)", /* short descr */
	"Zero extend N bits from VAL",
	((VAL) & ((1LL<<(N))-1)),
	/* attribs */
)

DEF_MACRO(
	fSXTN, /* macro name */
	(N,M,VAL),
	"sxt_{N->M}(VAL)", /* short descr */
	"Sign extend N bits from VAL",
	((fZXTN(N,M,VAL) ^ (1LL<<((N)-1))) - (1LL<<((N)-1))),
	/* attribs */
)

DEF_MACRO(
	fSATN,
	(N,VAL),
	"sat_##N(VAL)", /* short descr */
	"Saturate VAL to N bits",
	((fSXTN(N,64,VAL) == (VAL)) ? (VAL) : fSATVALN(N,VAL)),
	()
)

DEF_MACRO(
	fADDSAT64,
	(DST,A,B),
	"DST=sat64(A+B)", /* short descr */
	"DST=sat64(A+B)",
	{
	  size8u_t __a = fCAST8u(A);
	  size8u_t __b = fCAST8u(B);
	  size8u_t __sum = __a + __b;
	  size8u_t __xor = __a ^ __b;
	  const size8u_t __mask = 0x8000000000000000ULL;
	  if (__xor & __mask) {
		/* Opposite signs, OK */
		DST = __sum;
	  } else if ((__a ^ __sum) & __mask) {
		/* Signs mismatch */
		if (__sum & __mask) {
			/* overflowed to negative, make max pos */
			DST=0x7FFFFFFFFFFFFFFFLL; fSET_OVERFLOW();
		} else {
			/* overflowed to positive, make max neg */
			DST=0x8000000000000000LL; fSET_OVERFLOW();
		}
	  } else {
		/* signs did not mismatch, OK */
		DST = __sum;
	  }
        },
	()
)

DEF_MACRO(
	fSATUN,
	(N,VAL),
	"usat_##N(VAL)", /* short descr */
	"Saturate VAL to N bits",
	((fZXTN(N,64,VAL) == (VAL)) ? (VAL) : fSATUVALN(N,VAL)),
	()
)

DEF_MACRO(
	fSATH,
	(VAL),
	"sat_16(VAL)", /* short descr */
	"Saturate VAL to a signed half",
	(fSATN(16,VAL)),
	()
)


DEF_MACRO(
	fSATUH,
	(VAL),
	"usat_16(VAL)", /* short descr */
	"Saturate VAL to an unsigned half",
	(fSATUN(16,VAL)),
	()
)

DEF_MACRO(
	fSATUB,
	(VAL),
	"usat_8(VAL)", /* short descr */
	"Saturate VAL to an unsigned byte",
	(fSATUN(8,VAL)),
	()
)
DEF_MACRO(
	fSATB,
	(VAL),
	"sat_8(VAL)", /* short descr */
	"Saturate VAL to a signed byte",
	(fSATN(8,VAL)),
	()
)


/*************************************/
/* immediate extension               */
/*************************************/

DEF_MACRO(
	fIMMEXT,
	(IMM),
	"apply_extension(IMM)",
	"Apply extension to IMM",
	(IMM = IMM),
	(A_EXTENDABLE)
)

DEF_MACRO(
	fMUST_IMMEXT,
	(IMM),
	"apply_extension(IMM)",
	"Apply extension to IMM",
	fIMMEXT(IMM),
	(A_EXTENDABLE)
)

DEF_MACRO(
	fPCALIGN,
	(IMM),
	"IMM=IMM & ~PCALIGN_MASK",
	"",
	IMM=(IMM & ~PCALIGN_MASK),
	(A_EXTENDABLE)
)

/*************************************/
/* Read and Write Implicit Regs      */
/*************************************/

DEF_MACRO(
	fREAD_LR, /* read link register */
	(), /* parameters */
	"LR", /* short description */
	"LR", /* long description */
	(READ_RREG(REG_LR)),          /* behavior */
	()
)

DEF_MACRO(
	fWRITE_LR, /* write lr */
	(A), /* parameters */
	"LR=A", /* short description */
	"LR=A", /* long description */
	WRITE_RREG(REG_LR,A),          /* behavior */
	(A_IMPLICIT_WRITES_LR)
)

DEF_MACRO(
	fWRITE_FP, /* write sp */
	(A), /* parameters */
	"FP=A", /* short description */
	"FP=A", /* long description */
	WRITE_RREG(REG_FP,A),          /* behavior */
	(A_IMPLICIT_WRITES_FP)
)

DEF_MACRO(
	fWRITE_SP, /* write sp */
	(A), /* parameters */
	"SP=A", /* short description */
	"SP=A", /* long description */
        WRITE_RREG(REG_SP,A),          /* behavior */
	(A_IMPLICIT_WRITES_SP)
)

DEF_MACRO(
	fREAD_SP, /* read stack pointer */
	(), /* parameters */
	"SP", /* short description */
	"SP", /* long description */
	(READ_RREG(REG_SP)),          /* behavior */
	()
)

DEF_MACRO(
	fREAD_LC0, /* read loop count */
	, /* parameters */
	"LC0", /* short description */
	"LC0", /* long description */
	(READ_RREG(REG_LC0)),          /* behavior */
	()
)

DEF_MACRO(
	fREAD_LC1, /* read loop count */
	, /* parameters */
	"LC1", /* short description */
	"LC1", /* long description */
	(READ_RREG(REG_LC1)),          /* behavior */
	()
)

DEF_MACRO(
	fREAD_SA0, /* read start addr */
	, /* parameters */
	"SA0", /* short description */
	"SA0", /* long description */
	(READ_RREG(REG_SA0)),          /* behavior */
	()
)

DEF_MACRO(
	fREAD_SA1, /* read start addr */
	, /* parameters */
	"SA1", /* short description */
	"SA1", /* long description */
	(READ_RREG(REG_SA1)),          /* behavior */
	()
)


DEF_MACRO(
	fREAD_FP, /* read frame pointer */
	(), /* parameters */
	"FP", /* short description */
	"FP", /* long description */
	(READ_RREG(REG_FP)),          /* behavior */
	()
)

DEF_MACRO(
	fREAD_GP, /* read global pointer */
	(), /* parameters */
	"(Constant_extended ? (0) : GP)", /* short description */
	"(Constant_extended ? (0) : GP)", /* long description */
	(insn->extension_valid ? 0 : READ_RREG(REG_GP)),          /* behavior */
	()
)

DEF_MACRO(
	fREAD_PC, /* read PC */
	(), /* parameters */
	"PC", /* short description */
	"PC", /* long description */
	(READ_RREG(REG_PC)),          /* behavior */
	()
)

DEF_MACRO(
	fREAD_NPC, /* read next PC */
	(), /* parameters */
	"NPC", /* short description */
	"NPC", /* long description */
	(thread->next_PC & (0xfffffffe)),          /* behavior */
	()
)

DEF_MACRO(
	fREAD_P0, /* read Predicate 0 */
	(), /* parameters */
	"P0", /* short description */
	"P0", /* long description */
	(READ_PREG(0)),          /* behavior */
	()
)

DEF_MACRO(
	fREAD_P3, /* read Predicate 3 */
	(), /* parameters */
	"P3", /* short description */
	"P3", /* long description */
	(READ_PREG(3)),          /* behavior */
	()
)

DEF_MACRO(
	fCHECK_PCALIGN, (A),
	"",
	"",
	/* EJP: if exception already detected, do not trigger pc unaligned exception since we will be rewinding PC anyway. */
	/* Maybe this will screw up prioritization logic... but probably it is ok?  Otherwise we can ditch out of dealloc_return early if EXCEPTION_DETECTED */
	if (((A) & PCALIGN_MASK)) {
		register_error_exception(thread,PRECISE_CAUSE_PC_NOT_ALIGNED,thread->Regs[REG_BADVA0],thread->Regs[REG_BADVA1],GET_SSR_FIELD(SSR_BVS),GET_SSR_FIELD(SSR_V0),GET_SSR_FIELD(SSR_V1),0);
	},
	()
)

DEF_MACRO(
	fWRITE_NPC, /* write next PC */
	(A), /* parameters */
	"PC=A", /* short description */
	"PC=A", /* long description */
	if (!thread->branch_taken) {
           if (A != thread->next_PC) {
             thread->next_pkt_guess=thread->last_pkt->taken_ptr;
           }
	   fCHECK_PCALIGN(A);
           thread->branched = 1; thread->branch_taken = 1; thread->next_PC = A; \
           thread->branch_offset = insn->encoding_offset; thread->branch_opcode = insn->opcode;
        }
         ,          /* behavior */
	(A_COF)
)

DEF_MACRO(
	fBRANCH,
	(LOC,TYPE),
	"PC=LOC",
	"PC=LOC",
	fWRITE_NPC(LOC); fCOF_CALLBACK(LOC,TYPE),
	()
)

DEF_MACRO(
	fJUMPR,	/* A jumpr has executed */
	(REGNO,TARGET,TYPE),
	"PC=TARGET",
	"PC=TARGET",
	{fBRANCH(TARGET,COF_TYPE_JUMPR);},
	(A_INDIRECT)
)

DEF_MACRO(
	fHINTJR,	/* A hintjr instruction has executed */
	(TARGET),
	"",
	"",
	{ },
)

DEF_MACRO(
	fCALL,	/* Do a call */
	(A),
	"fWRITE_LR(fREAD_NPC()); fWRITE_NPC(A);",
	"fWRITE_LR(fREAD_NPC()); fWRITE_NPC(A);",
	if (!thread->branch_taken) {fBP_RAS_CALL(A); fWRITE_LR(fREAD_NPC()); fBRANCH(A,COF_TYPE_CALL);},
	(A_COF,A_IMPLICIT_WRITES_LR,A_CALL)
)

DEF_MACRO(
	fCALLR,	/* Do a call Register */
	(A),
	"fWRITE_LR(fREAD_NPC()); fWRITE_NPC(A);",
	"fWRITE_LR(fREAD_NPC()); fWRITE_NPC(A);",
	if (!thread->branch_taken) {fBP_RAS_CALL(A); fWRITE_LR(fREAD_NPC()); fBRANCH(A,COF_TYPE_CALLR);},
	(A_COF,A_IMPLICIT_WRITES_LR,A_CALL)
)

DEF_MACRO(
	fWRITE_LOOP_REGS0, /* write ln,sa,ea,lc */
	(START,COUNT), /* parameters */
	"SA0=START; LC0=COUNT", /* short description */
	"SA0=START; LC0=COUNT", /* short description */
	{WRITE_RREG(REG_LC0,COUNT);
         WRITE_RREG(REG_SA0,START);},
	(A_IMPLICIT_WRITES_LC0,A_IMPLICIT_WRITES_SA0)
)

DEF_MACRO(
	fWRITE_LOOP_REGS1, /* write ln,sa,ea,lc */
	(START,COUNT), /* parameters */
	"SA1=START; LC1=COUNT", /* short description */
	"SA1=START; LC1=COUNT", /* short description */
	{WRITE_RREG(REG_LC1,COUNT);
         WRITE_RREG(REG_SA1,START);},
	(A_IMPLICIT_WRITES_LC1,A_IMPLICIT_WRITES_SA1)
)

DEF_MACRO(
	fWRITE_LC0,
	(VAL), /* parameters */
	"LC0=VAL", /* short description */
	"LC0=VAL",
	WRITE_RREG(REG_LC0,VAL),
	(A_IMPLICIT_WRITES_LC0)
)

DEF_MACRO(
	fWRITE_LC1,
	(VAL), /* parameters */
	"LC1=VAL", /* short description */
	"LC1=VAL",
	WRITE_RREG(REG_LC1,VAL),
	(A_IMPLICIT_WRITES_LC1)
)

DEF_MACRO(
	fCARRY_FROM_ADD,
	(A,B,C),
	"carry_from_add(A,B,C)",
	"carry_from_add(A,B,C)",
	carry_from_add64(A,B,C),
	/* NOTHING */
)

DEF_MACRO(
	fSET_OVERFLOW,
	(),
	"USR.OVF=1",
	"USR.OVF=1",
	SET_USR_FIELD(USR_OVF,1),
	()
)

DEF_MACRO(
	fSET_LPCFG,
	(VAL), /* parameters */
	"USR.LPCFG=VAL",
	"USR.LPCFG=VAL",
	SET_USR_FIELD(USR_LPCFG,(VAL)),
	()
)


DEF_MACRO(
	fGET_LPCFG,
	, /* parameters */
	"USR.LPCFG",
	"USR.LPCFG",
	(GET_USR_FIELD(USR_LPCFG)),
	()
)



DEF_MACRO(
	fWRITE_P0, /* write Predicate 0 */
	(VAL), /* parameters */
	"P0=VAL", /* short description */
	"P0=VAL", /* long description */
	WRITE_PREG(0,VAL),          /* behavior */
	(A_IMPLICIT_WRITES_P0)
)

DEF_MACRO(
	fWRITE_P1, /* write Predicate 0 */
	(VAL), /* parameters */
	"P1=VAL", /* short description */
	"P1=VAL", /* long description */
	WRITE_PREG(1,VAL),          /* behavior */
	(A_IMPLICIT_WRITES_P1)
)

DEF_MACRO(
	fWRITE_P2, /* write Predicate 0 */
	(VAL), /* parameters */
	"P2=VAL", /* short description */
	"P2=VAL", /* long description */
	WRITE_PREG(2,VAL),          /* behavior */
	(A_IMPLICIT_WRITES_P2)
)

DEF_MACRO(
	fWRITE_P3, /* write Predicate 0 */
	(VAL), /* parameters */
	"P3=VAL", /* short description */
	"P3=VAL", /* long description */
	WRITE_PREG(3,VAL),     /* behavior */
	(A_IMPLICIT_WRITES_P3)
)

DEF_MACRO(
	fPART1, /* write Predicate 0 */
	(WORK), /* parameters */
	"WORK", /* short description */
	"WORK", /* long description */
	if (insn->part1) { WORK; return; },          /* behavior */
	/* optional attributes */
)


/*************************************/
/* Casting, Sign-Zero extension, etc */
/*************************************/

DEF_MACRO(
	fCAST4u, /* macro name */
	(A), /* parameters */
	"A.uw[0]", /* short description */
	"unsigned 32-bit A", /* long description */
	((size4u_t)(A)),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fCAST4s, /* macro name */
	(A), /* parameters */
	"A.s32", /* short description */
	"signed 32-bit A", /* long description */
	((size4s_t)(A)),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fCAST8u, /* macro name */
	(A), /* parameters */
	"A.u64", /* short description */
	"unsigned 64-bit A", /* long description */
	((size8u_t)(A)),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fCAST8s, /* macro name */
	(A), /* parameters */
	"A.s64", /* short description */
	"signed 64-bit A", /* long description */
	((size8s_t)(A)),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fCAST4_4s, /* macro name */
	(A), /* params */
	"A",
	"signed 32-bit A",
	((size4s_t)(A)),
	/* optional attributes */
)

DEF_MACRO(
	fCAST4_4u, /* macro name */
	(A), /* params */
	"A",
	"unsigned 32-bit A",
	((size4u_t)(A)),
	/* optional attributes */
)


DEF_MACRO(
	fCAST4_8s, /* macro name */
	(A), /* params */
	"fSXTN(32,64,A)",
	"32-bit A sign-extended to signed 64-bit",
	((size8s_t)((size4s_t)(A))),
	/* optional attributes */
)

DEF_MACRO(
	fCAST4_8u, /* macro name */
	(A), /* params */
	"fZXTN(32,64,A)",
	"32-bit A zero-extended to unsigned 64-bit",
	((size8u_t)((size4u_t)(A))),
	/* optional attributes */
)

DEF_MACRO(
	fCAST8_8s, /* macro name */
	(A), /* params */
	"A",
	"signed 64-bit A",
	((size8s_t)(A)),
	/* optional attributes */
)

DEF_MACRO(
	fCAST8_8u, /* macro name */
	(A), /* params */
	"A",
	"unsigned 64-bit A",
	((size8u_t)(A)),
	/* optional attributes */
)

DEF_MACRO(
	fCAST2_8s, /* macro name */
	(A), /* params */
	"fSXTN(16,64,A)",
	"16-bit A sign-extended to signed 64-bit",
	((size8s_t)((size2s_t)(A))),
	/* optional attributes */
)
DEF_MACRO(
	fCAST2_8u, /* macro name */
	(A), /* params */
	"fZXTN(16,64,A)",
	"16-bit A zero-extended to unsigned 64-bit",
	((size8u_t)((size2u_t)(A))),
	/* optional attributes */
)

DEF_MACRO(
	fZE8_16, /* zero-extend 8 to 16 */
	(A),
	"A",
	"Unsigned low 8 bits of A",
	((size2s_t)((size1u_t)(A))),
	/* optional attributes */
)
DEF_MACRO(
	fSE8_16, /* sign-extend 8 to 16 */
	(A),
	"A",
	"Signed low 8 bits of A",
	((size2s_t)((size1s_t)(A))),
	/* optional attributes */
)


DEF_MACRO(
	fSE16_32, /* sign-extend 16 to 32 */
	(A), /* parameters */
	"A", /* short description */
	"signed low 16-bits of A", /* long description */
	((size4s_t)((size2s_t)(A))),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fZE16_32, /* zero-extend 16 to 32 */
	(A), /* parameters */
	"A", /* short description */
	"signed low 16-bits of A", /* long description */
	((size4u_t)((size2u_t)(A))),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fSE32_64,
	(A), /* parameters */
	"A", /* short description */
	"A", /* long description */
	( (size8s_t)((size4s_t)(A)) ),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fZE32_64,
	(A), /* parameters */
	"A", /* short description */
	"zero-extend A from 32 to 64", /* long description */
	( (size8u_t)((size4u_t)(A)) ),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fSE8_32, /* sign-extend 8 to 32 */
	(A),
	"A",
	"Signed low 8 bits of A",
	((size4s_t)((size1s_t)(A))),
	/* optional attributes */
)

DEF_MACRO(
	fZE8_32, /* zero-extend 8 to 32 */
	(A),
	"A",
	"Unsigned low 8 bits of A",
	((size4s_t)((size1u_t)(A))),
	/* optional attributes */
)

/*************************************/
/* DSP arithmetic support            */
/************************************/
DEF_MACRO(
	fMPY8UU, /* multiply half integer */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"unsigned 8-bit multiply of A by B", /* long description */
	(int)(fZE8_16(A)*fZE8_16(B)),     /* behavior */
	()
)
DEF_MACRO(
	fMPY8US, /* multiply half integer */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"unsigned 8-bit multiply of A by signed B", /* long description */
	(int)(fZE8_16(A)*fSE8_16(B)),     /* behavior */
	()
)
DEF_MACRO(
	fMPY8SU, /* multiply half integer */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"signed 8-bit multiply of A by unsigned B", /* long description */
	(int)(fSE8_16(A)*fZE8_16(B)),     /* behavior */
	()
)

DEF_MACRO(
	fMPY8SS, /* multiply half integer */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"signed 8-bit multiply of A by B", /* long description */
	(int)((short)(A)*(short)(B)),     /* behavior */
	()
)

DEF_MACRO(
	fMPY16SS, /* multiply half integer */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"signed 16-bit multiply of A by B", /* long description */
	fSE32_64(fSE16_32(A)*fSE16_32(B)),     /* behavior */
	()
)

DEF_MACRO(
	fMPY16UU, /* multiply unsigned half integer */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"multiply unsigned A by unsigned B", /* long description */
	fZE32_64(fZE16_32(A)*fZE16_32(B)),     /* behavior */
	()
)

DEF_MACRO(
	fMPY16SU, /* multiply half integer */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"signed 16-bit A times unsigned 16-bit B", /* long description */
	fSE32_64(fSE16_32(A)*fZE16_32(B)),     /* behavior */
	()
)

DEF_MACRO(
	fMPY16US, /* multiply half integer */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"unsigned 16-bit A times signed 16-bit B", /* long description */
	fMPY16SU(B,A),
	()
)

DEF_MACRO(
	fMPY32SS, /* multiply half integer */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"signed 32-bit multiply of A by B", /* long description */
	(fSE32_64(A)*fSE32_64(B)),     /* behavior */
	()
)

DEF_MACRO(
	fMPY32UU, /* multiply half integer */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"unsigned 32-bit multiply of A by B", /* long description */
	(fZE32_64(A)*fZE32_64(B)),     /* behavior */
	()
)

DEF_MACRO(
	fMPY32SU, /* multiply half integer */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"32-bit multiply of signed A by unsigned B", /* long description */
	(fSE32_64(A)*fZE32_64(B)),     /* behavior */
	()
)

DEF_MACRO(
	fMPY3216SS, /* multiply mixed precision */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"signed 16-bit multiply of A by B", /* long description */
	(fSE32_64(A)*fSXTN(16,64,B)),     /* behavior */
	()
)

DEF_MACRO(
	fMPY3216SU, /* multiply mixed precision */
	(A,B), /* parameters */
	"(A * B)", /* short description */
	"signed 16-bit multiply of A by unsigned B", /* long description */
	(fSE32_64(A)*fZXTN(16,64,B)),     /* behavior */
	()
)

DEF_MACRO(
	fROUND, /* optional rounding */
	(A), /* parameters */
	"round(A)", /* short description */
	"round(A)", /* long description */
	(A+0x8000),
	/* optional attributes */
)

DEF_MACRO(
	fCLIP, /* optional rounding */
	(DST,SRC,U), /* parameters */
	"DST=MIN((1<<U)-1,MAX(SRC,-(1<<U)))", /* short description */
	"DST=IN((1<<U)-1,MAX(SRC,-(1<<U)))", /* long description */
	{ size4s_t maxv = (1<<U)-1;
	 size4s_t minv = -(1<<U);
	 DST = fMIN(maxv,fMAX(SRC,minv));
	},
	/* optional attributes */
)

DEF_MACRO(
	fCRND, /* optional rounding */
	(A), /* parameters */
	"convround(A)", /* short description */
	"convround(A)", /* long description */
	((((A)&0x3)==0x3)?((A)+1):((A))),
	/* optional attributes */
)

DEF_MACRO(
	fRNDN, /* Rounding to a boundary */
	(A,N), /* parameters */
	"(N==0)?(A):round(A,2**(N-1))", /* short description */
	"(N==0)?(A):round(A,2**(N-1))", /* long description */
	((((N)==0)?(A):(((fSE32_64(A))+(1<<((N)-1)))))),
	/* optional attributes */
)

DEF_MACRO(
	fCRNDN, /* Rounding to a boundary */
	(A,N), /* parameters */
	"(N==0)?A:convround(A,2**(N-1))>>N", /* short description */
	"(N==0)?A:convround(A,2**(N-1))>>N", /* long description */
	(conv_round(A,N)),
	/* optional attributes */
)

DEF_MACRO(
	fADD128, /* Rounding to a boundary */
	(A,B), /* parameters */
	"A+B", /* short description */
	"", /* long description */
	(add128(A, B)),
	/* optional attributes */
)
DEF_MACRO(
	fSUB128, /* Rounding to a boundary */
	(A,B), /* parameters */
	"A-B", /* short description */
	"", /* long description */
	(sub128(A, B)),
	/* optional attributes */
)
DEF_MACRO(
	fSHIFTR128, /* Rounding to a boundary */
	(A,B), /* parameters */
	"(size8s_t) (A >> B)", /* short description */
	"", /* long description */
	(shiftr128(A, B)),
	/* optional attributes */
)

DEF_MACRO(
	fSHIFTL128, /* Rounding to a boundary */
	(A,B), /* parameters */
	"(A << B)", /* short description */
	"", /* long description */
	(shiftl128(A, B)),
	/* optional attributes */
)

DEF_MACRO(
	fAND128, /* Rounding to a boundary */
	(A,B), /* parameters */
	"(A & B)", /* short description */
	"", /* long description */
	(and128(A, B)),
	/* optional attributes */
)

DEF_MACRO(
	fCAST8S_16S, /* Rounding to a boundary */
	(A), /* parameters */
	"sxt_{64->128}(A)", /* short description */
	"", /* long description */
	(cast8s_to_16s(A)),
	/* optional attributes */
)
DEF_MACRO(
	fCAST16S_8S, /* Rounding to a boundary */
	(A), /* parameters */
	"sxt_{128->64}(A)", /* short description */
	"", /* long description */
	(cast16s_to_8s(A)),
	/* optional attributes */
)

DEF_MACRO(
	fEA_RI, /* Calculate EA with Register + Immediate Offset */
	(REG,IMM),
	"EA=REG+IMM",	/* short descr */
	"EA=REG+IMM",	/* long descr */
	do { EA=REG+IMM; fDOCHKPAGECROSS(REG,EA); } while (0),
	()
)

DEF_MACRO(
	fEA_RRs, /* Calculate EA with Register + Registers scaled Offset */
	(REG,REG2,SCALE),
	"EA=REG+(REG2<<SCALE)",	/* short descr */
	"EA=REG+(REG2<<SCALE)",	/* long descr */
	do { EA=REG+(REG2<<SCALE); fDOCHKPAGECROSS(REG,EA); } while (0),
	()
)

DEF_MACRO(
	fEA_IRs, /* Calculate EA with Immediate + Registers scaled Offset */
	(IMM,REG,SCALE),
	"EA=IMM+(REG<<SCALE)",	/* short descr */
	"EA=IMM+(REG<<SCALE)",	/* long descr */
	do { EA=IMM+(REG<<SCALE); fDOCHKPAGECROSS(IMM,EA); } while (0),
	()
)

DEF_MACRO(
	fEA_IMM, /* Calculate EA with Immediate */
	(IMM),
	"EA=IMM",	/* short descr */
	"EA=IMM",	/* long descr */
	EA=IMM,
	()
)

DEF_MACRO(
	fEA_REG, /* Calculate EA with REGISTER */
	(REG),
	"EA=REG",	/* short descr */
	"EA=REG",	/* long descr */
	EA=REG,
	()
)

DEF_MACRO(
	fEA_GPI, /* Calculate EA with Global Poitner + Immediate */
	(IMM),
	"EA=fREAD_GP()+IMM",	/* short descr */
	"EA=fREAD_GP()+IMM",	/* long descr */
    do { EA=fREAD_GP()+IMM; fGP_DOCHKPAGECROSS(fREAD_GP(),EA); } while (0),
	()
)

DEF_MACRO(
	fPM_I, /* Post Modify Register by Immediate*/
	(REG,IMM),
	"REG=REG+IMM",	/* short descr */
	"REG=REG+IMM",	/* long descr */
	do { REG = REG + IMM; } while (0),
	()
)

DEF_MACRO(
	fPM_M, /* Post Modify Register by M register */
	(REG,MVAL),
	"REG=REG+MVAL",	/* short descr */
	"REG=REG+MVAL",	/* long descr */
	do { REG = REG + MVAL; } while (0),
	()
)

DEF_MACRO(
	fSCALE, /* scale by N */
	(N,A), /* parameters */
	"A<<N", /* short description */
	"A<<N", /* long description */
	(((size8s_t)(A))<<N),
	/* optional attributes */
)

DEF_MACRO(
	fSATW, /* saturating to 32-bits*/
	(A), /* parameters */
	"sat_32(A)", /* short description */
	"saturate A to 32-bits", /* long description */
	fSATN(32,((long long)A)),
	()
)

DEF_MACRO(
	fSAT, /* saturating to 32-bits*/
	(A), /* parameters */
	"sat_32(A)", /* short description */
	"saturate A to 32-bits", /* long description */
	fSATN(32,(A)),
	()
)

DEF_MACRO(
	fSAT_ORIG_SHL, /* Saturating to 32-bits, with original value, for shift left */
	(A,ORIG_REG), /* parameters */
	"sat_32(A)", /* short description */
	"saturate A to 32-bits for left shift", /* long description */
	((((size4s_t)((fSAT(A)) ^ ((size4s_t)(ORIG_REG)))) < 0) ?
		fSATVALN(32,((size4s_t)(ORIG_REG))) :
		((((ORIG_REG) > 0) && ((A) == 0)) ?
			fSATVALN(32,(ORIG_REG)) :
			fSAT(A))),
	()
)

DEF_MACRO(
	fPASS,
	(A),
	"A", /* short description */
	"", /* long description */
	A,
)

DEF_MACRO(
	fRND, /* saturating to 32-bits*/
	(A), /* parameters */
	"((A)+1)>>1", /* short description */
	"round(A)", /* long description */
	(((A)+1)>>1),
)


DEF_MACRO(
	fBIDIR_SHIFTL,
	(SRC,SHAMT,REGSTYPE),
	"bidir_shiftl(SRC,SHAMT)",
	"bidir_shiftl(SRC,SHAMT)",
	(((SHAMT) < 0) ? ((fCAST##REGSTYPE(SRC) >> ((-(SHAMT))-1)) >>1) : (fCAST##REGSTYPE(SRC) << (SHAMT))),
	()
)

DEF_MACRO(
	fBIDIR_ASHIFTL,
	(SRC,SHAMT,REGSTYPE),
	"(SHAMT>0)?(fCAST##REGSTYPE##s(SRC)<<SHAMT):(fCAST##REGSTYPE##s(SRC)>>SHAMT)",
	"bidir_asl(fCAST##REGSTYPE##s(SRC),SHAMT)",
	fBIDIR_SHIFTL(SRC,SHAMT,REGSTYPE##s),
	()
)

DEF_MACRO(
	fBIDIR_LSHIFTL,
	(SRC,SHAMT,REGSTYPE),
	"(SHAMT>0)?(fCAST##REGSTYPE##u(SRC)<<SHAMT):(fCAST##REGSTYPE##u(SRC)>>>SHAMT)",
	"bidir_lsl(fCAST##REGSTYPE##u(SRC),SHAMT)",
	fBIDIR_SHIFTL(SRC,SHAMT,REGSTYPE##u),
	()
)

DEF_MACRO(
	fBIDIR_ASHIFTL_SAT,
	(SRC,SHAMT,REGSTYPE),
	"bidir_shiftl(SRC,SHAMT)",
	"bidir_shiftl(SRC,SHAMT)",
	(((SHAMT) < 0) ? ((fCAST##REGSTYPE##s(SRC) >> ((-(SHAMT))-1)) >>1) : fSAT_ORIG_SHL(fCAST##REGSTYPE##s(SRC) << (SHAMT),(SRC))),
	()
)


DEF_MACRO(
	fBIDIR_SHIFTR,
	(SRC,SHAMT,REGSTYPE),
	"bidir_shiftr(SRC,SHAMT)",
	"bidir_shiftr(SRC,SHAMT)",
	(((SHAMT) < 0) ? ((fCAST##REGSTYPE(SRC) << ((-(SHAMT))-1)) << 1) : (fCAST##REGSTYPE(SRC) >> (SHAMT))),
	()
)

DEF_MACRO(
	fBIDIR_ASHIFTR,
	(SRC,SHAMT,REGSTYPE),
	"(SHAMT>0)?(fCAST##REGSTYPE##s(SRC)>>SHAMT):(fCAST##REGSTYPE##s(SRC)<<SHAMT)",
	"bidir_asr(fCAST##REGSTYPE##s(SRC),SHAMT)",
	fBIDIR_SHIFTR(SRC,SHAMT,REGSTYPE##s),
	()
)

DEF_MACRO(
	fBIDIR_LSHIFTR,
	(SRC,SHAMT,REGSTYPE),
	"(SHAMT>0)?(fCAST##REGSTYPE##u(SRC)>>>SHAMT):(fCAST##REGSTYPE##u(SRC)<<SHAMT)",
	"bidir_lsr(fCAST##REGSTYPE##u(SRC),SHAMT)",
	fBIDIR_SHIFTR(SRC,SHAMT,REGSTYPE##u),
	()
)

DEF_MACRO(
	fBIDIR_ASHIFTR_SAT,
	(SRC,SHAMT,REGSTYPE),
	"bidir_shiftr(SRC,SHAMT)",
	"bidir_shiftr(SRC,SHAMT)",
	(((SHAMT) < 0) ? fSAT_ORIG_SHL((fCAST##REGSTYPE##s(SRC) << ((-(SHAMT))-1)) << 1,(SRC)) : (fCAST##REGSTYPE##s(SRC) >> (SHAMT))),
	()
)

DEF_MACRO(
	fASHIFTR,
	(SRC,SHAMT,REGSTYPE),
	"SRC >> SHAMT",
	"asr(SRC,SHAMT)",
	(fCAST##REGSTYPE##s(SRC) >> (SHAMT)),
	/* */
)

DEF_MACRO(
	fLSHIFTR,
	(SRC,SHAMT,REGSTYPE),
	"SRC >>> SHAMT",
	"lsr(SRC,SHAMT)",
	(((SHAMT) >= 64)?0:(fCAST##REGSTYPE##u(SRC) >> (SHAMT))),
	/* */
)

DEF_MACRO(
	fROTL,
	(SRC,SHAMT,REGSTYPE),
	"SRC <<_{R} SHAMT",
	"rol(SRC,SHAMT)",
	(((SHAMT)==0) ? (SRC) : ((fCAST##REGSTYPE##u(SRC) << (SHAMT)) | \
		((fCAST##REGSTYPE##u(SRC) >> ((sizeof(SRC)*8)-(SHAMT)))))),
	/* */
)

DEF_MACRO(
	fROTR,
	(SRC,SHAMT,REGSTYPE),
	"SRC >>_{R} SHAMT",
	"ror(SRC,SHAMT)",
	(((SHAMT)==0) ? (SRC) : ((fCAST##REGSTYPE##u(SRC) >> (SHAMT)) | \
		((fCAST##REGSTYPE##u(SRC) << ((sizeof(SRC)*8)-(SHAMT)))))),
	/* */
)

DEF_MACRO(
	fASHIFTL,
	(SRC,SHAMT,REGSTYPE),
	"fCAST##REGSTYPE##s(SRC) << SHAMT",
	"asl(SRC,SHAMT)",
	(((SHAMT) >= 64)?0:(fCAST##REGSTYPE##s(SRC) << (SHAMT))),
	/* */
)

/*************************************/
/* Floating-Point Support            */
/************************************/

DEF_MACRO(
	fFLOAT, /* name */
	(A), /* parameters */
	"A", /* short description */
	"A", /* long description */
	({ union { float f; size4u_t i; } _fipun; _fipun.i = (A); _fipun.f; }),     /* behavior */
	(A_FPOP)
)

DEF_MACRO(
	fUNFLOAT, /* multiply half integer */
	(A), /* parameters */
	"A", /* short description */
	"A", /* long description */
	({ union { float f; size4u_t i; } _fipun; _fipun.f = (A); isnan(_fipun.f) ? 0xFFFFFFFFU : _fipun.i; }),     /* behavior */
	(A_FPOP)
)

DEF_MACRO(
	fSFNANVAL,(),
	"NaN",
	"NaN",
	0xffffffff,
	()
)

DEF_MACRO(
	fSFINFVAL,(A),
	"sign(A) * Inf",
	"sign(A) * Inf",
	(((A) & 0x80000000) | 0x7f800000),
	()
)

DEF_MACRO(
	fSFONEVAL,(A),
	"sign(A) * 1.0",
	"sign(A) * 1.0",
	(((A) & 0x80000000) | fUNFLOAT(1.0)),
	()
)

DEF_MACRO(
	fCHECKSFNAN,(DST,A),
	"if (isnan(A)) DST = NaN;",
	"if (isnan(A)) DST = NaN;",
	do {
		if (isnan(fFLOAT(A))) {
			if ((fGETBIT(22,A)) == 0) fRAISEFLAGS(FE_INVALID);
			DST = fSFNANVAL();
		}
	} while (0),
	()
)

DEF_MACRO(
	fCHECKSFNAN3,(DST,A,B,C),
	"if (isnan(A) || isnan(B) || isnan(C)) DST = NaN;",
	"if (isnan(A) || isnan(B) || isnan(C)) DST = NaN;",
	do {
		fCHECKSFNAN(DST,A);
		fCHECKSFNAN(DST,B);
		fCHECKSFNAN(DST,C);
	} while (0),
	()
)

DEF_MACRO(
	fSF_BIAS,(),
	"127",
	"single precision bias",
	127,
	()
)

DEF_MACRO(
	fSF_MANTBITS,(),
	"23",
	"single mantissa bits",
	23,
	()
)

DEF_MACRO(
	fSF_MUL_POW2,(A,B),
	"A * 2**B",
	"A * 2**B",
	(fUNFLOAT(fFLOAT(A) * fFLOAT((fSF_BIAS() + (B)) << fSF_MANTBITS()))),
	()
)

DEF_MACRO(
	fSF_GETEXP,(A),
	"exponent(A)",
	"exponent(A)",
	(((A) >> fSF_MANTBITS()) & 0xff),
	()
)

DEF_MACRO(
	fSF_MAXEXP,(),
	"254",
	"SF maximum exponent",
	(254),
	()
)

DEF_MACRO(
	fSF_RECIP_COMMON,(N,D,O,A),
	"(N,D,O,A)=recip_common(N,D)",
	"(N,D,O,A)=recip_common(N,D)",
	arch_sf_recip_common(&N,&D,&O,&A),
	(A_FPOP)
)

DEF_MACRO(
	fSF_INVSQRT_COMMON,(N,O,A),
	"(N,O,A)=invsqrt_common(N)",
	"(N,O,A)=invsqrt_common(N)",
	arch_sf_invsqrt_common(&N,&O,&A),
	(A_FPOP)
)

DEF_MACRO(
	fFMAFX,(A,B,C,ADJ),
	"fmaf(A,B,C) * 2**(ADJ)",
	"Fused Multiply Add w/ Scaling: (A*B+C)*2**ADJ",
	internal_fmafx(A,B,C,fSXTN(8,64,ADJ)),
	()
)

DEF_MACRO(
	fFMAF,(A,B,C),
	"fmaf(A,B,C)",
	"Fused Multiply Add: (A*B+C)",
	internal_fmafx(A,B,C,0),
	()
)

DEF_MACRO(
	fSFMPY,(A,B),
	"A*B",
	"Multiply: A*B",
	internal_mpyf(A,B),
	()
)

DEF_MACRO(
	fMAKESF,(SIGN,EXP,MANT),
	"-1**SIGN * 1.MANT * 2**(EXP-BIAS)",
	"-1**SIGN * 1.MANT * 2**(EXP-BIAS)",
	((((SIGN) & 1) << 31) | (((EXP) & 0xff) << fSF_MANTBITS()) |
		((MANT) & ((1<<fSF_MANTBITS())-1))),
	()
)


DEF_MACRO(
	fDOUBLE, /* multiply half integer */
	(A), /* parameters */
	"A", /* short description */
	"A", /* long description */
	({ union { double f; size8u_t i; } _fipun; _fipun.i = (A); _fipun.f; }),     /* behavior */
	(A_FPOP)
)

DEF_MACRO(
	fUNDOUBLE, /* multiply half integer */
	(A), /* parameters */
	"A", /* short description */
	"A", /* long description */
	({ union { double f; size8u_t i; } _fipun; _fipun.f = (A); isnan(_fipun.f) ? 0xFFFFFFFFFFFFFFFFULL : _fipun.i; }),     /* behavior */
	(A_FPOP)
)

DEF_MACRO(
	fDFNANVAL,(),
	"NaN",
	"NaN",
	0xffffffffffffffffULL,
	()
)

DEF_MACRO(
	fDF_ISNORMAL,(X),
	"is_normal(X)",
	"is X normal?",
	(fpclassify(fDOUBLE(X)) == FP_NORMAL),
	()
)

DEF_MACRO(
	fDF_ISDENORM,(X),
	"is_denormal(X)",
	"is X denormal?",
	(fpclassify(fDOUBLE(X)) == FP_SUBNORMAL),
	()
)

DEF_MACRO(
	fDF_ISBIG,(X),
	"(df_exponent(X) >= 512)",
	"is X sufficiently large for mpyfix (exp >= 512)?",
	(fDF_GETEXP(X) >= 512),
	()
)

DEF_MACRO(
	fDF_MANTBITS,(),
	"52",
	"single mantissa bits",
	52,
	()
)

DEF_MACRO(
	fDF_GETEXP,(A),
	"exponent(A)",
	"exponent(A)",
	(((A) >> fDF_MANTBITS()) & 0x7ff),
	()
)

DEF_MACRO(
	fFMA, (A,B,C),
	"fma(A,B,C)",
	"Fused Multiply Add: A*B+C",
	internal_fma(A,B,C),
	/* nothing */
)

DEF_MACRO(
	fDF_MPY_HH, (A,B,ACC),
	"A*B with partial product ACC",
	"Multiply: A*B with partial product ACC",
	internal_mpyhh(A,B,ACC),
	/* nothing */
)

DEF_MACRO(
	fFPOP_START,
	(),
	"fpop_start",
	"Begin floating point operation",
	arch_fpop_start(thread),
	/* nothing */
)

DEF_MACRO(
	fFPOP_END,
	(),
	"fpop_end",
	"End floating point operation",
	arch_fpop_end(thread),
	/* nothing */
)

DEF_MACRO(
	fFPSETROUND_NEAREST,
	(),
	"round_to_nearest()",
	"Set rounding mode to Nearest",
	fesetround(FE_TONEAREST),
	/* nothing */
)

DEF_MACRO(
	fFPSETROUND_CHOP,
	(),
	"round_to_zero()",
	"Set rounding mode to Chop",
	fesetround(FE_TOWARDZERO),
	/* nothing */
)

DEF_MACRO(
	fFPCANCELFLAGS,
	(),
	"cancel_flags()",
	"Do not update Floating Point Flags",
	feclearexcept(FE_ALL_EXCEPT),
	/* nothing */
)

DEF_MACRO(
	fISINFPROD,
	(A,B),
	"isinf(A*B)",
	"True if the product of A and B is truly infinite",
	((isinf(A) && isinf(B)) ||
		(isinf(A) && isfinite(B) && ((B) != 0.0)) ||
		(isinf(B) && isfinite(A) && ((A) != 0.0))),
	/* nothing */
)

DEF_MACRO(
	fISZEROPROD,
	(A,B),
	"is_true_zero(A*B)",
	"True if the product of A and B is truly zero",
	((((A) == 0.0) && isfinite(B)) || (((B) == 0.0) && isfinite(A))),
	/* nothing */
)

DEF_MACRO(
	fRAISEFLAGS,
	(A),
	"fpflags |= A",
	"Raise Floating Point Flags",
	arch_raise_fpflag(A),
	/* NOTHING */
)

DEF_MACRO(
	fDF_MAX,
	(A,B),
	"fmax(A,B)",
	"Floating Point Maximum",
	(((A)==(B))
		? fDOUBLE(fUNDOUBLE(A) & fUNDOUBLE(B))
		: fmax(A,B)),
	(A_FPOP)
)

DEF_MACRO(
	fDF_MIN,
	(A,B),
	"fmin(A,B)",
	"Floating Point Maximum",
	(((A)==(B))
		? fDOUBLE(fUNDOUBLE(A) | fUNDOUBLE(B))
		: fmin(A,B)),
	(A_FPOP)
)

DEF_MACRO(
	fSF_MAX,
	(A,B),
	"fmaxf(A,B)",
	"Floating Point Maximum",
	(((A)==(B))
		? fFLOAT(fUNFLOAT(A) & fUNFLOAT(B))
		: fmaxf(A,B)),
	(A_FPOP)
)

DEF_MACRO(
	fSF_MIN,
	(A,B),
	"fmin(A,B)",
	"Floating Point Maximum",
	(((A)==(B))
		? fFLOAT(fUNFLOAT(A) | fUNFLOAT(B))
		: fminf(A,B)),
	(A_FPOP)
)

/*************************************/
/* Load/Store support                */
/*************************************/

DEF_MACRO(fLOAD,(NUM,SIZE,SIGN,EA,DST),
	"DST = *EA",
	"Get SIZE bytes from memory at EA and save in DST.",
	{ DST = (size##SIZE##SIGN##_t)MEM_LOAD##SIZE(thread,EA,insn); },
	(A_LOAD,A_MEMLIKE)
)

DEF_MACRO(fMEMOP,(NUM,SIZE,SIGN,EA,FNTYPE,VALUE),
	"DST = *EA",
	"Get SIZE bytes from memory at EA and save in DST.",
	{ memop##SIZE##_##FNTYPE(thread,EA,VALUE); },
	(A_LOAD,A_STORE,A_MEMLIKE)
)

DEF_MACRO(fGET_FRAMEKEY,(),
	"FRAMEKEY",
	"FRAMEKEY",
	READ_RREG(REG_FRAMEKEY),
	()
)

DEF_MACRO(fFRAME_SCRAMBLE,(VAL),
	"frame_scramble(VAL)",
	"frame_scramble(VAL)",
	((VAL) ^ (fCAST8u(fGET_FRAMEKEY()) << 32)),
	/* ATTRIBS */
)

DEF_MACRO(fFRAME_UNSCRAMBLE,(VAL),
	"frame_unscramble(VAL)",
	"frame_unscramble(VAL)",
	fFRAME_SCRAMBLE(VAL),
	/* ATTRIBS */
)

DEF_MACRO(fFRAMECHECK,(ADDR,EA),
	"frame_check_limit(ADDR)",
	"frame_check_limit(ADDR)",
	sys_check_framelimit(thread,ADDR,EA),
	()
)

DEF_MACRO(fLOAD_LOCKED,(NUM,SIZE,SIGN,EA,DST),
	"DST = *EA; ",
	"Get SIZE bytes from memory at EA and save in DST.",
	{     DST = (size##SIZE##SIGN##_t)mem_load_locked(thread,EA,SIZE,insn);
  },
	(A_LOAD,A_MEMLIKE)
)

DEF_MACRO(fSTORE,(NUM,SIZE,EA,SRC),
	"*EA = SRC",
	"Store SIZE bytes from SRC into memory at EA",
	{ MEM_STORE##SIZE(thread,EA,SRC,insn); },
	(A_STORE,A_MEMLIKE)
)


DEF_MACRO(fSTORE_LOCKED,(NUM,SIZE,EA,SRC,PRED),
	"if (lock_valid) { *EA = SRC; PRED = 0xff; lock_valid = 0; } else { PRED = 0; }",
	"if the lock is valid, Store SIZE bytes from SRC into memory at EA, and invalidate the lock.  PRED is set to all 1s if the write actually took place.",
	{ PRED = (mem_store_conditional(thread,EA,SRC,SIZE,insn) ? 0xff : 0); },
	(A_STORE,A_MEMLIKE)
)

/*************************************/
/* Functions to help with bytes      */
/*************************************/

DEF_MACRO(fGETBYTE,(N,SRC),
	"SRC.b[N]",
	"Byte N from SRC",
         ((size1s_t)((SRC>>((N)*8))&0xff)),
	/* nothing */
)

DEF_MACRO(fGETUBYTE,(N,SRC),
	"SRC.ub[N]",
	"Byte N from SRC",
         ((size1u_t)((SRC>>((N)*8))&0xff)),
	/* nothing */
)

DEF_MACRO(fSETBYTE,(N,DST,VAL),
	"DST.b[N]=VAL",
	"Byte N from DST = VAL",
	{
	DST = (DST & ~(0x0ffLL<<((N)*8))) | (((size8u_t)((VAL) & 0x0ffLL)) << ((N)*8));
	},
	/* nothing */
)

DEF_MACRO(fGETHALF,(N,SRC),
	"SRC.h[N]",
	"Halfword N from SRC",
         ((size2s_t)((SRC>>((N)*16))&0xffff)),
	/* nothing */
)

DEF_MACRO(fGETUHALF,(N,SRC),
	"SRC.uh[N]",
	"Halfword N from SRC",
         ((size2u_t)((SRC>>((N)*16))&0xffff)),
	/* nothing */
)

DEF_MACRO(fSETHALF,(N,DST,VAL),
	"DST.h[N]=VAL",
	"Halfword N from DST = VAL",
	{
	DST = (DST & ~(0x0ffffLL<<((N)*16))) | (((size8u_t)((VAL) & 0x0ffff)) << ((N)*16));
	},
	/* nothing */
)



DEF_MACRO(fGETWORD,(N,SRC),
	"SRC.w[N]",
	"Word N from SRC",
         ((size8s_t)((size4s_t)((SRC>>((N)*32))&0x0ffffffffLL))),
	/* nothing */
)

DEF_MACRO(fGETUWORD,(N,SRC),
	"SRC.uw[N]",
	"Word N from SRC",
         ((size8u_t)((size4u_t)((SRC>>((N)*32))&0x0ffffffffLL))),
	/* nothing */
)

DEF_MACRO(fSETWORD,(N,DST,VAL),
	"DST.w[N]=VAL",
	"Word N from DST = VAL",
	{
	DST = (DST & ~(0x0ffffffffLL<<((N)*32))) | (((VAL) & 0x0ffffffffLL) << ((N)*32));
	},
	/* nothing */
)

DEF_MACRO(fSETBIT,(N,DST,VAL),
	"DST.N = VAL",
	"Set bit N in DST to VAL",
	{
	DST = (DST & ~(1ULL<<(N))) | (((size8u_t)(VAL))<<(N));
	},
	/* nothing */
)

DEF_MACRO(fGETBIT,(N,SRC),
	"SRC.N",
	"Get bit N from SRC",
	(((SRC)>>N)&1),
	/* nothing */
)


DEF_MACRO(fSETBITS,(HI,LO,DST,VAL),
	"DST[HI:LO] = VAL",
	"Set bits from HI to LO in DST to VAL",
	do {
        int j;
        for (j=LO;j<=HI;j++) {
          fSETBIT(j,DST,VAL);
        }
	} while (0),
	/* nothing */
)

/*************************************/
/* Used for parity, etc........      */
/*************************************/
DEF_MACRO(fCOUNTONES_4,(VAL),
	"count_ones(VAL)",
	"Count the number of bits set in VAL",
	count_ones_4(VAL),
	/* nothing */
)

DEF_MACRO(fCOUNTONES_8,(VAL),
	"count_ones(VAL)",
	"Count the number of bits set in VAL",
	count_ones_8(VAL),
	/* nothing */
)

DEF_MACRO(fBREV_8,(VAL),
	"reverse_bits(VAL)",
	"Count the number of bits set in VAL",
	reverse_bits_8(VAL),
	/* nothing */
)

DEF_MACRO(fBREV_4,(VAL),
	"reverse_bits(VAL)",
	"Count the number of bits set in VAL",
	reverse_bits_4(VAL),
	/* nothing */
)

DEF_MACRO(fCL1_8,(VAL),
	"count_leading_ones(VAL)",
	"Count the number of bits set in VAL",
	count_leading_ones_8(VAL),
	/* nothing */
)

DEF_MACRO(fCL1_4,(VAL),
	"count_leading_ones(VAL)",
	"Count the number of bits set in VAL",
	count_leading_ones_4(VAL),
	/* nothing */
)

DEF_MACRO(fINTERLEAVE,(ODD,EVEN),
	"interleave(ODD,EVEN)",
	"Interleave odd bits from ODD with even bits from EVEN",
	interleave(ODD,EVEN),
	/* nothing */
)

DEF_MACRO(fDEINTERLEAVE,(MIXED),
	"deinterleave(ODD,EVEN)",
	"Deinterleave odd bits into high half even bits to low half",
	deinterleave(MIXED),
	/* nothing */
)

DEF_MACRO(fHIDE,(A),
	"",
	"",
	A,
	()
)

DEF_MACRO(fCONSTLL,(A),
	"A",
	"A",
	A##LL,
)

/* Do the things in the parens, but don't print the parens. */
DEF_MACRO(fECHO,(A),
	"A",
	"A",
	(A),
	/* nothing */
)


/********************************************/
/* OS interface and stop/wait               */
/********************************************/

/* The way it should be */
DEF_MACRO(fTRAP,(TRAPTYPE,IMM),
	"SSR.CAUSE = IMM; TRAP # TRAPTYPE",
	"SSR.CAUSE = IMM; TRAP # TRAPTYPE",
    warn("Trap NPC=%x ",fREAD_NPC());
	warn("Trap exception, PCYCLE=%lld TYPE=%d NPC=%x IMM=0x%x",thread->processor_ptr->pstats[pcycles],TRAPTYPE,fREAD_NPC(),IMM);
	register_trap_exception(thread,fREAD_NPC(),TRAPTYPE,IMM);,
	()
)

DEF_MACRO(fALIGN_REG_FIELD_VALUE,(FIELD,VAL),
	"VAL << FIELD.OFFSET",
	"VAL << FIELD.OFFSET",
	((VAL)<<reg_field_info[FIELD].offset),
	/* */
)

DEF_MACRO(fGET_REG_FIELD_MASK,(FIELD),
	"VAL << FIELD.OFFSET",
	"VAL << FIELD.OFFSET",
	(((1<<reg_field_info[FIELD].width)-1)<<reg_field_info[FIELD].offset),
	/* */
)

DEF_MACRO(fREAD_REG_FIELD,(REG,FIELD),
	"REG.FIELD",
	"REG.FIELD",
	fEXTRACTU_BITS(thread->Regs[REG_##REG],
            reg_field_info[FIELD].width,
            reg_field_info[FIELD].offset),
	/* ATTRIBS */
)

DEF_MACRO(fGET_FIELD,(VAL,FIELD),
	"VAL.FIELD",
	"VAL.FIELD",
	fEXTRACTU_BITS(VAL,
		reg_field_info[FIELD].width,
		reg_field_info[FIELD].offset),
	/* ATTRIBS */
)

DEF_MACRO(fSET_FIELD,(VAL,FIELD,NEWVAL),
	"VAL.FIELD",
	"VAL.FIELD",
	fINSERT_BITS(VAL,
		reg_field_info[FIELD].width,
		reg_field_info[FIELD].offset,
		(NEWVAL)),
	/* ATTRIBS */
)

/********************************************/
/* Cache Management                         */
/********************************************/

DEF_MACRO(fBARRIER,(),
	"memory_barrier",
	"memory_barrier",
     {
        sys_barrier(thread, insn->slot);
     },
	()
)

DEF_MACRO(fSYNCH,(),
	"memory_synch",
	"memory_synch",
  {
      sys_sync(thread, insn->slot);
  },
	()
)

DEF_MACRO(fISYNC,(),
	"instruction_sync",
	"instruction_sync",
  {
      sys_isync(thread, insn->slot);
  },
	()
)


DEF_MACRO(fDCFETCH,(REG),
	"dcache_fetch(REG)",
	"dcache_fetch(REG)",
	sys_dcfetch(thread, (REG), insn->slot),
	(A_MEMLIKE)
)

DEF_MACRO(fICINVA,(REG),
	"icache_inv_addr(REG)",
	"icache_inv_addr(REG)",
	{
	arch_internal_flush(thread->processor_ptr, 0, 0xffffffff);
	sys_icinva(thread, (REG),insn->slot);
	},
	(A_ICINVA)
)

DEF_MACRO(fL2FETCH,(ADDR,HEIGHT,WIDTH,STRIDE,FLAGS),
	"l2fetch(ADDR,INFO)",
	"l2fetch(ADDR,INFO)",
	sys_l2fetch(thread, ADDR,HEIGHT,WIDTH,STRIDE,FLAGS, insn->slot),
	(A_MEMLIKE,A_L2FETCH)
)

DEF_MACRO(fDCCLEANA,(REG),
	"dcache_clean_addr(REG)",
	"dcache_clean_addr(REG)",
	sys_dccleana(thread, (REG)),
	(A_MEMLIKE)
)

DEF_MACRO(fDCCLEANINVA,(REG),
	"dcache_cleaninv_addr(REG)",
	"dcache_cleaninv_addr(REG)",
	sys_dccleaninva(thread, (REG), insn->slot),
	(A_MEMLIKE,A_DCCLEANINVA)
)

DEF_MACRO(fDCZEROA,(REG),
	"dcache_zero_addr(REG)",
	"dcache_zero_addr(REG)",
	sys_dczeroa(thread, (REG)),
	(A_MEMLIKE)
)

DEF_MACRO(fCHECKFORPRIV,(),
	"priv_check();",
	"priv_check();",
	{sys_check_privs(thread); if (EXCEPTION_DETECTED) return; },
	()
)

DEF_MACRO(fCHECKFORGUEST,(),
	"priv_check();",
	"priv_check();",
	{sys_check_guest(thread); if (EXCEPTION_DETECTED) return; },
	()
)

DEF_MACRO(fBRANCH_SPECULATE_STALL,(DOTNEWVAL, JUMP_COND, SPEC_DIR, HINTBITNUM, STRBITNUM),
	"",
	"Check the .new predicate and stall if wrongly speculated.",
	{
sys_speculate_branch_stall(thread, insn->slot, JUMP_COND(JUMP_PRED_SET),
										   SPEC_DIR,
										   DOTNEWVAL,
										   HINTBITNUM,
										   STRBITNUM,
										   0,
										   thread->last_pkt->pkt_has_dual_jump,
										   insn->is_2nd_jump,
										   (thread->fetch_access.vaddr + insn->encoding_offset*4));
  },
	()
)
