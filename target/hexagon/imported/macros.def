/*
 *  Copyright(c) 2019-2020 Qualcomm Innovation Center, Inc. All Rights Reserved.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

DEF_MACRO(
	LIKELY,		/* NAME */
	__builtin_expect((X),1), /* BEH */
	()		/* attribs */
)

DEF_MACRO(
	UNLIKELY,	/* NAME */
	__builtin_expect((X),0), /* BEH */
	()		/* attribs */
)

DEF_MACRO(
	CANCEL, /* macro name */
	{if (thread->last_pkt) thread->last_pkt->slot_cancelled |= (1<<insn->slot); return;} , /* behavior */
	(A_CONDEXEC)
)

DEF_MACRO(
	STORE_ZERO, /* macro name */
	{if (thread->last_pkt) thread->last_pkt->slot_zero_byte_store |= (1<<insn->slot); } , /* behavior */
	(A_CONDEXEC)
)

DEF_MACRO(
	LOAD_CANCEL, /* macro name */
	{mem_general_load_cancelled(thread,EA,insn);CANCEL;} , /* behavior */
	(A_CONDEXEC)
)

DEF_MACRO(
	STORE_CANCEL, /* macro name */
	{mem_general_store_cancelled(thread,EA,insn);CANCEL;} , /* behavior */
	(A_CONDEXEC)
)

DEF_MACRO(
	IS_CANCELLED, /* macro name */
	((thread->last_pkt->slot_cancelled >> SLOT)&1) , /* behavior */
	/* attrib */
)

DEF_MACRO(
	fMAX, /* macro name */
	(((A) > (B)) ? (A) : (B)), /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fMIN, /* macro name */
	(((A) < (B)) ? (A) : (B)), /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fABS, /* macro name */
	(((A)<0)?(-(A)):(A)), /* behavior */
	/* optional attributes */
)


/* Bit insert */
DEF_MACRO(
	fINSERT_BITS,
        {
	   REG = ((REG) & ~(((fCONSTLL(1)<<(WIDTH))-1)<<(OFFSET))) | (((INVAL) & ((fCONSTLL(1)<<(WIDTH))-1)) << (OFFSET));
        },
	/* attribs */
)

/* Bit extract */
DEF_MACRO(
	fEXTRACTU_BITS,
	(fZXTN(WIDTH,32,(INREG >> OFFSET))),
	/* attribs */
)

DEF_MACRO(
	fEXTRACTU_BIDIR,
	(fZXTN(WIDTH,32,fBIDIR_LSHIFTR((INREG),(OFFSET),4_8))),
	/* attribs */
)

DEF_MACRO(
	fEXTRACTU_RANGE,
	(fZXTN((HIBIT-LOWBIT+1),32,(INREG >> LOWBIT))),
	/* attribs */
)


DEF_MACRO(
	fINSERT_RANGE,
        {
          int offset=LOWBIT;
          int width=HIBIT-LOWBIT+1;
  	  /* clear bits where new bits go */
	  INREG &= ~(((fCONSTLL(1)<<width)-1)<<offset);
	  /* OR in new bits */
	  INREG |= ((INVAL & ((fCONSTLL(1)<<width)-1)) << offset);
        },
	/* attribs */
)


DEF_MACRO(
	f8BITSOF,
	( (VAL) ? 0xff : 0x00),
	/* attribs */
)

DEF_MACRO(
	fLSBOLD,
	((VAL) & 1),
	(A_DOTOLD)
)

DEF_MACRO(
	fLSBNEW,
	predlog_read(thread,PNUM),
	(A_DOTNEW)
)

DEF_MACRO(
	fLSBNEW0,
	predlog_read(thread,0),
	(A_DOTNEW,A_IMPLICIT_READS_P0)
)

DEF_MACRO(
	fLSBNEW1,
	predlog_read(thread,1),
	(A_DOTNEW,A_IMPLICIT_READS_P1)
)

DEF_MACRO(
	fLSBOLDNOT,
	(!fLSBOLD(VAL)),
	(A_DOTOLD,A_INVPRED)
)

DEF_MACRO(
	fLSBNEWNOT,
	(!fLSBNEW(PNUM)),
	(A_DOTNEW,A_INVPRED)
)

DEF_MACRO(
	fLSBNEW0NOT,
	(!fLSBNEW0),
	(A_DOTNEW,A_INVPRED,A_IMPLICIT_READS_P0)
)

DEF_MACRO(
	fLSBNEW1NOT,
	(!fLSBNEW1),
	(A_DOTNEW,A_INVPRED,A_IMPLICIT_READS_P1)
)

DEF_MACRO(
	fNEWREG,
	({if (newvalue_missing(thread,RNUM) ||
      IS_CANCELLED(insn->new_value_producer_slot)) CANCEL; reglog_read(thread,RNUM);}),
	(A_DOTNEWVALUE,A_RESTRICT_SLOT0ONLY)
)
// Store new with a missing newvalue or cancelled goes out as a zero byte store in V65
// take advantage of the fact that reglog_read returns zero for not valid rnum
DEF_MACRO(
	fNEWREG_ST,
	({if (newvalue_missing(thread,RNUM) ||
      IS_CANCELLED(insn->new_value_producer_slot)) { STORE_ZERO; RNUM = -1; }; reglog_read(thread,RNUM);}),
	(A_DOTNEWVALUE,A_RESTRICT_SLOT0ONLY)
)

DEF_MACRO(
	fMEMZNEW,
	(RNUM == 0),
	/* attribs */
)

DEF_MACRO(
	fMEMNZNEW,
	(RNUM != 0),
	/* attribs */
)

DEF_MACRO(
	fVSATUVALN,
	({ ((VAL) < 0) ? 0 : ((1LL<<(N))-1);}),
	(A_USATURATE)
)

DEF_MACRO(
	fSATUVALN,
	({fSET_OVERFLOW(); ((VAL) < 0) ? 0 : ((1LL<<(N))-1);}),
	(A_USATURATE)
)

DEF_MACRO(
	fSATVALN,
	({fSET_OVERFLOW(); ((VAL) < 0) ? (-(1LL<<((N)-1))) : ((1LL<<((N)-1))-1);}),
	(A_SATURATE)
)

DEF_MACRO(
	fVSATVALN,
	({((VAL) < 0) ? (-(1LL<<((N)-1))) : ((1LL<<((N)-1))-1);}),
	(A_SATURATE)
)

DEF_MACRO(
	fZXTN, /* macro name */
	((VAL) & ((1LL<<(N))-1)),
	/* attribs */
)

DEF_MACRO(
	fSXTN, /* macro name */
	((fZXTN(N,M,VAL) ^ (1LL<<((N)-1))) - (1LL<<((N)-1))),
	/* attribs */
)

DEF_MACRO(
	fSATN,
	((fSXTN(N,64,VAL) == (VAL)) ? (VAL) : fSATVALN(N,VAL)),
	(A_SATURATE)
)
DEF_MACRO(
	fVSATN,
	((fSXTN(N,64,VAL) == (VAL)) ? (VAL) : fVSATVALN(N,VAL)),
	(A_SATURATE)
)

DEF_MACRO(
	fADDSAT64,
	{
	  size8u_t __a = fCAST8u(A);
	  size8u_t __b = fCAST8u(B);
	  size8u_t __sum = __a + __b;
	  size8u_t __xor = __a ^ __b;
	  const size8u_t __mask = 0x8000000000000000ULL;
	  if (__xor & __mask) {
		/* Opposite signs, OK */
		DST = __sum;
	  } else if ((__a ^ __sum) & __mask) {
		/* Signs mismatch */
		if (__sum & __mask) {
			/* overflowed to negative, make max pos */
			DST=0x7FFFFFFFFFFFFFFFLL; fSET_OVERFLOW();
		} else {
			/* overflowed to positive, make max neg */
			DST=0x8000000000000000LL; fSET_OVERFLOW();
		}
	  } else {
		/* signs did not mismatch, OK */
		DST = __sum;
	  }
        },
	(A_SATURATE)
)

DEF_MACRO(
	fVSATUN,
	({size8u_t tmp8=fZXTN(N,64,VAL);
      size4u_t tmp9=(tmp8==(VAL)) ? (VAL) : fVSATUVALN(N,VAL);
	  tmp9; }),
	(A_USATURATE)
)

DEF_MACRO(
	fSATUN,
	((fZXTN(N,64,VAL) == (VAL)) ? (VAL) : fSATUVALN(N,VAL)),
	(A_USATURATE)
)

DEF_MACRO(
	fSATH,
	(fSATN(16,VAL)),
	(A_SATURATE)
)


DEF_MACRO(
	fSATUH,
	(fSATUN(16,VAL)),
	(A_USATURATE)
)

DEF_MACRO(
	fVSATH,
	(fVSATN(16,VAL)),
	(A_SATURATE)
)

DEF_MACRO(
	fVSATUH,
	(fVSATUN(16,VAL)),
	(A_USATURATE)
)


DEF_MACRO(
	fSATUB,
	(fSATUN(8,VAL)),
	(A_USATURATE)
)
DEF_MACRO(
	fSATB,
	(fSATN(8,VAL)),
	(A_SATURATE)
)


DEF_MACRO(
	fVSATUB,
	(fVSATUN(8,VAL)),
	(A_USATURATE)
)
DEF_MACRO(
	fVSATB,
	(fVSATN(8,VAL)),
	(A_SATURATE)
)




/*************************************/
/* immediate extension               */
/*************************************/

DEF_MACRO(
	fIMMEXT,
	(IMM = IMM /* (insn->extension_valid?(fGET_EXTENSION | fZXTN(6,32,(IMM))):(IMM)) */ ),
	(A_EXTENDABLE)
)

DEF_MACRO(
	fMUST_IMMEXT,
	fIMMEXT,
	(A_EXTENDABLE,A_MUST_EXTEND)
)

DEF_MACRO(
	fPCALIGN,
	IMM=(IMM & ~PCALIGN_MASK),
	(A_EXTENDABLE)
)

DEF_MACRO(
	fGET_EXTENSION,
	insn->extension,
	/* attrs */
)

/*************************************/
/* Read and Write Implicit Regs      */
/*************************************/

DEF_MACRO(
	fVERIFICATION_REGWRITE_NOTE,
	/* NOTHING */,
	()
)



DEF_MACRO(
	fREAD_IREG, /* read link register */
	(fSXTN(11,64,(((VAL) & 0xf0000000)>>21) | ((VAL>>17)&0x7f) )),          /* behavior */
	()
)


DEF_MACRO(
	fREAD_R0, /* read r0 */
	(READ_RREG(0)),          /* behavior */
	(A_IMPLICIT_READS_R00)
)

DEF_MACRO(
	fREAD_LR, /* read link register */
	(READ_RREG(REG_LR)),          /* behavior */
	(A_IMPLICIT_READS_LR)
)

DEF_MACRO(
	fREAD_SSR, /* read link register */
	(READ_RREG(REG_SSR)),          /* behavior */
	()
)

DEF_MACRO(
	fWRITE_R0, /* write r0 */
	fVERIF_MARK_RREG_ACCESS(0,'-',1,A); WRITE_RREG(0,A),          /* behavior */
	(A_IMPLICIT_WRITES_R00)
)

DEF_MACRO(
	fWRITE_LR, /* write lr */
	fVERIF_MARK_RREG_ACCESS(REG_LR,'-',1,A); WRITE_RREG(REG_LR,A),          /* behavior */
	(A_IMPLICIT_WRITES_LR)
)

DEF_MACRO(
	fWRITE_FP, /* write sp */
	fVERIF_MARK_RREG_ACCESS(REG_FP,'-',1,A); WRITE_RREG(REG_FP,A),          /* behavior */
	(A_IMPLICIT_WRITES_FP)
)

DEF_MACRO(
	fWRITE_SP, /* write sp */
	fVERIF_MARK_RREG_ACCESS(REG_SP,'-',1,A); WRITE_RREG(REG_SP,A),          /* behavior */
	(A_IMPLICIT_WRITES_SP)
)

DEF_MACRO(
	fWRITE_GOSP, /* write gosp */
	fVERIF_MARK_RREG_ACCESS(REG_GOSP,'-',1,A); WRITE_RREG(REG_GOSP,A),          /* behavior */
	(A_IMPLICIT_WRITES_GOSP)
)

DEF_MACRO(
	fWRITE_GP, /* write gp */
	WRITE_RREG(REG_GP,A),          /* behavior */
	(A_IMPLICIT_WRITES_GP)
)

DEF_MACRO(
	fREAD_SP, /* read stack pointer */
	(READ_RREG(REG_SP)),          /* behavior */
	(A_IMPLICIT_READS_SP)
)

DEF_MACRO(
	fREAD_GOSP, /* read guest other stack pointer */
	(READ_RREG(REG_GOSP)),          /* behavior */
	(A_IMPLICIT_READS_GOSP)
)

DEF_MACRO(
	fREAD_GELR, /* read guest other stack pointer */
	(READ_RREG(REG_GELR)),          /* behavior */
	(A_IMPLICIT_READS_GELR)
)

DEF_MACRO(
	fREAD_GEVB, /* read guest other stack pointer */
	(READ_RREG(REG_GEVB)),          /* behavior */
	(A_IMPLICIT_READS_GEVB)
)

DEF_MACRO(
	fREAD_CSREG, /* read stack pointer */
	(READ_RREG(REG_CSA+N)),          /* behavior */
	(A_IMPLICIT_READS_CS)
)

DEF_MACRO(
	fREAD_LC0, /* read loop count */
	(READ_RREG(REG_LC0)),          /* behavior */
	(A_IMPLICIT_READS_LC0)
)

DEF_MACRO(
	fREAD_LC1, /* read loop count */
	(READ_RREG(REG_LC1)),          /* behavior */
	(A_IMPLICIT_READS_LC1)
)

DEF_MACRO(
	fREAD_SA0, /* read start addr */
	(READ_RREG(REG_SA0)),          /* behavior */
	(A_IMPLICIT_READS_SA0)
)

DEF_MACRO(
	fREAD_SA1, /* read start addr */
	(READ_RREG(REG_SA1)),          /* behavior */
	(A_IMPLICIT_READS_SA1)
)


DEF_MACRO(
	fREAD_FP, /* read stack pointer */
	(READ_RREG(REG_FP)),          /* behavior */
	(A_IMPLICIT_READS_FP)
)

DEF_MACRO(
	fREAD_GP, /* read global pointer */
	(insn->extension_valid ? 0 : READ_RREG(REG_GP)),          /* behavior */
	(A_IMPLICIT_READS_GP)
)

DEF_MACRO(
	fREAD_PC, /* read PC */
	(READ_RREG(REG_PC)),          /* behavior */
	(A_IMPLICIT_READS_PC)
)

DEF_MACRO(
	fREAD_NPC, /* read PC */
	(thread->next_PC & (0xfffffffe)),          /* behavior */
	()
)

DEF_MACRO(
	fREAD_P0, /* read Predicate 0 */
	(READ_PREG(0)),          /* behavior */
	(A_IMPLICIT_READS_P0)
)

DEF_MACRO(
	fREAD_P3, /* read Predicate 0 */
	(READ_PREG(3)),          /* behavior */
	(A_IMPLICIT_READS_P3)
)

DEF_MACRO(
	fNOATTRIB_READ_P3, /* read Predicate 0 */
	(READ_PREG(3)),          /* behavior */
	()
)

DEF_MACRO(
	fINVALID,
	(register_error_exception(thread,PRECISE_CAUSE_INVALID_PACKET,thread->Regs[REG_BADVA0],thread->Regs[REG_BADVA1],GET_SSR_FIELD(SSR_BVS),GET_SSR_FIELD(SSR_V0),GET_SSR_FIELD(SSR_V1),0)),
	()
)

DEF_MACRO(
	fCHECK_PCALIGN,
	/* EJP: if exception already detected, do not trigger pc unaligned exception since we will be rewinding PC anyway. */
	/* Maybe this will screw up prioritization logic... but probably it is ok?  Otherwise we can ditch out of dealloc_return early if EXCEPTION_DETECTED */
	if (((A) & PCALIGN_MASK)) {
		register_error_exception(thread,PRECISE_CAUSE_PC_NOT_ALIGNED,thread->Regs[REG_BADVA0],thread->Regs[REG_BADVA1],GET_SSR_FIELD(SSR_BVS),GET_SSR_FIELD(SSR_V0),GET_SSR_FIELD(SSR_V1),0);
	},
	()
)

DEF_MACRO(
	fCUREXT,
	GET_SSR_FIELD(SSR_XA),
	()
)

DEF_MACRO(
	fEXT_WRAP,
	{
		if (get_ext_contexts(thread->processor_ptr))
			EXT_NO &= (get_ext_contexts(thread->processor_ptr)-1);
		else
			EXT_NO = 0;
		EXT_NO = thread->processor_ptr->arch_proc_options->QDSP6_CP_PRESENT ? (EXT_NO & 0x3) : (EXT_NO+4);
	},
	()
)

DEF_MACRO(
	fCUREXT_WRAP,
	{
		EXT_NO = fCUREXT();
		fEXT_WRAP(EXT_NO);
	},
	()
)


DEF_MACRO(
	fWRITE_NPC, /* write next PC */
	if (!thread->branch_taken) {
           if (A != thread->next_PC) {
             thread->next_pkt_guess=thread->last_pkt->taken_ptr;
           }
	   fCHECK_PCALIGN(A);
           thread->branched = 1; thread->branch_taken = 1; thread->next_PC = A; \
           thread->branch_offset = insn->encoding_offset; thread->branch_opcode = insn->opcode;
        }
         ,          /* behavior */
	(A_IMPLICIT_WRITES_PC,A_COF)
)


DEF_MACRO(
	fLOOPSTATS,
	/* INC_TSTAT(tloopends);
  	   INC_TSTATN(tloopend_same_line,(thread->Regs[REG_PC] & -32) == ((A) & -32));
	   INC_TSTATN(tloopend_samepc,(thread->Regs[REG_PC]) == (A));*/ ,
	()
)


DEF_MACRO(
	fCOF_CALLBACK,
  {
// This might be same to always use, not just verif
    thread->cof_log_to_va = (LOC);
    thread->cof_log_coftype = (TYPE);
    thread->cof_log_valid = 1;
  },
	()
)

DEF_MACRO(
	fBRANCH,
	fWRITE_NPC(LOC); fCOF_CALLBACK(LOC,TYPE),
	()
)

DEF_MACRO(
	fTIME_JUMPR,
#if 0
	if (thread->timing_on) {be_log_ret(thread->processor_ptr,thread->threadId,TARGET,REGNO); } ,
#else
	{ sys_branch_return(thread, insn->slot, TARGET, REGNO); },
#endif
	(A_INDIRECT)
)


DEF_MACRO(
	fJUMPR,	/* A jumpr has executed */
	{ fTIME_JUMPR(REGNO,TARGET,TYPE); fBRANCH(TARGET,COF_TYPE_JUMPR);},
	(A_INDIRECT)
)

DEF_MACRO(
	fHINTJR,	/* A hintjr instruction has executed */
	{ sys_hintjr(thread, insn->slot, TARGET); },
)

DEF_MACRO(
	fBP_RAS_CALL,
#if 0
	do { if (thread->timing_on) be_log_call(thread->processor_ptr,thread->threadId,A,fREAD_NPC()); } while (0),
#else
	{ sys_branch_call(thread, insn->slot, A, fREAD_NPC()); },
#endif
)

DEF_MACRO(
	fCALL,	/* Do a call */
	if (!thread->branch_taken) {fBP_RAS_CALL(A); fWRITE_LR(fREAD_NPC()); fBRANCH(A,COF_TYPE_CALL);},
	(A_IMPLICIT_WRITES_PC,A_COF,A_IMPLICIT_WRITES_LR,A_CALL)
)

DEF_MACRO(
	fCALLR,	/* Do a call Register */
	if (!thread->branch_taken) {fBP_RAS_CALL(A); fWRITE_LR(fREAD_NPC()); fBRANCH(A,COF_TYPE_CALLR);},
	(A_IMPLICIT_WRITES_PC,A_COF,A_IMPLICIT_WRITES_LR,A_CALL)
)

DEF_MACRO(
	fWRITE_LOOP_REGS0, /* write ln,sa,ea,lc */
	{WRITE_RREG(REG_LC0,COUNT);
         WRITE_RREG(REG_SA0,START);},
	(A_IMPLICIT_WRITES_LC0,A_IMPLICIT_WRITES_SA0)
)

DEF_MACRO(
	fWRITE_LOOP_REGS1, /* write ln,sa,ea,lc */
	{WRITE_RREG(REG_LC1,COUNT);
         WRITE_RREG(REG_SA1,START);},
	(A_IMPLICIT_WRITES_LC1,A_IMPLICIT_WRITES_SA1)
)

DEF_MACRO(
	fWRITE_LC0,
	WRITE_RREG(REG_LC0,VAL),
	(A_IMPLICIT_WRITES_LC0)
)

DEF_MACRO(
	fWRITE_LC1,
	WRITE_RREG(REG_LC1,VAL),
	(A_IMPLICIT_WRITES_LC1)
)

DEF_MACRO(
	fCARRY_FROM_ADD,
	carry_from_add64(A,B,C),
	/* NOTHING */
)

DEF_MACRO(
	fSETCV_ADD,
	do {
		SET_USR_FIELD(USR_C,gen_carry_add((A),(B),((A)+(B))));
		SET_USR_FIELD(USR_V,gen_overflow_add((A),(B),((A)+(B))));
	} while (0),
	(A_IMPLICIT_WRITES_CVBITS,A_NOTE_CVFLAGS,A_RESTRICT_NOSRMOVE)
)
DEF_MACRO(
	fSETCV_SUB,
	do {
		SET_USR_FIELD(USR_C,gen_carry_add((A),(B),((A)-(B))));
		SET_USR_FIELD(USR_V,gen_overflow_add((A),(B),((A)-(B))));
	} while (0),
	(A_IMPLICIT_WRITES_CVBITS,A_NOTE_CVFLAGS,A_RESTRICT_NOSRMOVE)
)

DEF_MACRO(
	fSET_OVERFLOW,
	SET_USR_FIELD(USR_OVF,1),
	(A_IMPLICIT_WRITES_SRBIT,A_NOTE_SR_OVF_WHEN_SATURATING,A_RESTRICT_NOSRMOVE)
)

DEF_MACRO(
	fSET_LPCFG,
	SET_USR_FIELD(USR_LPCFG,(VAL)),
	(A_IMPLICIT_WRITES_LPCFG,A_RESTRICT_NOSRMOVE)
)


DEF_MACRO(
	fGET_LPCFG,
	(GET_USR_FIELD(USR_LPCFG)),
	()
)



DEF_MACRO(
	fWRITE_P0, /* write Predicate 0 */
	WRITE_PREG(0,VAL),          /* behavior */
	(A_IMPLICIT_WRITES_P0)
)

DEF_MACRO(
	fWRITE_P1, /* write Predicate 0 */
	WRITE_PREG(1,VAL),          /* behavior */
	(A_IMPLICIT_WRITES_P1)
)

DEF_MACRO(
	fWRITE_P2, /* write Predicate 0 */
	WRITE_PREG(2,VAL),          /* behavior */
	(A_IMPLICIT_WRITES_P2)
)

DEF_MACRO(
	fWRITE_P3, /* write Predicate 0 */
	WRITE_PREG(3,VAL),     /* behavior */
	(A_IMPLICIT_WRITES_P3)
)

DEF_MACRO(
	fWRITE_P3_LATE, /* write Predicate 0 */
	{WRITE_PREG(3,VAL); fHIDE(MARK_LATE_PRED_WRITE(3))} ,          /* behavior */
	(A_IMPLICIT_WRITES_P3,A_RESTRICT_LATEPRED)
)


DEF_MACRO(
	fPART1, /* write Predicate 0 */
	if (insn->part1) { WORK; return; },          /* behavior */
	/* optional attributes */
)


/*************************************/
/* Casting, Sign-Zero extension, etc */
/*************************************/

DEF_MACRO(
	fCAST4u, /* macro name */
	((size4u_t)(A)),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fCAST4s, /* macro name */
	((size4s_t)(A)),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fCAST8u, /* macro name */
	((size8u_t)(A)),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fCAST8s, /* macro name */
	((size8s_t)(A)),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fCAST2_2s, /* macro name */
	((size2s_t)(A)),
	/* optional attributes */
)

DEF_MACRO(
	fCAST2_2u, /* macro name */
	((size2u_t)(A)),
	/* optional attributes */
)

DEF_MACRO(
	fCAST4_4s, /* macro name */
	((size4s_t)(A)),
	/* optional attributes */
)

DEF_MACRO(
	fCAST4_4u, /* macro name */
	((size4u_t)(A)),
	/* optional attributes */
)


DEF_MACRO(
	fCAST4_8s, /* macro name */
	((size8s_t)((size4s_t)(A))),
	/* optional attributes */
)

DEF_MACRO(
	fCAST4_8u, /* macro name */
	((size8u_t)((size4u_t)(A))),
	/* optional attributes */
)

DEF_MACRO(
	fCAST8_8s, /* macro name */
	((size8s_t)(A)),
	/* optional attributes */
)

DEF_MACRO(
	fCAST8_8u, /* macro name */
	((size8u_t)(A)),
	/* optional attributes */
)

DEF_MACRO(
	fCAST2_8s, /* macro name */
	((size8s_t)((size2s_t)(A))),
	/* optional attributes */
)

DEF_MACRO(
	fCAST2_8u, /* macro name */
	((size8u_t)((size2u_t)(A))),
	/* optional attributes */
)

#if 0
DEF_MACRO(
	fCAST5u, /* macro name */
	fZXTN(40,64,((size8u_t)(A))),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fCAST5s, /* macro name */
	fSXTN(40,((size8s_t)(A))),          /* behavior */
	/* optional attributes */
)
#endif

DEF_MACRO(
	fZE8_16, /* zero-extend 8 to 16 */
	((size2s_t)((size1u_t)(A))),
	/* optional attributes */
)
DEF_MACRO(
	fSE8_16, /* sign-extend 8 to 16 */
	((size2s_t)((size1s_t)(A))),
	/* optional attributes */
)


DEF_MACRO(
	fSE16_32, /* sign-extend 16 to 32 */
	((size4s_t)((size2s_t)(A))),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fZE16_32, /* zero-extend 16 to 32 */
	((size4u_t)((size2u_t)(A))),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fSE32_64,
	( (size8s_t)((size4s_t)(A)) ),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fSE64_128,
	( (size16s_t) cast8s_to_16s((size8s_t)A)),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fZE32_64,
	( (size8u_t)((size4u_t)(A)) ),          /* behavior */
	/* optional attributes */
)

DEF_MACRO(
	fSE8_32, /* sign-extend 8 to 32 */
	((size4s_t)((size1s_t)(A))),
	/* optional attributes */
)

DEF_MACRO(
	fZE8_32, /* zero-extend 8 to 32 */
	((size4s_t)((size1u_t)(A))),
	/* optional attributes */
)

/*************************************/
/* DSP arithmetic support            */
/************************************/
DEF_MACRO(
	fMPY8UU, /* multiply half integer */
	(int)(fZE8_16(A)*fZE8_16(B)),     /* behavior */
	(A_MPY)
)
DEF_MACRO(
	fMPY8US, /* multiply half integer */
	(int)(fZE8_16(A)*fSE8_16(B)),     /* behavior */
	(A_MPY)
)
DEF_MACRO(
	fMPY8SU, /* multiply half integer */
	(int)(fSE8_16(A)*fZE8_16(B)),     /* behavior */
	(A_MPY)
)

DEF_MACRO(
	fMPY8SS, /* multiply half integer */
	(int)((short)(A)*(short)(B)),     /* behavior */
	(A_MPY)
)

DEF_MACRO(
	fMPY16SS, /* multiply half integer */
	fSE32_64(fSE16_32(A)*fSE16_32(B)),     /* behavior */
	(A_MPY)
)

DEF_MACRO(
	fMPY16UU, /* multiply unsigned half integer */
	fZE32_64(fZE16_32(A)*fZE16_32(B)),     /* behavior */
	(A_MPY)
)

DEF_MACRO(
	fMPY16SU, /* multiply half integer */
	fSE32_64(fSE16_32(A)*fZE16_32(B)),     /* behavior */
	(A_MPY)
)

DEF_MACRO(
	fMPY16US, /* multiply half integer */
	fMPY16SU(B,A),
	(A_MPY)
)

DEF_MACRO(
	fMPY32SS, /* multiply half integer */
	(fSE32_64(A)*fSE32_64(B)),     /* behavior */
	(A_MPY)
)

DEF_MACRO(
	fMPY32UU, /* multiply half integer */
	(fZE32_64(A)*fZE32_64(B)),     /* behavior */
	(A_MPY)
)

DEF_MACRO(
	fMPY32SU, /* multiply half integer */
	(fSE32_64(A)*fZE32_64(B)),     /* behavior */
	(A_MPY)
)

DEF_MACRO(
	fMPY3216SS, /* multiply mixed precision */
	(fSE32_64(A)*fSXTN(16,64,B)),     /* behavior */
	(A_MPY)
)

DEF_MACRO(
	fMPY3216SU, /* multiply mixed precision */
	(fSE32_64(A)*fZXTN(16,64,B)),     /* behavior */
	(A_MPY)
)

DEF_MACRO(
	fROUND, /* optional rounding */
	(A+0x8000),
	/* optional attributes */
)

DEF_MACRO(
	fCLIP, /* optional rounding */
	{ size4s_t maxv = (1<<U)-1;
	 size4s_t minv = -(1<<U);
	 size4s_t tmp1 = (size4s_t)fMAX(((size4s_t)SRC),minv);
	 DST = (size4s_t) fMIN(((size4s_t)maxv),tmp1);
	},
	/* optional attributes */
)

DEF_MACRO(
	fCRND, /* optional rounding */
	((((A)&0x3)==0x3)?((A)+1):((A))),
	/* optional attributes */
)

DEF_MACRO(
	fRNDN, /* Rounding to a boundary */
	((((N)==0)?(A):(((fSE32_64(A))+(1<<((N)-1)))))),
	/* optional attributes */
)

DEF_MACRO(
	fCRNDN, /* Rounding to a boundary */
	(conv_round(A,N)),
	/* optional attributes */
)

DEF_MACRO(
	fCRNDN64, /* Rounding to a boundary */
	(conv_round64(A,N)),
	/* optional attributes */
)
DEF_MACRO(
	fADD128, /* Rounding to a boundary */
	(add128(A, B)),
	/* optional attributes */
)
DEF_MACRO(
	fSUB128, /* Rounding to a boundary */
	(sub128(A, B)),
	/* optional attributes */
)
DEF_MACRO(
	fSHIFTR128, /* Rounding to a boundary */
	(shiftr128(A, B)),
	/* optional attributes */
)

DEF_MACRO(
	fSHIFTL128, /* Rounding to a boundary */
	(shiftl128(A, B)),
	/* optional attributes */
)

DEF_MACRO(
	fAND128, /* Rounding to a boundary */
	(and128(A, B)),
	/* optional attributes */
)

DEF_MACRO(
	fCAST8S_16S, /* Rounding to a boundary */
	(cast8s_to_16s(A)),
	/* optional attributes */
)
DEF_MACRO(
	fCAST16S_8S, /* Rounding to a boundary */
	(cast16s_to_8s(A)),
	/* optional attributes */
)
DEF_MACRO(
	fCAST16S_4S, /* Rounding to a boundary */
	(cast16s_to_4s(A)),
	/* optional attributes */
)



DEF_MACRO(
	fEA_RI, /* Calculate EA with Register + Immediate Offset */
	do { EA=REG+IMM; fDOCHKPAGECROSS(REG,EA); } while (0),
	(A_EA_REG_PLUS_IMM)
)

DEF_MACRO(
	fEA_RRs, /* Calculate EA with Register + Registers scaled Offset */
	do { EA=REG+(REG2<<SCALE); fDOCHKPAGECROSS(REG,EA); } while (0),
	(A_EA_REG_PLUS_REGSCALED)
)

DEF_MACRO(
	fEA_IRs, /* Calculate EA with Immediate + Registers scaled Offset */
	do { EA=IMM+(REG<<SCALE); fDOCHKPAGECROSS(IMM,EA); } while (0),
	(A_EA_IMM_PLUS_REGSCALED)
)

DEF_MACRO(
	fEA_IMM, /* Calculate EA with Immediate */
	EA=IMM,
	(A_EA_IMM_ONLY)
)

DEF_MACRO(
	fEA_REG, /* Calculate EA with REGISTER */
	EA=REG,
	(A_EA_REG_ONLY)
)

DEF_MACRO(
	fEA_BREVR, /* Calculate EA with bit reversed bottom of REGISTER */
	EA=fbrev,
	(A_EA_BREV_REG)
)

DEF_MACRO(
	fEA_GPI, /* Calculate EA with Global Poitner + Immediate */
    do { EA=fREAD_GP()+IMM; fGP_DOCHKPAGECROSS(fREAD_GP(),EA); } while (0),
	(A_EA_GP_IMM)
)

DEF_MACRO(
	fPM_I, /* Post Modify Register by Immediate*/
	do { REG = REG + IMM; fTIMING_AIA(EA,REG); } while (0),
	(A_PM_I)
)

DEF_MACRO(
	fPM_M, /* Post Modify Register by M register */
	do { REG = REG + MVAL; fTIMING_AIA(EA,REG); } while (0),
	(A_PM_M)
)

DEF_MACRO(
	fPM_M_BREV, /* Post Modify Register by M register */
	do { REG = REG + MVAL; fTIMING_AIA(EA,fbrev(REG)); } while (0),
	(A_PM_M)
)

DEF_MACRO(
	fPM_M_BREV, /* Post Modify Register by M register */
	do { REG = REG + MVAL; fTIMING_AIA(EA,fbrev(REG)); } while (0),
	(A_PM_M)
)

DEF_MACRO(
	fPM_CIRI, /* Post Modify Register using Circular arithmetic by Immediate */
	do { fcirc_add(REG,siV,MuV); fTIMING_AIA(EA,REG); } while (0),
	(A_PM_CIRI)
)

DEF_MACRO(
	fPM_CIRR, /* Post Modify Register using Circular arithmetic by register */
	do { fcirc_add(REG,VAL,MuV); fTIMING_AIA(EA,REG); } while (0),
	(A_PM_CIRR)
)



DEF_MACRO(
	fMODCIRCU, /* modulo power of 2, positive output  */
	((N) & ((1<<(P))-1)),
	/* optional attributes */
)

DEF_MACRO(
	fSCALE, /* scale by N */
	(((size8s_t)(A))<<N),
	/* optional attributes */
)
DEF_MACRO(
	fVSATW, /* saturating to 32-bits*/
	fVSATN(32,((long long)A)),
	(A_SATURATE)
)

DEF_MACRO(
	fVSATUW, /* saturating to 32-bits*/
	fVSATUN(32,((unsigned long long)A)),
	(A_USATURATE)
)

DEF_MACRO(
	fSATW, /* saturating to 32-bits*/
	fSATN(32,((long long)A)),
	(A_SATURATE)
)

DEF_MACRO(
	fVSAT, /* saturating to 32-bits*/
	fVSATN(32,(A)),
	(A_SATURATE)
)

DEF_MACRO(
	fSAT, /* saturating to 32-bits*/
	fSATN(32,(A)),
	(A_SATURATE)
)

DEF_MACRO(
	fSAT_ORIG_SHL, /* Saturating to 32-bits, with original value, for shift left */
	((((size4s_t)((fSAT(A)) ^ ((size4s_t)(ORIG_REG)))) < 0) ?
		fSATVALN(32,((size4s_t)(ORIG_REG))) :
		((((ORIG_REG) > 0) && ((A) == 0)) ?
			fSATVALN(32,(ORIG_REG)) :
			fSAT(A))),
	(A_SATURATE)
)

DEF_MACRO(
	fPASS,
	(A),
	A
)

DEF_MACRO(
	fRND, /* saturating to 32-bits*/
	(((A)+1)>>1),
    /* FIXME */
)


#if 0
DEF_MACRO(
	fSSLH, /* signed shift left halfword */
        (((fSXTN(8,SHAMT) >= 0) ? (fSE16_32(SRC) << fSXTN(8,SHAMT)) : (fSE16_32(SRC) >> (-fSXTN(8,SHAMT))))),
	/* optional attributes */
)
#endif



DEF_MACRO(
	fBIDIR_SHIFTL,
	(((SHAMT) < 0) ? ((fCAST##REGSTYPE(SRC) >> ((-(SHAMT))-1)) >>1) : (fCAST##REGSTYPE(SRC) << (SHAMT))),
	(A_BIDIRSHIFTL)
)

DEF_MACRO(
	fBIDIR_ASHIFTL,
	fBIDIR_SHIFTL(SRC,SHAMT,REGSTYPE##s),
	(A_BIDIRSHIFTL)
)

DEF_MACRO(
	fBIDIR_LSHIFTL,
	fBIDIR_SHIFTL(SRC,SHAMT,REGSTYPE##u),
	(A_BIDIRSHIFTL)
)

DEF_MACRO(
	fBIDIR_ASHIFTL_SAT,
	(((SHAMT) < 0) ? ((fCAST##REGSTYPE##s(SRC) >> ((-(SHAMT))-1)) >>1) : fSAT_ORIG_SHL(fCAST##REGSTYPE##s(SRC) << (SHAMT),(SRC))),
	(A_BIDIRSHIFTL)
)


DEF_MACRO(
	fBIDIR_SHIFTR,
	(((SHAMT) < 0) ? ((fCAST##REGSTYPE(SRC) << ((-(SHAMT))-1)) << 1) : (fCAST##REGSTYPE(SRC) >> (SHAMT))),
	(A_BIDIRSHIFTR)
)

DEF_MACRO(
	fBIDIR_ASHIFTR,
	fBIDIR_SHIFTR(SRC,SHAMT,REGSTYPE##s),
	(A_BIDIRSHIFTR)
)

DEF_MACRO(
	fBIDIR_LSHIFTR,
	fBIDIR_SHIFTR(SRC,SHAMT,REGSTYPE##u),
	(A_BIDIRSHIFTR)
)

DEF_MACRO(
	fBIDIR_ASHIFTR_SAT,
	(((SHAMT) < 0) ? fSAT_ORIG_SHL((fCAST##REGSTYPE##s(SRC) << ((-(SHAMT))-1)) << 1,(SRC)) : (fCAST##REGSTYPE##s(SRC) >> (SHAMT))),
	(A_BIDIRSHIFTR)
)

DEF_MACRO(
	fASHIFTR,
	(fCAST##REGSTYPE##s(SRC) >> (SHAMT)),
	/* */
)

DEF_MACRO(
	fLSHIFTR,
	(((SHAMT) >= 64)?0:(fCAST##REGSTYPE##u(SRC) >> (SHAMT))),
	/* */
)

DEF_MACRO(
	fROTL,
	(((SHAMT)==0) ? (SRC) : ((fCAST##REGSTYPE##u(SRC) << (SHAMT)) | \
		((fCAST##REGSTYPE##u(SRC) >> ((sizeof(SRC)*8)-(SHAMT)))))),
	/* */
)

DEF_MACRO(
	fROTR,
	(((SHAMT)==0) ? (SRC) : ((fCAST##REGSTYPE##u(SRC) >> (SHAMT)) | \
		((fCAST##REGSTYPE##u(SRC) << ((sizeof(SRC)*8)-(SHAMT)))))),
	/* */
)

DEF_MACRO(
	fASHIFTL,
	(((SHAMT) >= 64)?0:(fCAST##REGSTYPE##s(SRC) << (SHAMT))),
	/* */
)

/*************************************/
/* Floating-Point Support            */
/************************************/

DEF_MACRO(
	fFLOAT, /* name */
	({ union { float f; size4u_t i; } _fipun; _fipun.i = (A); _fipun.f; }),     /* behavior */
	(A_FPOP,A_FPSINGLE,A_IMPLICIT_WRITES_FPFLAGS,A_IMPLICIT_READS_FPRND)
)

DEF_MACRO(
	fUNFLOAT, /* multiply half integer */
	({ union { float f; size4u_t i; } _fipun; _fipun.f = (A); isnan(_fipun.f) ? 0xFFFFFFFFU : _fipun.i; }),     /* behavior */
	(A_FPOP,A_FPSINGLE,A_IMPLICIT_WRITES_FPFLAGS,A_IMPLICIT_READS_FPRND)
)

DEF_MACRO(
	fHALF, /* name */
	({ hf_t h; h.i = (A); h;}),     /* behavior */
	(A_FPOP,A_FPSINGLE,A_IMPLICIT_WRITES_FPFLAGS,A_IMPLICIT_READS_FPRND)
)

DEF_MACRO(
	fUNHALF, /* multiply half integer */
	(A.i),     /* behavior */
	(A_FPOP,A_FPSINGLE,A_IMPLICIT_WRITES_FPFLAGS,A_IMPLICIT_READS_FPRND)
)

DEF_MACRO(
	fHF_BIAS,
	15,
	()
)

DEF_MACRO(
	fHF_MANTBITS,
	10,
	()
)

DEF_MACRO(
	fSFNANVAL,
	0xffffffff,
	()
)

DEF_MACRO(
	fSFINFVAL,
	(((A) & 0x80000000) | 0x7f800000),
	()
)

DEF_MACRO(
	fSFONEVAL,
	(((A) & 0x80000000) | fUNFLOAT(1.0)),
	()
)

DEF_MACRO(
	fCHECKSFNAN,
	do {
		if (isnan(fFLOAT(A))) {
			if ((fGETBIT(22,A)) == 0) fRAISEFLAGS(FE_INVALID);
			DST = fSFNANVAL();
		}
	} while (0),
	()
)

DEF_MACRO(
	fCHECKSFNAN3,
	do {
		fCHECKSFNAN(DST,A);
		fCHECKSFNAN(DST,B);
		fCHECKSFNAN(DST,C);
	} while (0),
	()
)

DEF_MACRO(
	fSF_BIAS,
	127,
	()
)

DEF_MACRO(
	fSF_MANTBITS,
	23,
	()
)

DEF_MACRO(
	fSF_RECIP_LOOKUP,
	arch_recip_lookup(IDX),
	()
)

DEF_MACRO(
	fSF_INVSQRT_LOOKUP,
	arch_invsqrt_lookup(IDX),
	()
)

DEF_MACRO(
	fSF_MUL_POW2,
	(fUNFLOAT(fFLOAT(A) * fFLOAT((fSF_BIAS() + (B)) << fSF_MANTBITS()))),
	()
)

DEF_MACRO(
	fSF_GETEXP,
	(((A) >> fSF_MANTBITS()) & 0xff),
	()
)

DEF_MACRO(
	fSF_MAXEXP,
	(254),
	()
)

DEF_MACRO(
	fSF_RECIP_COMMON,
	arch_sf_recip_common(&N,&D,&O,&A),
	(A_FPOP,A_IMPLICIT_WRITES_FPFLAGS)
)

DEF_MACRO(
	fSF_INVSQRT_COMMON,
	arch_sf_invsqrt_common(&N,&O,&A),
	(A_FPOP,A_IMPLICIT_WRITES_FPFLAGS)
)

DEF_MACRO(
	fFMAFX,
	internal_fmafx(A,B,C,fSXTN(8,64,ADJ)),
	(A_MPY)
)

DEF_MACRO(
	fFMAF,
	internal_fmafx(A,B,C,0),
	(A_MPY)
)

DEF_MACRO(
	fSFMPY,
	internal_mpyf(A,B),
	(A_MPY)
)

DEF_MACRO(
	fMAKESF,
	((((SIGN) & 1) << 31) | (((EXP) & 0xff) << fSF_MANTBITS()) |
		((MANT) & ((1<<fSF_MANTBITS())-1))),
	()
)


DEF_MACRO(
	fDOUBLE, /* multiply half integer */
	({ union { double f; size8u_t i; } _fipun; _fipun.i = (A); _fipun.f; }),     /* behavior */
	(A_FPOP,A_FPDOUBLE,A_IMPLICIT_WRITES_FPFLAGS,A_IMPLICIT_READS_FPRND)
)

DEF_MACRO(
	fUNDOUBLE, /* multiply half integer */
	({ union { double f; size8u_t i; } _fipun; _fipun.f = (A); isnan(_fipun.f) ? 0xFFFFFFFFFFFFFFFFULL : _fipun.i; }),     /* behavior */
	(A_FPOP,A_FPDOUBLE,A_IMPLICIT_WRITES_FPFLAGS,A_IMPLICIT_READS_FPRND)
)

DEF_MACRO(
	fDFNANVAL,
	0xffffffffffffffffULL,
	()
)

DEF_MACRO(
	fDFINFVAL,
	(((A) & 0x8000000000000000ULL) | 0x7ff0000000000000ULL),
	()
)

DEF_MACRO(
	fDFONEVAL,
	(((A) & 0x8000000000000000ULL) | fUNDOUBLE(1.0)),
	()
)

DEF_MACRO(
	fCHECKDFNAN,
	do {
		if (isnan(fDOUBLE(A))) {
			if ((fGETBIT(51,A)) == 0) fRAISEFLAGS(FE_INVALID);
			DST = fDFNANVAL();
		}
	} while (0),
	()
)

DEF_MACRO(
	fCHECKDFNAN3,
	do {
		fCHECKDFNAN(DST,A);
		fCHECKDFNAN(DST,B);
		fCHECKDFNAN(DST,C);
	} while (0),
	()
)

DEF_MACRO(
	fDF_BIAS,
	1023,
	()
)

DEF_MACRO(
	fDF_ISNORMAL,
	(fpclassify(fDOUBLE(X)) == FP_NORMAL),
	()
)

DEF_MACRO(
	fDF_ISDENORM,
	(fpclassify(fDOUBLE(X)) == FP_SUBNORMAL),
	()
)

DEF_MACRO(
	fDF_ISBIG,
	(fDF_GETEXP(X) >= 512),
	()
)

DEF_MACRO(
	fDF_MANTBITS,
	52,
	()
)

DEF_MACRO(
	fDF_RECIP_LOOKUP,
	(size8u_t)(arch_recip_lookup(IDX)),
	()
)

DEF_MACRO(
	fDF_INVSQRT_LOOKUP,
	(size8u_t)(arch_invsqrt_lookup(IDX)),
	()
)

DEF_MACRO(
	fDF_MUL_POW2,
	(fUNDOUBLE(fDOUBLE(A) * fDOUBLE((0ULL + fDF_BIAS() + (B)) << fDF_MANTBITS()))),
	()
)

DEF_MACRO(
	fDF_GETEXP,
	(((A) >> fDF_MANTBITS()) & 0x7ff),
	()
)

DEF_MACRO(
	fDF_MAXEXP,
	(2046),
	()
)

DEF_MACRO(
	fDF_RECIP_COMMON,
	arch_df_recip_common(&N,&D,&O,&A),
	(A_FPOP)
)

DEF_MACRO(
	fDF_INVSQRT_COMMON,
	arch_df_invsqrt_common(&N,&O,&A),
	(A_FPOP)
)

DEF_MACRO(
	fFMA,
	internal_fma(A,B,C),
	/* nothing */
)

DEF_MACRO(
	fDFMPY,
	internal_mpy(A,B),
	/* nothing */
)

DEF_MACRO(
	fDF_MPY_HH,
	internal_mpyhh(A,B,ACC),
	/* nothing */
)

DEF_MACRO(
	fFMAX,
	internal_fmax(A,B,C,fSXTN(8,64,ADJ)*2),
	/* nothing */
)

DEF_MACRO(
	fMAKEDF,
	((((SIGN) & 1ULL) << 63) | (((EXP) & 0x7ffULL) << fDF_MANTBITS()) |
		((MANT) & ((1ULL<<fDF_MANTBITS())-1))),
	()
)

DEF_MACRO(
	fFPOP_START,
	arch_fpop_start(thread),
	/* nothing */
)

DEF_MACRO(
	fFPOP_END,
	arch_fpop_end(thread),
	/* nothing */
)

DEF_MACRO(
	fFPSETROUND_NEAREST,
	fesetround(FE_TONEAREST),
	/* nothing */
)

DEF_MACRO(
	fFPSETROUND_CHOP,
	fesetround(FE_TOWARDZERO),
	/* nothing */
)

DEF_MACRO(
	fFPCANCELFLAGS,
	feclearexcept(FE_ALL_EXCEPT),
	/* nothing */
)

DEF_MACRO(
	fISINFPROD,
	((isinf(A) && isinf(B)) ||
		(isinf(A) && isfinite(B) && ((B) != 0.0)) ||
		(isinf(B) && isfinite(A) && ((A) != 0.0))),
	/* nothing */
)

DEF_MACRO(
	fISZEROPROD,
	((((A) == 0.0) && isfinite(B)) || (((B) == 0.0) && isfinite(A))),
	/* nothing */
)

DEF_MACRO(
	fRAISEFLAGS,
	arch_raise_fpflag(A),
	/* NOTHING */
)

DEF_MACRO(
	fDF_MAX,
	(((A)==(B))
		? fDOUBLE(fUNDOUBLE(A) & fUNDOUBLE(B))
		: fmax(A,B)),
	(A_FPOP)
)

DEF_MACRO(
	fDF_MIN,
	(((A)==(B))
		? fDOUBLE(fUNDOUBLE(A) | fUNDOUBLE(B))
		: fmin(A,B)),
	(A_FPOP)
)

DEF_MACRO(
	fSF_MAX,
	(((A)==(B))
		? fFLOAT(fUNFLOAT(A) & fUNFLOAT(B))
		: fmaxf(A,B)),
	(A_FPOP)
)

DEF_MACRO(
	fSF_MIN,
	(((A)==(B))
		? fFLOAT(fUNFLOAT(A) | fUNFLOAT(B))
		: fminf(A,B)),
	(A_FPOP)
)

/*************************************/
/* Load/Store support                */
/*************************************/

DEF_MACRO(fMMU,
	/* mmu xlate */ ADDR,
	(A_EXCEPTION_TLB,A_EXCEPTION_ACCESS)
)

DEF_MACRO(fcirc_add,
	(REG=fcircadd(thread, REG,INCR,IMMED, fREAD_CSREG(MuN))),
	(A_CIRCADDR,A_IMPLICIT_READS_CS)
)

DEF_MACRO(fbrev,
	(fbrevaddr(REG)),
	(A_BREVADDR)
)


DEF_MACRO(fLOAD,
	{ DST = (size##SIZE##SIGN##_t)MEM_LOAD##SIZE(thread,EA,insn); },
	(A_LOAD,A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fMEMOP,
	{ memop##SIZE##_##FNTYPE(thread,EA,VALUE); },
	(A_LOAD,A_STORE,A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fGET_FRAMEKEY,
	READ_RREG(REG_FRAMEKEY),
	(A_IMPLICIT_READS_FRAMEKEY)
)

DEF_MACRO(fFRAME_SCRAMBLE,
	((VAL) ^ (fCAST8u(fGET_FRAMEKEY()) << 32)),
	/* ATTRIBS */
)

DEF_MACRO(fFRAME_UNSCRAMBLE,
	fFRAME_SCRAMBLE,
	/* ATTRIBS */
)

DEF_MACRO(fFRAMECHECK,
	sys_check_framelimit(thread,ADDR,EA),
	(A_IMPLICIT_READS_FRAMELIMIT)
)

DEF_MACRO(fLOAD_LOCKED,
	{     DST = (size##SIZE##SIGN##_t)mem_load_locked(thread,EA,SIZE,insn);
  },
	(A_LOAD,A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fLOAD_PHYS,
	{     DST = (size##SIZE##SIGN##_t)mem_load_phys(thread,SRC1,SRC2,insn);
  },
	(A_LOAD,A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)


DEF_MACRO(fSTORE,
	{ MEM_STORE##SIZE(thread,EA,SRC,insn); },
	(A_STORE,A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fSTORE_DMA,
	{
		mem_dmalink_store(thread, EA, SIZE, SRC, insn);
	},
	(A_STORE,A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fSTORE_LOCKED,
	{ PRED = (mem_store_conditional(thread,EA,SRC,SIZE,insn) ? 0xff : 0); },
	(A_STORE,A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fVTCM_MEMCPY,
	mem_vtcm_memcpy(thread, insn, DST, SRC, SIZE);,
	/* ATTRIBS */
)


/*************************************/
/* High/Low access support           */
/*************************************/
#if 0
DEF_MACRO(fRDH_L,
	(REG&0x0000ffff),
	()
)

DEF_MACRO(fRDH_H,
	((REG>>16)&0x0000ffff),
	()
)

DEF_MACRO(fWRH_L,
	(REG=(REG&0xffff0000)|(VAL)),
	()
)

DEF_MACRO(fWRH_H,
	(REG=(REG&0x0000ffff)|((VAL)<<16)),
	()
)
#endif

/*************************************/
/* Permute Handler                   */
/*************************************/

DEF_MACRO(fPERMUTEH,
	fpermuteh((SRC0),(SRC1),CTRL),
	(A_PERM)
)

DEF_MACRO(fPERMUTEB,
	fpermuteb((SRC0),(SRC1),CTRL),
	(A_PERM)
)

/*************************************/
/* Functions to help with bytes      */
/*************************************/

DEF_MACRO(fGETBYTE,
         ((size1s_t)((SRC>>((N)*8))&0xff)),
	/* nothing */
)

DEF_MACRO(fGETUBYTE,
         ((size1u_t)((SRC>>((N)*8))&0xff)),
	/* nothing */
)

DEF_MACRO(fSETBYTE,
	{
	DST = (DST & ~(0x0ffLL<<((N)*8))) | (((size8u_t)((VAL) & 0x0ffLL)) << ((N)*8));
	},
	/* nothing */
)

DEF_MACRO(fGETHALF,
         ((size2s_t)((SRC>>((N)*16))&0xffff)),
	/* nothing */
)

DEF_MACRO(fGETUHALF,
         ((size2u_t)((SRC>>((N)*16))&0xffff)),
	/* nothing */
)

DEF_MACRO(fSETHALF,
	{
	DST = (DST & ~(0x0ffffLL<<((N)*16))) | (((size8u_t)((VAL) & 0x0ffff)) << ((N)*16));
	},
	/* nothing */
)



DEF_MACRO(fGETWORD,
         ((size8s_t)((size4s_t)((SRC>>((N)*32))&0x0ffffffffLL))),
	/* nothing */
)

DEF_MACRO(fGETUWORD,
         ((size8u_t)((size4u_t)((SRC>>((N)*32))&0x0ffffffffLL))),
	/* nothing */
)

DEF_MACRO(fSETWORD,
	{
	DST = (DST & ~(0x0ffffffffLL<<((N)*32))) | (((VAL) & 0x0ffffffffLL) << ((N)*32));
	},
	/* nothing */
)

DEF_MACRO(fACC,
    ,
    (A_ACC)
)

DEF_MACRO(fEXTENSION_AUDIO,
    A,
    (A_EXTENSION_AUDIO,A_NOTE_EXTENSION_AUDIO)
)

DEF_MACRO(fSETBIT,
	{
	DST = (DST & ~(1ULL<<(N))) | (((size8u_t)(VAL))<<(N));
	},
	/* nothing */
)

DEF_MACRO(fGETBIT,
	(((SRC)>>N)&1),
	/* nothing */
)


DEF_MACRO(fSETBITS,
	do {
        int j;
        for (j=LO;j<=HI;j++) {
          fSETBIT(j,DST,VAL);
        }
	} while (0),
	/* nothing */
)

DEF_MACRO(fUNDEFINED,
	warn("[UNDEFINED]: architecturally undefined"),
	/* NOTHING */
)

/*************************************/
/* Used for parity, etc........      */
/*************************************/
DEF_MACRO(fCOUNTONES_2,
	count_ones_2,
	/* nothing */
)

DEF_MACRO(fCOUNTONES_4,
	count_ones_4,
	/* nothing */
)

DEF_MACRO(fCOUNTONES_8,
	count_ones_8,
	/* nothing */
)

DEF_MACRO(fBREV_8,
	reverse_bits_8,
	/* nothing */
)

DEF_MACRO(fBREV_4,
	reverse_bits_4,
	/* nothing */
)

DEF_MACRO(fBREV_2,
	reverse_bits_2,
	/* nothing */
)

DEF_MACRO(fBREV_1,
	reverse_bits_1,
	/* nothing */
)

DEF_MACRO(fCL1_8,
	count_leading_ones_8,
	/* nothing */
)

DEF_MACRO(fCL1_4,
	count_leading_ones_4,
	/* nothing */
)

DEF_MACRO(fCL1_2,
	count_leading_ones_2,
	/* nothing */
)

DEF_MACRO(fCL1_1,
	count_leading_ones_1,
	/* nothing */
)

DEF_MACRO(fCLZ_16,
	count_leading_zeros_16,
	/* nothing */
)


DEF_MACRO(fINTERLEAVE,
	interleave(ODD,EVEN),
	/* nothing */
)

DEF_MACRO(fDEINTERLEAVE,
	deinterleave(MIXED),
	/* nothing */
)

DEF_MACRO(fNORM16,
        ((VAL == 0) ? (31) : (fMAX(fCL1_2( VAL),fCL1_2(~VAL))-1)),
	/* nothing */
)



DEF_MACRO(fHIDE,
	A,
	()
)

DEF_MACRO(fASM_MAP,
	fatal("ASM_MAP instruction " A "->" B " executed.");,
	()
)

DEF_MACRO(fCOND_ASM_MAP,
	fatal("ASM_MAP instruction " A "->" X "/" Y " executed.");,
	()
)

DEF_MACRO(fCONSTLL,
	A##LL,
)

DEF_MACRO(fCONSTULL,
	A##ULL,
)

/* Do the things in the parens, but don't print the parens. */
DEF_MACRO(fECHO,
	(A),
	/* nothing */
)


/********************************************/
/* OS interface and stop/wait               */
/********************************************/

DEF_MACRO(RUNNABLE_THREADS_MAX,
	(thread->processor_ptr->runnable_threads_max),
	()
)

DEF_MACRO(THREAD_IS_ON,
	((get_thread_en_mask(PROC)>>TNUM) & 0x1),
	()
)

DEF_MACRO(THREAD_EN_MASK,
	(get_thread_en_mask(PROC)),
	()
)



DEF_MACRO(READ_IMASK,
         (((TH) >= (thread->processor_ptr->runnable_threads_max)) ? 0 : (thread->processor_ptr->thread[TH]->Regs[REG_IMASK])),
	(A_IMPLICIT_READS_IMASK_ANYTHREAD)
)
DEF_MACRO(WRITE_IMASK,
        /* if ((TH) < (thread->processor_ptr->runnable_threads_max)) { LOG_OTHER_THREAD_REG_WRITE(thread,REG_IMASK,VAL,TH); fVERIFICATION_REGWRITE_NOTE((TH),(REG_IMASK)); }, */
	 if ((TH) < (thread->processor_ptr->runnable_threads_max)) { thread->processor_ptr->thread[TH]->Regs[REG_IMASK]=(VAL & reg_mutability[REG_IMASK] ); fVERIFICATION_REGWRITE_NOTE((TH),(REG_IMASK)) },
	(A_IMPLICIT_WRITES_IMASK_ANYTHREAD)
)


DEF_MACRO(WRITE_PRIO,
	{
		if ((TH) < (thread->processor_ptr->runnable_threads_max)) {
			size4u_t tid_reg = thread->processor_ptr->thread[TH]->Regs[REG_TID];
			fINSERT_BITS(tid_reg, reg_field_info[STID_PRIO].width, reg_field_info[STID_PRIO].offset, VAL);
			LOG_OTHER_THREAD_REG_WRITE(thread,REG_TID,tid_reg,TH);
		}
	},
	(A_IMPLICIT_WRITES_STID_PRIO_ANYTHREAD)
)


DEF_MACRO(DO_IASSIGNW,
	{
        int i;
        int intbitpos = ((REG>>16)&0xF);
        for (i=0;i<RUNNABLE_THREADS_MAX;i++) {
			if(( (get_thread_en_mask(thread->processor_ptr)>>i) & 0x1)) {
				fINSERT_BITS(thread->processor_ptr->thread[i]->Regs[REG_IMASK],1, intbitpos, (REG>>i) & 1);
           }
		}
	},
	(A_IMPLICIT_WRITES_IMASK_ANYTHREAD)
)




DEF_MACRO(fDO_NMI,
	{
		int i;
		for (i=0;i<RUNNABLE_THREADS_MAX;i++) {
			if( ( (get_thread_en_mask(thread->processor_ptr)>>i) & 0x1) ) {
				if (SREG & (1<<i)) {
					register_nmi_interrupt(thread->processor_ptr->thread[i]);
				}
			}
		}
	},
)

DEF_MACRO(fDO_TRACE,
	{
		fHIDE(CALLBACK(thread->processor_ptr->options->trace_callback,
			thread->system_ptr,thread->processor_ptr,
			thread->threadId,SREG);)
        },
)

DEF_MACRO(DO_IASSIGNR,
	{
		int i;
		int result=0;
		int intbitpos = ((SREG>>16)&0xF);
		for (i=0;i<RUNNABLE_THREADS_MAX;i++) {
			if(( (get_thread_en_mask(thread->processor_ptr)>>i) & 0x1)) {
				result |= (((thread->processor_ptr->thread[i]->Regs[REG_IMASK]>>intbitpos)&1)<<i);
			}
		}
		DREG=result;
	},
	(A_IMPLICIT_READS_IMASK_ANYTHREAD)
)

DEF_MACRO(DO_SWI,
        {fHIDE(CALLBACK(thread->processor_ptr->options->swi_callback,
         thread->system_ptr,thread->processor_ptr,
         thread->threadId,REG));
	 fLOG_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IPEND,fREAD_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IPEND)|(REG));
        },
	(A_EXCEPTION_SWI,A_IMPLICIT_READS_IPENDAD_IPEND,A_IMPLICIT_WRITES_IPENDAD_IPEND)
)

DEF_MACRO(DO_CSWI,
	fLOG_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IPEND,fREAD_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IPEND) & ~(REG));,
	(A_IMPLICIT_READS_IPENDAD_IPEND,A_IMPLICIT_WRITES_IPENDAD_IPEND)
)

DEF_MACRO(DO_CIAD,
	sys_ciad(thread,VAL);
	fLOG_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IAD,fREAD_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IAD) & ~(VAL));,
	(A_EXCEPTION_SWI,A_IMPLICIT_READS_IPENDAD_IAD,A_IMPLICIT_WRITES_IPENDAD_IAD)
)

DEF_MACRO(DO_SIAD,
	sys_siad(thread,VAL);
	fLOG_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IAD,fREAD_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IAD) | (VAL));,
	(A_EXCEPTION_SWI,A_IMPLICIT_READS_IPENDAD_IAD,A_IMPLICIT_WRITES_IPENDAD_IAD)
)

DEF_MACRO(fBREAK,
        {isdb_brkpt_insn(thread->processor_ptr,thread->threadId);},
	()
)

DEF_MACRO(fGP_DOCHKPAGECROSS,
	if (!(insn->extension_valid)) {
        fDOCHKPAGECROSS(BASE,SUM);
    },
	(A_EA_PAGECROSS)
)

DEF_MACRO(fDOCHKPAGECROSS,
	if (thread->bq_on) {
		thread->mem_access[insn->slot].check_page_crosses = 1;
		thread->mem_access[insn->slot].page_cross_base = BASE;
		thread->mem_access[insn->slot].page_cross_sum = SUM;
	},
	(A_EA_PAGECROSS)
)

DEF_MACRO(fTIMING_AIA,
  if(thread->bq_on){
	thread->mem_access[insn->slot].post_updated = 1;
	thread->mem_access[insn->slot].post_updated_va = NEWVA;
	insn->is_aia = 1;
	},
	(A_PM_ANY)
)


DEF_MACRO(fPAUSE,
        {sys_pause(thread, insn->slot, IMM);},
	()
)
DEF_MACRO(fUNPAUSE,
        {sys_unpause(thread, insn->slot);},
	()
)


#if 1
/* The way it should be */
DEF_MACRO(fTRAP,
    warn("Trap NPC=%x ",fREAD_NPC());
	warn("Trap exception, PCYCLE=%lld TYPE=%d NPC=%x IMM=0x%x",thread->processor_ptr->pstats[pcycles],TRAPTYPE,fREAD_NPC(),IMM);
	register_trap_exception(thread,fREAD_NPC(),TRAPTYPE,IMM);,
	(A_EXCEPTION_SWI)
)
#else
DEF_MACRO(fTRAP,
        if ((TRAPTYPE == 0) && (IMM == 0) &&
              (!thread->sandbox_execution) &&
              (!thread->processor_ptr->options->disable_angelswi)) {
                sim_handle_trap(thread->system_ptr,thread->processor_ptr,thread->threadId,0);
                /*thread->status |= EXEC_STATUS_SWI;*/
        } else if ((TRAPTYPE == 0) && (IMM == 0xdb) &&
               (!thread->sandbox_execution) &&
               (!thread->processor_ptr->options->disable_angelswi)) {
                sim_handle_debug(thread->system_ptr,thread->processor_ptr,thread->threadId,0xdb);
        } else {
          warn("Trap exception, TYPE=%d NPC=%x IMM=0x%x",TRAPTYPE,fREAD_NPC(),IMM);
          register_trap_exception(thread,fREAD_NPC(),TRAPTYPE,IMM);
        },
        (A_EXCEPTION_SWI)
)
#endif

DEF_MACRO(fINTERNAL_CLEAR_SAMEPAGE,

	/* force re-xlate at next fetch, refresh of in_user_mode, etc */
	/* Permissions change too... */
	sys_utlb_invalidate(thread->processor_ptr,thread),
	/* NOTHING */
)

DEF_MACRO(fCLEAR_RTE_EX,
      {
        fLOG_REG_FIELD(SSR,SSR_EX,0);
  	    fINTERNAL_CLEAR_SAMEPAGE();
      },
      ()
)

DEF_MACRO(fTLB_LOCK_AVAILABLE,
	(fREAD_GLOBAL_REG_FIELD(SYSCONF,SYSCFG_TLBLOCK) == 0),
	()
)

DEF_MACRO(fK0_LOCK_AVAILABLE,
	(fREAD_GLOBAL_REG_FIELD(SYSCONF,SYSCFG_K0LOCK) == 0),
	()
)

DEF_MACRO(fSET_TLB_LOCK,
      {
      if (fTLB_LOCK_AVAILABLE()) {
        fLOG_GLOBAL_REG_FIELD(SYSCONF,SYSCFG_TLBLOCK,1);
      } else {
        sys_waiting_for_tlb_lock(thread);
      }
      },
      (A_IMPLICIT_READS_SYSCFG_TLBLOCK,A_IMPLICIT_WRITES_SYSCFG_TLBLOCK)
)

DEF_MACRO(fSET_K0_LOCK,
      {
      if (fK0_LOCK_AVAILABLE() && sys_k0lock_queue_ready(thread)) {
	warn("k0lock: T%d: PC=0x%x: PCycle=%lld",thread->threadId,thread->Regs[REG_PC],thread->processor_ptr->pstats[pcycles]);
        fLOG_GLOBAL_REG_FIELD(SYSCONF,SYSCFG_K0LOCK,1);
      } else {
      warn("k0lock_waiting: T%d: PC=0x%x: PCycle=%lld",thread->threadId,thread->Regs[REG_PC],thread->processor_ptr->pstats[pcycles]);
        sys_waiting_for_k0_lock(thread);
      }
      },
      (A_IMPLICIT_READS_SYSCFG_K0LOCK,A_IMPLICIT_WRITES_SYSCFG_K0LOCK)
)

DEF_MACRO(fCLEAR_TLB_LOCK,
      {
		int i;
		fLOG_GLOBAL_REG_FIELD(SYSCONF,SYSCFG_TLBLOCK,0);
		for (i = 0; i < RUNNABLE_THREADS_MAX; i++) {
			if(( (get_thread_en_mask(thread->processor_ptr)>>i) & 0x1)) {
				thread->processor_ptr->thread[i]->cu_tlb_lock_waiting = 0;
			}
		}
      },
      (A_IMPLICIT_READS_SYSCFG_TLBLOCK,A_IMPLICIT_WRITES_SYSCFG_TLBLOCK)
)

DEF_MACRO(fCLEAR_K0_LOCK,
      do {
      warn("k0unlock: T%d: PC=0x%x: Pcycle=%lld",thread->threadId,thread->Regs[REG_PC], thread->processor_ptr->pstats[pcycles]);
      sys_initiate_clear_k0_lock(thread);
      } while (0),
      (A_IMPLICIT_READS_SYSCFG_K0LOCK,A_IMPLICIT_WRITES_SYSCFG_K0LOCK)
)

DEF_MACRO(fWRITE_REG_FIELD,
	fINSERT_BITS(thread->Regs[REG_##REG],
            reg_field_info[FIELD].width,
            reg_field_info[FIELD].offset,VAL),
)

DEF_MACRO(fALIGN_REG_FIELD_VALUE,
	((VAL)<<reg_field_info[FIELD].offset),
	/* */
)

DEF_MACRO(fGET_REG_FIELD_MASK,
	(((1<<reg_field_info[FIELD].width)-1)<<reg_field_info[FIELD].offset),
	/* */
)

DEF_MACRO(fLOG_REG_FIELD,
	LOG_MASKED_REG_WRITE(thread,REG_##REG,
		fALIGN_REG_FIELD_VALUE(FIELD,VAL),
		fGET_REG_FIELD_MASK(FIELD)),
	()
)

DEF_MACRO(fWRITE_GLOBAL_REG_FIELD,
	fINSERT_BITS(thread->processor_ptr->global_regs[REG_##REG],
            reg_field_info[FIELD].width,
            reg_field_info[FIELD].offset,VAL),
)

DEF_MACRO(fLOG_GLOBAL_REG_FIELD,
	LOG_MASKED_GLOBAL_REG_WRITE(REG_##REG,
		fALIGN_REG_FIELD_VALUE(FIELD,VAL),
		fGET_REG_FIELD_MASK(FIELD)),
	()
)

DEF_MACRO(fREAD_REG_FIELD,
	fEXTRACTU_BITS(thread->Regs[REG_##REG],
            reg_field_info[FIELD].width,
            reg_field_info[FIELD].offset),
	/* ATTRIBS */
)

DEF_MACRO(fREAD_GLOBAL_REG_FIELD,
	fEXTRACTU_BITS(thread->processor_ptr->global_regs[REG_##REG],
            reg_field_info[FIELD].width,
            reg_field_info[FIELD].offset),
	/* ATTRIBS */
)

DEF_MACRO(fGET_FIELD,
	fEXTRACTU_BITS(VAL,
		reg_field_info[FIELD].width,
		reg_field_info[FIELD].offset),
	/* ATTRIBS */
)

DEF_MACRO(fSET_FIELD,
	fINSERT_BITS(VAL,
		reg_field_info[FIELD].width,
		reg_field_info[FIELD].offset,
		(NEWVAL)),
	/* ATTRIBS */
)

DEF_MACRO(fSET_RUN_MODE_NOW,
        {thread->processor_ptr->global_regs[REG_MODECTL] |= (1<<TNUM);
         thread->last_commit_cycle = thread->processor_ptr->pcycle_counter;
         sys_recalc_num_running_threads(thread->processor_ptr);},
)

DEF_MACRO(fIN_DEBUG_MODE,
	(thread->debug_mode || (fREAD_GLOBAL_REG_FIELD(ISDBST,ISDBST_DEBUGMODE) & 1<<TNUM)),
	()
)
DEF_MACRO(fIN_DEBUG_MODE_NO_ISDB,
	(thread->debug_mode),
	()
)


DEF_MACRO(fIN_DEBUG_MODE_WARN,
	{
		if (fREAD_GLOBAL_REG_FIELD(ISDBST,ISDBST_DEBUGMODE) & 1<<TNUM)
			warn("In ISDB debug mode, but TB told me to step normally");
	},
	()
)

DEF_MACRO(fCLEAR_RUN_MODE,
	{fLOG_GLOBAL_REG_FIELD(MODECTL,MODECTL_E,
    fREAD_GLOBAL_REG_FIELD(MODECTL,MODECTL_E) & ~(1<<(TNUM)))},
#if 0
        if (!thread->debug_mode) {
	{thread->processor_ptr->global_regs[REG_MODECTL] &= ~(1<<TNUM);
         sys_recalc_num_running_threads(thread->processor_ptr);}},
#endif
	/* NOTHING */
)

DEF_MACRO(fCLEAR_RUN_MODE_NOW,
	do {
		fWRITE_GLOBAL_REG_FIELD(MODECTL,MODECTL_E,
			fREAD_GLOBAL_REG_FIELD(MODECTL,MODECTL_E) & ~(1<<(TNUM)));
		sys_recalc_num_running_threads(thread->processor_ptr);
	} while (0),
	/* NOTHING */
)

DEF_MACRO(fGET_RUN_MODE,
        ((thread->processor_ptr->global_regs[REG_MODECTL]>>TNUM)&0x1),
)

DEF_MACRO(fSET_WAIT_MODE,
	{fLOG_GLOBAL_REG_FIELD(MODECTL,MODECTL_W,
    fREAD_GLOBAL_REG_FIELD(MODECTL,MODECTL_W) | 1<<(TNUM))
	thread->isdb_delayed_wait_brkpt = 1;},
#if 0
        {thread->processor_ptr->global_regs[REG_MODECTL] |= (1<<(TNUM+16));
         sys_recalc_num_running_threads(thread->processor_ptr);},
#endif
	/* NOTHING */
)

DEF_MACRO(fCLEAR_WAIT_MODE,
        {thread->processor_ptr->global_regs[REG_MODECTL] &= ~(1<<(TNUM+16));
         thread->last_commit_cycle = thread->processor_ptr->pcycle_counter;
         sys_recalc_num_running_threads(thread->processor_ptr);},
)

DEF_MACRO(fGET_WAIT_MODE,
        ((thread->processor_ptr->global_regs[REG_MODECTL]>>(TNUM+16))&0x1),
)


DEF_MACRO(fRESET_THREAD,
        register_reset_interrupt(T,NUM),
)

DEF_MACRO(fREAD_CURRENT_EVB,
	(GLOBAL_REG_READ(REG_EVB)),
	/* nothing */
)

DEF_MACRO(fREAD_ELR,
	READ_RREG(REG_ELR),
	(A_IMPLICIT_READS_ELR)
)

DEF_MACRO(fPOW2_HELP_ROUNDUP,
	((VAL) | ((VAL) >> 1) | ((VAL) >> 2) | ((VAL) >> 4) | ((VAL) >> 8) | ((VAL) >> 16)),
	()
)

DEF_MACRO(fPOW2_ROUNDUP,
	fPOW2_HELP_ROUNDUP((VAL)-1)+1,
	()
)

DEF_MACRO(fTLB_IDXMASK,
	((INDEX) & (fPOW2_ROUNDUP(fCAST4u(thread->processor_ptr->arch_proc_options->QDSP6_JTLB_SZ)) - 1)),
	()
)

DEF_MACRO(fDMATLB_IDXMASK,
	((INDEX) & (fPOW2_ROUNDUP(fCAST4u(thread->processor_ptr->arch_proc_options->QDSP6_DMAJTLB_SZ)) - 1)),
	()
)
DEF_MACRO(fTLB_NONPOW2WRAP,
	(((INDEX) >= thread->processor_ptr->arch_proc_options->QDSP6_JTLB_SZ) ? ((INDEX) - thread->processor_ptr->arch_proc_options->QDSP6_JTLB_SZ) : (INDEX)),
	/* ATTRIBS */
)

DEF_MACRO(fTLBW,
	do {
		size4u_t __myidx = fTLB_NONPOW2WRAP(fTLB_IDXMASK(INDEX));
		warn("TLB Write to index=%x entry=%llx wrapped index=%x", INDEX, VALUE, __myidx);
		 fHIDE(dma_adapter_tlb_invalidate(thread, __myidx, TLB_REG_READ(__myidx), VALUE);)
         TLB_REG_WRITE(__myidx,VALUE);
        CALLBACK(thread->processor_ptr->options->tlbw_callback,thread->system_ptr,thread->processor_ptr,thread->threadId,__myidx);
        sys_tlb_write(thread,__myidx,VALUE);

	} while (0),

)

DEF_MACRO(fTLBW_EXTENDED,

	do {
		size4u_t __dma_tlb = ((INDEX & DMA_TLB_OFFSET) && (thread->processor_ptr->arch_proc_options->QDSP6_DMAJTLB_SZ>0))  ;
		size4u_t __myidx = __dma_tlb ? fTLB_NONPOW2WRAP(fDMATLB_IDXMASK(INDEX-DMA_TLB_OFFSET)) + DMA_TLB_OFFSET : fTLB_NONPOW2WRAP(fTLB_IDXMASK(INDEX));
		warn("TLB Write to index=%x entry=%llx wrapped index=%x __dma_tlb=%x", INDEX, VALUE, __myidx, __dma_tlb);
		fHIDE(dma_adapter_tlb_invalidate(thread, __myidx, TLB_REG_READ(__myidx), VALUE);)
        TLB_REG_WRITE(__myidx,VALUE);
        CALLBACK(thread->processor_ptr->options->tlbw_callback,thread->system_ptr,thread->processor_ptr,thread->threadId,__myidx);
        sys_tlb_write(thread,__myidx,VALUE);

	} while (0),

)
DEF_MACRO(fTLB_ENTRY_OVERLAP,
     fHIDE( (sys_check_overlap(thread,VALUE, INDEX)!=-2) ),
	/* ATTRIBS */
)

DEF_MACRO(fTLB_ENTRY_OVERLAP_IDX,
     fHIDE(sys_check_overlap(thread,VALUE, INDEX)),
	/* ATTRIBS */
)


DEF_MACRO(fTLBR,
        TLB_REG_READ(fTLB_NONPOW2WRAP(fTLB_IDXMASK(INDEX))),
	/* ATTRIBS */
)

DEF_MACRO(fTLBR_EXTENDED,
    ((INDEX & DMA_TLB_OFFSET) && (thread->processor_ptr->arch_proc_options->QDSP6_DMAJTLB_SZ>0)) ? TLB_REG_READ(fTLB_NONPOW2WRAP(fDMATLB_IDXMASK(INDEX-DMA_TLB_OFFSET))+DMA_TLB_OFFSET) :  TLB_REG_READ(fTLB_NONPOW2WRAP(fTLB_IDXMASK(INDEX))),
	/* ATTRIBS */
)

DEF_MACRO(fTLBP,
        tlb_lookup(thread,((TLBHI)>>12),((TLBHI)<<12),1),
	/* attribs */
)



DEF_MACRO(READ_SGP0,
	READ_RREG(REG_SGP),
	(A_IMPLICIT_READS_SGP0)
)

DEF_MACRO(READ_SGP1,
	READ_RREG(REG_SGP+1),
	(A_IMPLICIT_READS_SGP1)
)

DEF_MACRO(READ_SGP10,
	READ_RREG_PAIR(REG_SGP),
	(A_IMPLICIT_READS_SGP0,A_IMPLICIT_READS_SGP1)
)

DEF_MACRO(READ_UGP,
	READ_RREG(REG_UGP),
)

DEF_MACRO(WRITE_SGP0,
        WRITE_RREG(REG_SGP,VAL),
	(A_IMPLICIT_WRITES_SGP0)
)

DEF_MACRO(WRITE_SGP1,
        WRITE_RREG(REG_SGP+1,VAL),
	(A_IMPLICIT_WRITES_SGP1)
)

DEF_MACRO(WRITE_SGP10,
        WRITE_RREG_PAIR(REG_SGP,VAL),
	(A_IMPLICIT_WRITES_SGP0,A_IMPLICIT_WRITES_SGP1)
)

DEF_MACRO(WRITE_UGP,
        WRITE_RREG(REG_UGP,VAL),
)

#if 0
DEF_MACRO(fSTOP,
	/* FIXME */,
	()
)
#endif

DEF_MACRO(fSTART,
	fLOG_GLOBAL_REG_FIELD(MODECTL,MODECTL_E, fREAD_GLOBAL_REG_FIELD(MODECTL,MODECTL_E) | (((REG & ((1<<RUNNABLE_THREADS_MAX)-1))) & THREAD_EN_MASK(thread->processor_ptr))),
#if 0
	do {
		fHIDE(size4u_t i;)
		for (i = 0; i < RUNNABLE_THREADS_MAX; i++) {
			if (fGETBIT(i,RsV) && (fGET_RUN_MODE(i) == 0)) {
				fSET_RUN_MODE(i);
				fRESET_THREAD(thread,i);
			}
		}
	} while (0)/* FIXME */,
#endif
	()
)

#if 0
DEF_MACRO(fWAIT,
	/* FIXME */,
	()
)
#endif

DEF_MACRO(fRESUME,
	fLOG_GLOBAL_REG_FIELD(MODECTL,MODECTL_W,
		fREAD_GLOBAL_REG_FIELD(MODECTL,MODECTL_W) & (~(REG))),
	()
)

DEF_MACRO(fGET_TNUM,
	thread->threadId,
	()
)


DEF_MACRO(fVERIF_MARK_RREG_ACCESS,
	/* Nothing */,
	()
)


DEF_MACRO(fVERIF_MARK_RREGPAIR_ACCESS,
	/* Nothing */,
	()
)

DEF_MACRO(fVERIF_MARK_CREG_ACCESS,
	/* Nothing */,
	()
)


DEF_MACRO(fVERIF_MARK_CREGPAIR_ACCESS,
	/* Nothing */,
	()
)

DEF_MACRO(fVERIF_MARK_SREG_ACCESS,
	/* Nothing */,
	()
)


DEF_MACRO(fVERIF_MARK_SREGPAIR_ACCESS,
	/* Nothing */,
	()
)

DEF_MACRO(fVERIF_MARK_GREG_ACCESS,
	/* Nothing */,
	()
)


DEF_MACRO(fVERIF_MARK_GREGPAIR_ACCESS,
	/* Nothing */,
	()
)


DEF_MACRO(fVERIF_MARK_VREG_ACCESS,
	/* Nothing */,
	()
)


DEF_MACRO(fVERIF_MARK_VREGPAIR_ACCESS,
	/* Nothing */,
	()
)

DEF_MACRO(fVERIF_MARK_VREGQUAD_ACCESS,
	/* Nothing */,
	()
)


/********************************************/
/* Cache Management                         */
/********************************************/

DEF_MACRO(fBARRIER,
     {
        sys_barrier(thread, insn->slot);
     },
	()
)

DEF_MACRO(fSYNCH,
  {
      sys_sync(thread, insn->slot);
  },
	()
)

DEF_MACRO(fISYNC,
  {
      sys_isync(thread, insn->slot);
  },
	()
)


DEF_MACRO(fICFETCH,
	/* Unimplemented for now in uarch... cache_nru_icache_fetch(thread->processor_ptr, thread->threadId, (REG)) */,
	()
)

DEF_MACRO(fDCFETCH,
	sys_dcfetch(thread, (REG), insn->slot),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fICINVIDX,
  {
  	arch_internal_flush(thread->processor_ptr,0,0xffffffff); /* FIXME */
  //    sys_icinvidx(thread, (REG));
  }
  ,
	()
)

DEF_MACRO(fICINVA,
	{
	arch_internal_flush(thread->processor_ptr, 0, 0xffffffff);
   	sys_icinva(thread, (REG),insn->slot);
	},
	(A_ICINVA)
)

DEF_MACRO(fICKILL,
        arch_internal_flush(thread->processor_ptr, 0, 0xffffffff);
        cache_kill_icache(thread->processor_ptr); ,
	()
)

DEF_MACRO(fDCKILL,
        cache_kill_dcache(thread->processor_ptr); ,
	()
)

DEF_MACRO(fL2KILL,
        cache_kill_l2cache(thread->processor_ptr); ,
	(A_IMPLICIT_READS_SYSCFG_GCA,A_IMPLICIT_WRITES_SYSCFG_GCA)
)

DEF_MACRO(fL2UNLOCK,
	sys_l2gunlock(thread),
	(A_IMPLICIT_READS_SYSCFG_GCA,A_IMPLICIT_WRITES_SYSCFG_GCA)
)

DEF_MACRO(fL2CLEAN,
	sys_l2gclean(thread),
	(A_IMPLICIT_READS_SYSCFG_GCA,A_IMPLICIT_WRITES_SYSCFG_GCA)
)

DEF_MACRO(fL2CLEANINV,
	sys_l2gcleaninv(thread),
	(A_IMPLICIT_READS_SYSCFG_GCA,A_IMPLICIT_WRITES_SYSCFG_GCA)
)

DEF_MACRO(fL2CLEANPA,
	sys_l2gclean_pa(thread,REG),
	(A_IMPLICIT_READS_SYSCFG_GCA,A_IMPLICIT_WRITES_SYSCFG_GCA)
)

DEF_MACRO(fL2CLEANINVPA,
	sys_l2gcleaninv_pa(thread,REG),
	(A_IMPLICIT_READS_SYSCFG_GCA,A_IMPLICIT_WRITES_SYSCFG_GCA)
)


DEF_MACRO(fL2CLEANINVIDX,
	sys_l2cleaninvidx(thread, (REG)),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fL2CLEANIDX,
	sys_l2cleanidx(thread, (REG)),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fL2INVIDX,
	sys_l2invidx(thread, (REG)),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fDCTAGR,
	({DST=sys_dctagr(thread, INDEX, insn->slot,DSTREGNO);})/* FIXME */,
	()
)

DEF_MACRO(fDCTAGW,
	(sys_dctagw(thread, INDEX, PART2, insn->slot)),
	()
)
DEF_MACRO(fICTAGR,
	({DST=sys_ictagr(thread, INDEX, insn->slot,REGNO);}),
	()
)

DEF_MACRO(fICDATAR,
	({DST=sys_icdatar(thread, INDEX, insn->slot);}),
	()
)

DEF_MACRO(fICTAGW,
	(sys_ictagw(thread, INDEX, PART2, insn->slot)),
	()
)
DEF_MACRO(fICDATAW,
	({ fHIDE(); }),
	()
)

DEF_MACRO(fL2FETCH,
	sys_l2fetch(thread, ADDR,HEIGHT,WIDTH,STRIDE,FLAGS, insn->slot),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST,A_L2FETCH)
)

DEF_MACRO(fDMSTART,
	"DM0[31:4] = Rs[31:0];"
	dma_adapter_cmd(thread,DMA_CMD_START,NEWPTR,0),
	()
)

DEF_MACRO(fDMLINK,
	"CURPTR->Next = NEWPTR;"
	"if (DM0 == 0);"
	dma_adapter_cmd(thread,DMA_CMD_LINK,CURPTR,NEWPTR),
	()
)

DEF_MACRO(fDMPOLL,
	DST=dma_adapter_cmd(thread,DMA_CMD_POLL,0,0),
	()
)

DEF_MACRO(fDMWAIT,
	DST=dma_adapter_cmd(thread,DMA_CMD_WAIT,0,0),
	()
)

DEF_MACRO(fDMSYNCHT,
	DST=dma_adapter_cmd(thread,DMA_CMD_SYNCHT,0,0),
	()
)
DEF_MACRO(fDMTLBSYNCH,
	DST=dma_adapter_cmd(thread,DMA_CMD_TLBSYNCH,0,0),
	()
)


DEF_MACRO(fDMPAUSE,
	"DST = DM0;"
	DST=dma_adapter_cmd(thread,DMA_CMD_PAUSE,0,0),
	()
)

DEF_MACRO(fDMRESUME,
	"DST = DM0;"
	dma_adapter_cmd(thread,DMA_CMD_RESUME,PTR,0),
	()
)

DEF_MACRO(fDMWAITDESCRIPTOR,
	DST=dma_adapter_cmd(thread,DMA_CMD_WAITDESCRIPTOR,SRC,0),
	()
)

DEF_MACRO(fDMCFGRD,
	DST=dma_adapter_cmd(thread,DMA_CMD_CFGRD,DMANUM,0),
	()
)

DEF_MACRO(fDMCFGWR,
	dma_adapter_cmd(thread,DMA_CMD_CFGWR,DMANUM,DATA),
	()
)

DEF_MACRO(fL2TAGR,
	({DST=sys_l2tagr(thread, INDEX, insn->slot, DSTREG);}),
	()
)

DEF_MACRO(fL2LOCKA,
	do {DST=sys_l2locka(thread, VA, insn->slot, PREGDST); } while (0),
	()
)

DEF_MACRO(fL2UNLOCKA,
	sys_l2unlocka(thread, VA, insn->slot),
	()
)

DEF_MACRO(fL2TAGW,
	({sys_l2tagw(thread, INDEX, PART2, insn->slot);}),
	()
)

DEF_MACRO(fDCCLEANIDX,
	sys_dccleanidx(thread, (REG)),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fDCCLEANA,
	sys_dccleana(thread, (REG)),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fDCCLEANINVIDX,
	sys_dccleaninvidx(thread, (REG)),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fDCCLEANINVA,
	sys_dccleaninva(thread, (REG), insn->slot),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST,A_DCCLEANINVA)
)

DEF_MACRO(fDCZEROA,
	sys_dczeroa(thread, (REG)),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fDCINVIDX,
	sys_dcinvidx(thread, (REG)),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)

DEF_MACRO(fDCINVA,
	sys_dcinva(thread, (REG)),
	(A_MEMLIKE,A_RESTRICT_SINGLE_MEM_FIRST)
)


DEF_MACRO(fCHECKFORPRIV,
	{sys_check_privs(thread); if (EXCEPTION_DETECTED) return; },
	()
)

DEF_MACRO(fCHECKFORGUEST,
	{sys_check_guest(thread); if (EXCEPTION_DETECTED) return; },
	()
)

DEF_MACRO(fILLEGAL,
	do {sys_illegal(thread); if (EXCEPTION_DETECTED) return; } while (0),
	()
)

#ifdef NEW_INTERRUPTS

DEF_MACRO(fTAKEN_INTERRUPT_EDGECLEAR,
	{ fWRITE_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IPEND,
		fREAD_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IPEND) & ~(INT_NUMTOMASK(intnum))); },
	()
)

DEF_MACRO(fSET_IAD,
	{ sys_siad(thread,INT_NUMTOMASK(intnum));
	  fWRITE_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IAD,
		fREAD_GLOBAL_REG_FIELD(IPENDAD,IPENDAD_IAD) | INT_NUMTOMASK(intnum)); },
	()
)
#else

DEF_MACRO(fTAKEN_INTERRUPT_EDGECLEAR,
        { proc->global_regs[REG_IPEND] &= ~(INT_NUMTOMASK(intnum) & proc->global_regs[REG_IEL]); },
        ()
)

DEF_MACRO(fSET_IAD,
        { sys_siad(thread,INT_NUMTOMASK(intnum)); thread->processor_ptr->global_regs[REG_IAD] |= INT_NUMTOMASK(intnum); },
        ()
)

#endif

DEF_MACRO(fBRANCH_SPECULATED_RIGHT,
	(((JC) ^ (SD) ^ (DOTNEWVAL&1)) & 0x1),
	()
)



DEF_MACRO(fBRANCH_SPECULATE_STALL,
	{
#if 0
	if(thread->timing_on) {
      thread->processor_ptr->uarch.bp_check_branch_new_stall_ptr(thread->processor_ptr,thread->threadId,
										JUMP_COND(JUMP_PRED_SET), SPEC_DIR, DOTNEWVAL, HINTBITNUM,STRBITNUM,0,
        					            thread->last_pkt->pkt_has_dual_jump, insn->is_2nd_jump,
		                          (thread->fetch_access.vaddr + insn->encoding_offset*4));
    }
#else
sys_speculate_branch_stall(thread, insn->slot, JUMP_COND(JUMP_PRED_SET),
										   SPEC_DIR,
										   DOTNEWVAL,
										   HINTBITNUM,
										   STRBITNUM,
										   0,
										   thread->last_pkt->pkt_has_dual_jump,
										   insn->is_2nd_jump,
										   (thread->fetch_access.vaddr + insn->encoding_offset*4));
#endif
  },
	(A_BIMODAL_BRANCH)
)


DEF_MACRO(CACHE_MODIFY,
  A=B
  ,
  ()
)

DEF_MACRO(SIM_BUSACCESS,
   ({
	sim_busaccess_t p = B->busaccess;
	if (!p) p = sim_busaccess;
	p(A,B,C,D,E,F,G,H,I);
   })
  ,
  ()
)

DEF_MACRO(SIM_BUSACCESS_ACK,
	/* EJP: implicit "status" is probably bad. */
  do {
	sim_busaccess_t p = B->busaccess;
	if (!p) p = sim_busaccess;
	status = p(A,B,C,D,E,F,G,H,I);
  } while (0)
  ,
  ()
)

DEF_MACRO(SET_PMU_EVENT_STATE,
  (_THREAD_->processor_ptr->pmu_event_state[_PMU_EVENT_NUM_] = 1)
  ,
  ()
)

DEF_MACRO(CLEAR_PMU_EVENT_STATE,
  (_THREAD_->processor_ptr->pmu_event_state[_PMU_EVENT_NUM_] = 0)
  ,
  ()
)

DEF_MACRO(fNOP_EXECUTED,
	{ sys_nop_executed(thread);	},
	()
)

DEF_MACRO(fSETMREG,
          (thread->Mregs[IDX] = (VAL)),
	  ()
)

DEF_MACRO(fGETMREG,
          (thread->Mregs[IDX]),
	  ()
)








DEF_MACRO(fXORBITS,
      {
        for (SUM=0,VAR=0;VAR<32;VAR++) {
           SUM ^= VEC & 1;
           VEC = VEC >> 1;
        }
      },
)

DEF_MACRO(fTIMING,
	if (UNLIKELY(thread->timing_on)) {
		A;
	},
	()
)

DEF_MACRO(IV1DEAD,
	,
	() /*A_NOTE_NOISTARIV1*/
)

DEF_MACRO(FAKE,
	,
	(A_FAKEINSN)
)

DEF_MACRO(fIN_MONITOR_MODE,
	sys_in_monitor_mode(thread),
	(A_IMPLICIT_READS_SSR)
)

DEF_MACRO(fIN_USER_MODE,
	sys_in_user_mode(thread),
	(A_IMPLICIT_READS_SSR)
)

DEF_MACRO(fIN_GUEST_MODE,
	sys_in_guest_mode(thread),
	(A_IMPLICIT_READS_SSR)
)

DEF_MACRO(fGRE_ENABLED,
	fREAD_REG_FIELD(CCR,CCR_GRE),
	(A_IMPLICIT_READS_CCR)
)

DEF_MACRO(fGTE_ENABLED,
	fREAD_REG_FIELD(CCR,CCR_GRE),
	(A_IMPLICIT_READS_CCR)
)

DEF_MACRO(fTRAP1_VIRTINSN,
	((fIN_GUEST_MODE())
		&& (fGRE_ENABLED())
		&& (	((IMM) == 1)
			|| ((IMM) == 3)
			|| ((IMM) == 4)
			|| ((IMM) == 6))),
	()
)

DEF_MACRO(fTRAP0_TO_GUEST,
	((!fIN_MONITOR_MODE())
		&& (fGTE_ENABLED())),
	()
)

DEF_MACRO(fVIRTINSN_RTE,
	do {
		thread->trap1_info = TRAP1_VIRTINSN_RTE;
		fLOG_REG_FIELD(SSR,SSR_SS,fREAD_REG_FIELD(GSR,GSR_SS));
		fLOG_REG_FIELD(CCR,CCR_GIE,fREAD_REG_FIELD(GSR,GSR_IE));
		fLOG_REG_FIELD(SSR,SSR_GM,!fREAD_REG_FIELD(GSR,GSR_UM));
		fBRANCH((fREAD_GELR() & -4),COF_TYPE_RTE);
		fINTERNAL_CLEAR_SAMEPAGE();
	} while (0),
	(A_IMPLICIT_READS_GSR,A_IMPLICIT_WRITES_PC,A_IMPLICIT_WRITES_CCR,A_IMPLICIT_WRITES_SSR)
)

DEF_MACRO(fVIRTINSN_SETIE,
	do { 	fLOG_REG_FIELD(CCR,CCR_GIE,(REG) & 1);
		REG = fREAD_REG_FIELD(CCR,CCR_GIE);
		thread->trap1_info = TRAP1_VIRTINSN_SETIE;
	} while (0),
	(A_IMPLICIT_READS_CCR,A_IMPLICIT_WRITES_CCR)
)

DEF_MACRO(fVIRTINSN_GETIE,
	{ 	thread->trap1_info = TRAP1_VIRTINSN_GETIE;
		REG = fREAD_REG_FIELD(CCR,CCR_GIE);
	},

	(A_IMPLICIT_READS_CCR)
)

DEF_MACRO(fVIRTINSN_SPSWAP,
	do { if (fREAD_REG_FIELD(GSR,GSR_UM)) {
		size4u_t TEMP = REG;
		REG = fREAD_GOSP();
		fWRITE_GOSP(TEMP);
		thread->trap1_info = TRAP1_VIRTINSN_SPSWAP;
	} } while (0),
	(A_IMPLICIT_READS_GSR,A_IMPLICIT_READS_GOSP,A_IMPLICIT_WRITES_GOSP)
)

DEF_MACRO(fGUESTTRAP,
	do {
		if (TRAPTYPE == 0) {
			CALLBACK(thread->processor_ptr->options->trap0_callback,
					 thread->system_ptr, thread->processor_ptr,
					 thread->threadId, IMM);
		}
		WRITE_RREG(REG_GELR,fREAD_NPC());
		fLOG_REG_FIELD(GSR,GSR_UM,!fREAD_REG_FIELD(SSR,SSR_GM));
		fLOG_REG_FIELD(GSR,GSR_SS,fREAD_REG_FIELD(SSR,SSR_SS));
		fLOG_REG_FIELD(GSR,GSR_IE,fREAD_REG_FIELD(CCR,CCR_GIE));
		fLOG_REG_FIELD(GSR,GSR_CAUSE,IMM);
		fLOG_REG_FIELD(SSR,SSR_GM,1);
		fLOG_REG_FIELD(SSR,SSR_SS,0);
		fLOG_REG_FIELD(CCR,CCR_GIE,0);
		fBRANCH(fREAD_GEVB() + ((EXCEPT_TYPE_TRAP##TRAPTYPE)<<2),COF_TYPE_TRAP);
	} while (0),
	()
)

DEF_MACRO(fPREDUSE_TIMING,
	,
	(A_PREDUSE_BSB)
)

DEF_MACRO(CCR_CDID_MUTABILITY,
	(PROC->arch_proc_options->QDSP6_CONSISTENCY_DMN_NUM < 2) ? 0x0 : generate_mutability(proc, 8 - log2(proc->arch_proc_options->QDSP6_CONSISTENCY_DMN_NUM), log2(proc->arch_proc_options->QDSP6_CONSISTENCY_DMN_NUM))
	,
	()
)
